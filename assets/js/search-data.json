{
  
    
        "post0": {
            "title": "Writing custom functions",
            "content": "Questions: . How can I create my own functions? | . Objectives: . Explain and identify the difference between function definition and function call. | Write a function that takes a small, fixed number of arguments and produces a single result. | . Keypoints: . Break programs down into functions to make them easier to understand. | Define a function using def with a name, parameters, and a block of code. | Defining a function does not run it. | Arguments in call are matched to parameters in definition. | Functions may return a result to their caller using return. | . Break programs down into functions to make them easier to understand. . Human beings can only keep a few items in working memory at a time. We understand larger/more complicated ideas by understanding and combining pieces. Analogies for this include: . Components in a machine. | Lemmas when proving theorems. | . Functions serve the same purpose in programs - they Encapsulate complexity so that we can treat it as a single &quot;thing&quot;. Functions also enables re-use - we write a function one time, anduse many times. . Define a function using def with a name, parameters, and a block of code. . Begin the definition of a new function with def. | This is followed by the name of the function. | Then parameters in parentheses. | Then a colon. | Then an indented block of code. | . def print_greeting(): print(&#39;Hello!&#39;) . Defining a function does not run it. . Defining a function does not run it - We must call the function to execute the code it contains. . print_greeting() . Hello! . The arguments in call are matched to parameters in definition. . Functions are most useful when they can operate on different data. We can specify parameters when defining a function. . def print_date(year, month, day): joined = str(year) + &#39;/&#39; + str(month) + &#39;/&#39; + str(day) print(joined) . If we don&#39;t name the arguments when we call the function then they are assigned to the parameters in the order they were defined in the function. . print_date(1871, 3, 19) . 1871/3/19 . Or, we can name the arguments when we call the function, which allows us to specify them in any order: . print_date(month=3, day=19, year=1871) . 1871/3/19 . Functions may return a result to their caller using return. . Use return ... to give a value back to the caller. This may occur anywhere in the function. But functions are easier to understand if return occurs: . At the start to handle special cases. | At the very end, with a final result. | . def average(values): if len(values) == 0: return None return sum(values) / len(values) . a = average([1, 3, 4]) print(&#39;average of actual values:&#39;, a) . average of actual values: 2.6666666666666665 . print(&#39;average of empty list:&#39;, average([])) . average of empty list: None . Every function returns something - a function that doesn&#39;t explicitly return a value automatically returns None. . result = print_date(1871, 3, 19) print(&#39;result of call is:&#39;, result) . 1871/3/19 result of call is: None . . Do the quick-test. . Back to Python part two. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Writing-Functions.html",
            "relUrl": "/2021/08/02/Writing-Functions.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Writing functions - quick test",
            "content": "Identifying Syntax Errors . Read the code below and try to identify what the errors are without running it. | Run the code and read the error message. Is it a SyntaxError or an IndentationError? | Fix the error. | Repeat steps 2 and 3 until you have fixed all the errors. | def another_function print(&quot;Syntax errors are annoying.&quot;) print(&quot;But at least python tells us about them!&quot;) print(&quot;So they are usually not too hard to fix.&quot;) . Show answer def another_function(): print(&quot;Syntax errors are annoying.&quot;) print(&quot;But at least Python tells us about them!&quot;) print(&quot;So they are usually not too hard to fix.&quot;) . Definition and Use . What does the following program print? . def report(pressure): print(&#39;pressure is&#39;, pressure) print(&#39;calling&#39;, report, 22.5) . Show answer calling &lt;function report at 0x7fd128ff1bf8 22.5 . A function call always needs parenthesis, otherwise you get memory address of the function object. So, if we wanted to call the function named report, and give it the value 22.5 to report on, we could have our function call as follows . print(&quot;calling&quot;) report(22.5) . Order of Operations . The example above: . result = print_date(1871, 3, 19) print(&#39;result of call is:&#39;, result) . printed: . 1871/3/19 result of call is: None . Explain why the two lines of output appeared in the order they did. . What’s wrong in this example? . result = print_date(1871,3,19) def print_date(year, month, day): joined = str(year) + &#39;/&#39; + str(month) + &#39;/&#39; + str(day) print(joined) . Show answer The first line of output (1871/3/19) is from the print function inside print_date(), while the second line is from the print function below the function call. All of the code inside print_date() is executed first, and the program then “leaves” the function and executes the rest of the code. | The problem with the example is that the function is defined after the call to the function is made. Python therefore doesn’t understand the function call. | Find the First . Fill in the blanks to create a function that takes a list of numbers as an argument and returns the first negative value in the list. What does your function do if the list is empty? . def first_negative(values): for v in ____: if ____: return ____ . Show answer def first_negative(values): for v in values: if v&lt;0: return v . If an empty list is passed to this function, it returns None: . my_list = [] print(first_negative(my_list) . None . Calling by Name . Earlier we saw this function: . def print_date(year, month, day): joined = str(year) + &#39;/&#39; + str(month) + &#39;/&#39; + str(day) print(joined) . We saw that we can call the function using named arguments, like this: . print_date(day=1, month=2, year=2003) . What does print_date(day=1, month=2, year=2003) print? | When and why is it useful to call functions this way? | Show answer 2003/2/1 | Using named arguments can make code more readable since one can see from the function call what name the different arguments have inside the function. It can also reduce the chances of passing arguments in the wrong order, since by using named arguments the order doesn’t matter. | Encapsulate of If/Print Block . The code below will run on a label-printer for chicken eggs. A digital scale will report a chicken egg mass (in grams) to the computer and then the computer will print a label. . Please re-write the code so that the if-block is folded into a function. . import random for i in range(10): # simulating the mass of a chicken egg # the (random) mass will be 70 +/- 20 grams mass=70+20.0*(2.0*random.random()-1.0) print(mass) #egg sizing machinery prints a label if(mass=85): print(&quot;jumbo&quot;) elif(mass=70): print(&quot;large&quot;) elif(mass&lt;70 and mass=55): print(&quot;medium&quot;) else: print(&quot;small&quot;) . The simplified program follows. What function definition will make it functional? . # revised version import random for i in range(10): # simulating the mass of a chicken egg # the (random) mass will be 70 +/- 20 grams mass=70+20.0*(2.0*random.random()-1.0) print(mass,print_egg_label(mass)) . Create a function definition for print_egg_label() that will work with the revised program above. Note, the function’s return value will be significant. Sample output might be 71.23 large. | A dirty egg might have a mass of more than 90 grams, and a spoiled or broken egg will probably have a mass that’s less than 50 grams. Modify your print_egg_label() function to account for these error conditions. Sample output could be 25 too light, probably spoiled. | Show answer def print_egg_label(mass): #egg sizing machinery prints a label if(mass=90): return(&quot;warning: egg might be dirty&quot;) elif(mass=85): return(&quot;jumbo&quot;) elif(mass=70): return(&quot;large&quot;) elif(mass&lt;70 and mass=55): return(&quot;medium&quot;) elif(mass&lt;50): return(&quot;too light, probably spoiled&quot;) else: return(&quot;small&quot;) . Simulating a dynamical system . In mathematics, a dynamical system is a system in which a function describes the time dependence of a point in a geometrical space. A canonical example of a dynamical system is a system called the logistic map. . Define a function called logistic_map that takes two inputs: x, representing the state of the system at time t, and a parameter r. This function should return a value representing the state of the system at time t+1. . | Using a for loop, iterate the logistic_map function defined in part 1 starting from an initial condition of 0.5 for t_final=10, 100, and 1000 periods. Store the intermediate results in a list so that after the for loop terminates you have accumulated a sequence of values representing the state of the logistic map at time t=0,1,…,t_final. . | Encapsulate the logic of your for loop into a function called iterate that takes the initial condition as its first input, the parameter t_final as its second input and the parameter r as its third input. The function should return the list of values representing the state of the logistic map at time t=0,1,…,t_final. . | Show answer 1. . def logistic_map(x, r): return r * x * (1 - x) . 2. . initial_condition = 0.5 t_final = 10 r = 1.0 trajectory = [initial_condition] for t in range(1, t_final): trajectory[t] = logistic_map(trajectory[t-1], r) . 3. . def iterate(initial_condition, t_final, r): trajectory = [initial_condition] for t in range(1, t_final): trajectory[t] = logistic_map(trajectory[t-1], r) return trajectorys . . See the notebook. . Back to Python part two. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Writing-Functions-Qs.html",
            "relUrl": "/2021/08/02/Writing-Functions-Qs.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "Visualising data with matplotlib",
            "content": "Questions: . How can I plot my data? | How can I save my plot for publishing? | . Objectives: . Plot simple graphs from data. | . Keypoints: . Visualising data can provide key insights. | Use the pyplot library from matplotlib for creating simple visualizations. | Matplotlib contains many customisation options. | Numpy combined with matplotlib allows for further flexibility and insight. | Group related plots using sub-plots. | Many styles of plot are available. | . Visualising data can provide key insights . The mathematician Richard Hamming once said, &quot;The purpose of computing is insight, not numbers,&quot; and the best way to develop insight is often to visualize data. Visualization deserves an entire lecture of its own, but we can explore a few features of Python&#39;s matplotlib library here. . Use the pyplot library from matplotlib for creating simple visualizations. . While there is no official plotting library, matplotlib provides publication-quality figures is the de facto standard. Let&#39;s import the matplotlib plotting module and the NumPy and Pandas libraries that were used in previous lessons. . import matplotlib.pyplot import numpy import pandas . . Warning: If you&#8217;re using an IPython / Jupyter notebook, you&#8217;ll need to execute the %matplotlib inline command at the top of a code cell in order for your matplotlib images to appear in the notebook. The % indicates an IPython magic function - a function that is only valid within the notebook environment. Note that you only have to execute this function once per notebook. . Let&#39;s import the data from the previous lesson and take a look at the average absorption data across all wavelengths: . data = numpy.loadtxt(fname=&#39;../data/UVVis-01-cleaned.csv&#39;, delimiter=&#39;,&#39;) . ave_absorption = numpy.mean(data, axis=0) ave_plot = matplotlib.pyplot.plot(ave_absorption) matplotlib.pyplot.show() . Here, we have put the average per wavelength across all samples in the variable ave_absorption, then asked matplotlib.pyplot to create and display a line graph of those values. . Matplotlib contains many customisation options . At the moment the x-axis has no physical significance; it is an integer range from 0 to 1200. It would be better if the x-axis corresponded to the wavelength. Let&#39;s read in the wavelength from the original (un-cleaned) data file . wavelengths_df = pandas.read_csv(&quot;../data/UVVis-01.csv&quot;,usecols=[0],header=None) . We read in the first column of the data file as this contains the wavelength data. This has created a DataFrame object with a single column. We can convert this to a NumPy array using the DataFrame to_numpy method . wavelengths = wavelengths_df.to_numpy() . We can now ask matplotlib.pyplot to plot a line graph of absorption vs wavelength with labelled axes. . ave_plot = matplotlib.pyplot.plot(wavelengths,ave_absorption) matplotlib.pyplot.xlabel(&quot;wavelength&quot;) matplotlib.pyplot.ylabel(&quot;ave. absorption&quot;) matplotlib.pyplot.show() . There are many other options for customising a plot. For example, we can specify the line colour and y-axis tick labels. . ave_plot = matplotlib.pyplot.plot(wavelengths,ave_absorption,color=&quot;darkgreen&quot;) matplotlib.pyplot.xlabel(&quot;wavelength&quot;) matplotlib.pyplot.ylabel(&quot;ave. absorption&quot;) matplotlib.pyplot.yticks(ticks=numpy.linspace(-0.2,1.2,15)) matplotlib.pyplot.show() . Numpy combined with matplotlib allows for further flexibility and insight . We are interested in analysing a sub-set of the data, from index 650 to index 800. So let&#39;s take a slice of the wavelength and data arrays. . data_slice = data[:,650:800] wavelength_slice = wavelengths[650:800] . We can now plot this sub-set of the absorption data. . max_plot = matplotlib.pyplot.plot(wavelength_slice,numpy.mean(data_slice, axis=0)) matplotlib.pyplot.xlabel(&quot;wavelength&quot;) matplotlib.pyplot.ylabel(&quot;ave. absorption&quot;) matplotlib.pyplot.show() . Let&#39;s have a look at two other statistics: . max_plot = matplotlib.pyplot.plot(wavelength_slice,numpy.max(data_slice, axis=0)) matplotlib.pyplot.xlabel(&quot;wavelength&quot;) matplotlib.pyplot.ylabel(&quot;max absorption&quot;) matplotlib.pyplot.show() . min_plot = matplotlib.pyplot.plot(wavelength_slice,numpy.min(data_slice, axis=0)) matplotlib.pyplot.xlabel(&quot;wavelength&quot;) matplotlib.pyplot.ylabel(&quot;min absorption&quot;) matplotlib.pyplot.show() . Group related plots using sub-plots. . You can group similar plots in a single figure using subplots. This script below uses a number of new commands. The function matplotlib.pyplot.figure() creates a space into which we will place all of our plots. The parameter figsize tells Python how big to make this space. Each subplot is placed into the figure using its add_subplot method. The add_subplot method takes 3 parameters. The first denotes how many total rows of subplots there are, the second parameter refers to the total number of subplot columns, and the final parameter denotes which subplot your variable is referencing (left-to-right, top-to-bottom). Each subplot is stored in a different variable (axes1, axes2, axes3). Once a subplot is created, the axes can be titled using the set_xlabel() command (or set_ylabel()). Here are our three plots side by side: . import numpy import pandas import matplotlib.pyplot data = numpy.loadtxt(fname=&#39;../data/UVVis-01-cleaned.csv&#39;, delimiter=&#39;,&#39;) wavelengths = pandas.read_csv(&quot;../data/UVVis-01.csv&quot;,usecols=[0],header=None).to_numpy() data_slice = data[:,650:800] wavelength_slice = wavelengths[650:800] fig = matplotlib.pyplot.figure(figsize=(10.0, 3.0)) axes1 = fig.add_subplot(1, 3, 1) axes2 = fig.add_subplot(1, 3, 2) axes3 = fig.add_subplot(1, 3, 3) axes1.set_ylabel(&#39;average&#39;) axes1.set_xlabel(&#39;wavelength&#39;) axes1.plot(wavelength_slice,numpy.mean(data_slice, axis=0)) axes2.set_ylabel(&#39;max&#39;) axes2.set_xlabel(&#39;wavelength&#39;) axes2.plot(wavelength_slice,numpy.max(data_slice, axis=0)) axes3.set_ylabel(&#39;min&#39;) axes3.set_xlabel(&#39;wavelength&#39;) axes3.plot(wavelength_slice,numpy.min(data_slice, axis=0)) fig.tight_layout() matplotlib.pyplot.savefig(&#39;./group_plot.png&#39;) matplotlib.pyplot.show() . The call to loadtxt reads our data, and the rest of the program tells the plotting library how large we want the figure to be, that we&#39;re creating three subplots, what to draw for each one, and that we want a tight layout (If we leave out that call to fig.tight_layout(), the graphs will actually be squeezed together more closely). The call to savefig saves our figure to the file group_plot.png. . Tip: We will always use the syntax import numpy to import NumPy. However, in order to save typing, it is often suggested to make a shortcut like so: import numpy as np. If you ever see Python code online using a NumPy function with np (for example, np.loadtxt(...)), it&#39;s because they&#39;ve used this shortcut. When working with other people, it is important to agree on a convention of how common libraries are imported. . Many styles of plot are available . See the matplotlib gallery or Python graph gallery for lots of examples . . Do the quick-test. . Back to data analysis and visualisation. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Visualising-Data.html",
            "relUrl": "/2021/08/02/Visualising-Data.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "Cleaning data - quick test",
            "content": "Plot Scaling I . Why do all of our plots stop just short of the upper end of our graph? . Show answer Because matplotlib normally sets x and y axes limits to the min and max of our data (depending on data range) . If we want to change this, we can use the set_ylim(min, max) method of each ‘axes’, for example: . axes3.set_ylim(0,6) . Plot Scaling II . Update your plotting code to automatically set a more appropriate scale. (Hint: you can make use of the max and min methods to help.) . Show answer # One method axes3.set_ylabel(&#39;min&#39;) axes3.plot(numpy.min(data, axis=0)) axes3.set_ylim(0,6) . # A more automated approach min_data = numpy.min(data, axis=0) axes3.set_ylabel(&#39;min&#39;) axes3.plot(min_data) axes3.set_ylim(numpy.min(min_data), numpy.max(min_data) * 1.1) . Make Your Own Plot . Create a plot showing the standard deviation (numpy.std) of the absorption data for each day across all patients. . Show answer std_plot = matplotlib.pyplot.plot(numpy.std(data, axis=0)) matplotlib.pyplot.show() . Moving Plots Around . Modify the program to display the three plots on top of one another instead of side by side. . Show answer import numpy import matplotlib.pyplot data = numpy.loadtxt(fname=&#39;UVVis-01-cleaned.csv&#39;, delimiter=&#39;,&#39;) # change figsize (swap width and height) fig = matplotlib.pyplot.figure(figsize=(3.0, 10.0)) # change add_subplot (swap first two parameters) axes1 = fig.add_subplot(3, 1, 1) axes2 = fig.add_subplot(3, 1, 2) axes3 = fig.add_subplot(3, 1, 3) axes1.set_ylabel(&#39;average&#39;) axes1.plot(numpy.mean(data, axis=0)) axes2.set_ylabel(&#39;max&#39;) axes2.plot(numpy.max(data, axis=0)) axes3.set_ylabel(&#39;min&#39;) axes3.plot(numpy.min(data, axis=0)) fig.tight_layout() matplotlib.pyplot.show() . . See the notebook. . Back to Data analysis and visualisation. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Visualising-Data-Qs.html",
            "relUrl": "/2021/08/02/Visualising-Data-Qs.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "Version control and Github",
            "content": ". Questions: . What is version control and why is it useful? | How can I use Git to version control my files? | What is the difference between Git and Github? | . Objectives: . Describe the benefits of version control | Initialise a Git repository from the command line or through the Github interface | Use command line git to version control your work locally | Use git and Github to store and share a remote copy of your work | . Keypoints: . Version control is the ultimate undo button for code | Github is very widely used in academia and industry | Use git init to initialise an empty git repository | Use git status for a summary of your repository | Git uses a two-step process for version control: git add and git commit | See the changes made to a file using git diff | Use git log to see a record of the commits that have been made | You can add and commit multiple files | Use git push and git pull to communicate with a remote repository | For some tasks the Github web interface is a useful alternative | . . Version control is the ultimate undo button for code . . There are several benefits to version control: . Nothing that is committed to version control is ever lost, unless you work really, really hard at it. | You can go back in time to see exactly who wrote what on a particular day, or what version of a program was used to generate a particular set of results. | We can revert to a previous version, much like the “undo” feature in an editor. | When several people collaborate in the same project, it’s possible to accidentally overlook or overwrite someone’s changes. The version control system automatically notifies users whenever there’s a conflict between one person’s work and another’s. | . Version control is what software professionals use to keep track of what they’ve done and to collaborate with other people. Every large software development project relies on it, and most programmers use it for their small jobs as well. And it isn’t just for software: books, papers, small data sets, and anything that changes over time or needs to be shared can and should be stored in a version control system. . . Version control is not well-suited to binary files as much of the functionality that we will see later does not work efficiently with these types of file. Github is very widely used in academia and industry . In this lesson we will be using a version control system called git. You can install and use git locally on your own computer (without any internet connection). However there are several online services that will store remote copies of your git repositories. Remote copies are highly encouraged for two reasons: . as a backup in case your computer dies | to share your work with other people | . In this lesson we will be using this most popular git-based tool - Github. This is also where all of the code for this website is stored. We will see later in the course that Github can also be used to host website and automate tasks. . Use git init to initialise an empty git repository . First, let’s create a folder to hold the files we want to version control: . mkdir my_project cd my_project ls . Second, create a file. You can use the in-built terminal editor vim or nano, or any plain-text editor (such as Notepad). Whichever editor you use, you need to make sure you save the file in the my_scripts folder. . vim hello.py . . To start writing in vim type `i`. def hello_world(): print(&quot;hello_world&quot;) if __name__ == &quot;__main__&quot;: hello_world() . . We are not writing the Python shebang as we treating this like a Python module (with functions/code you can import) rather than a Python script that is ran from top-to-bottom. . To save and exit vim you type `Esc`, `:wq`, `Enter`. Third, create a git repository to version control this new file: . git init . The git repository is a hidden file so to see it we need to use the command: . ls -a . . .. .git hello.py . Git stores all of the repository data in the .git directory. To delete the repository you delete this hidden folder . rm -rf .git . . Always take care using the command `rm -rf`. This permenantly deletes a directory and everything within the directory - and it will not be available in the recylcing bin! Use git status for a summary of your repository . git status is a very useful command. It summarises the status of your git repository. . git status . On branch master No commits yet Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) hello.py nothing added to commit but untracked files present (use &quot;git add&quot; to track) . . For a long time the default branch in most Git repositories was named `master`. Fortunately, many people have become aware that this terminology should be replaced to something more inclusive: `main`. If you branch is called `master` you can rename it using `git branch -m master main`. The git outputs are generally quite helpful. Here we are told that there is “nothing added to commit but untracked files present” and git suggests that we use “git add” to track. What is this all about? . Git uses a two-step process for version control: git add and git commit . If you think of Git as taking snapshots of changes over the life of a project, git add specifies what will go in a snapshot (putting things in the staging area), and git commit then actually takes the snapshot, and makes a permanent record of it (as a commit). . . First let’s add our new file: . git add hello.py git status . On branch main No commits yet Changes to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: hello.py . Second let’s commit our file to the repository history. We provide a short commit message, describing what the changes are and/or why they were made: . git commit -m &quot;function to demonstrate the if __name__ == __main__ syntax&quot; . [main (root-commit) 0f7a7b4] create a hello_world function 1 file changed, 5 insertions(+) create mode 100644 hello.py . . Good commit messages often describe *why* a change was made. For example &#39;fixed a bug that was breaking the unit tests&#39;. Information about *what* changed can be gotten by asking git to compare different versions of the file (we&#39;ll see this later in the lesson). The two stage process is useful because it means you can carefully craft your commit snapshots. For example, I may make several changes to several files. I then want to version control the changes. Instead of being forced to use a single commit for changes that are unrelated I can split my changes into several smaller commits - for example, one for “implementing a new algorithm to find the minima” and one for “improved function docstrings”. . See the changes made to a file using git diff . Now let’s make an edit to the file . vim hello.py . def hello_world(): &quot;function to greet the world&quot; print(&quot;hello_world&quot;) if __name__ == &quot;__main__&quot;: hello_world() . We can see the difference between the latest version of the file and the version of the file stored in the git repository using git diff: . git diff . diff --git a/hello.py b/hello.py index cd6a6ec..df4dfe3 100644 a/hello.py +++ b/hello.py @@ -1,4 +1,5 @@ def hello_world(): + &quot;function to greet the world&quot; print(&quot;helloooo world&quot;) if __name__ == &quot;__main__&quot;: (END) . Commit this change to the repository: . git add git commit -m &quot;include docstring as per project guidelines&quot; git status . On branch main nothing to commit, working tree clean . Use git log to see a record of the commits that have been made . git log . commit b4bfc23897e6dd3c8faed6f101b5438ff0cc98c1 (HEAD -&gt; main) Author: Lucy Whalley &lt;l.whalley@northumbria.ac.uk&gt; Date: Mon Nov 22 20:40:14 2021 +0000 include docstring as per project guidelines commit 0f7a7b4e03439cd9f854dec2f438a85ffbd31fd9 Author: Lucy Whalley &lt;l.whalley@northumbria.ac.uk&gt; Date: Mon Nov 22 20:24:32 2021 +0000 function to demonstrate the if __name__ == __main__ syntax . You can add and commit multiple files . Create a new python module that we will import into out “hello.py” module: . vim bonjour.py . def bonjour_le_monde(): print(&quot;bonjour le monde!&quot;) . vim hello.py . import bonjour def hello_world(): &quot;function to greet the world&quot; print(&quot;hello_world&quot;) if __name__ == &quot;__main__&quot;: hello_world() bonjour.bonjour_le_monde() . python hello.py . hello_world bonjour le monde! . git status . On branch main Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: hello.py Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) __pycache__/ bonjour.py no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) . We can add and commit both files at the same time . git add hello.py bonjour.py git commit -m &quot;implement and import french translation&quot; . [main 8fb9bff] implement and import french translation 2 files changed, 6 insertions(+), 1 deletion(-) create mode 100644 bonjour.py . Use git push and git pull to communicate with a remote repository . Currently all of our files and changes are stored locally on our computer. . In practice, most programmers hold up-to-date copies of their files on a remote service such as Github. To create a remote repository on the Github servers follow these four steps: . Log into Github | Click on the “+” icon in the top right hand corner to create a new repository | Provide a name and description | Select “Add a README file” and “Choose a license” | . To decide which open source license you would like to use visit [https://choosealicense.com/](https://choosealicense.com/). You now need to push your local repository to the remote server. To do so, follow the commands under “…or push an existing repository from the command line” into your terminal (you need to be in the my_project folder when you do this). . git remote add origin https://github.com/lucydot/my_project.git git push -u origin main . If you make changes to the files on the remote Github repository, you can pull these changes to your local repository with . git pull . It is important to git push and git pull frequently so that your local and remote repositories stay up-to-date with one another. . For some tasks the Github web interface is a useful alternative . We have already seen how to create a repository on Github. You can also use the Github web interface (“drag and drop”) to add and commit files. . TASKS . Use Github to: . Create a repository for holding the work done in this module | Create a README.md and select an open source license | Use the Github drag-and-drop interface to upload the script(s) you wrote in the previous lesson | Extension: . Use the git command line to version control and upload the Jupyter Notebooks (or any other file) generated during this course |",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Version_control.html",
            "relUrl": "/2021/08/02/Version_control.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post5": {
            "title": "Variable scope",
            "content": "Questions: . How do function calls actually work? | How can I determine where errors occurred? | . Objectives: . Identify local and global variables. | Identify parameters as local variables. | Read a traceback and determine the file, function, and line number on which the error occurred, the type of error, and the error message. | . Keypoints: . The scope of a variable is the part of a program that can &#39;see&#39; that variable. | . The scope of a variable is the part of a program that can &#39;see&#39; that variable. . There are only so many sensible names for variables. People using functions shouldn&#39;t have to worry about what variable names the author of the function used. Equally, people writing functions shouldn&#39;t have to worry about what variable names the function&#39;s caller uses. The part of a program in which a variable is visible is called its scope. . pressure = 103.9 def adjust(t): temperature = t * 1.43 / pressure return temperature . pressure is a global variable - it is defined outside any particular function and is visible everywhere. t and temperature are local variables in adjust. They are defined in the function, and not visible in the main program. . print(&#39;adjusted:&#39;, adjust(0.9)) print(&#39;temperature after call:&#39;, temperature) . adjusted: 0.01238691049085659 . NameError Traceback (most recent call last) &lt;ipython-input-3-e73c01f89950&gt; in &lt;module&gt; 1 print(&#39;adjusted:&#39;, adjust(0.9)) -&gt; 2 print(&#39;temperature after call:&#39;, temperature) NameError: name &#39;temperature&#39; is not defined . . Do the quick-test. . Back to Python part two. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Variable-Scope.html",
            "relUrl": "/2021/08/02/Variable-Scope.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post6": {
            "title": "Variable scope - quick test",
            "content": "Local and Global Variable Use . Trace the values of all variables in this program as it is executed. (Use ‘—’ as the value of variables before and after they exist.) . limit = 100 def clip(value): return min(max(0.0, value), limit) value = -22.5 print(clip(value)) . Reading Error Messages . Read the traceback below, and identify the following: . How many levels does the traceback have? | What is the file name where the error occurred? | What is the function name where the error occurred? | On which line number in this function did the error occurr? | What is the type of error? | What is the error message? | KeyError Traceback (most recent call last) &lt;ipython-input-2-e4c4cbafeeb5&gt; in &lt;module&gt;() 1 import errors_02 -&gt; 2 errors_02.print_friday_message() /Users/ghopper/thesis/code/errors_02.py in print_friday_message() 13 14 def print_friday_message(): &gt; 15 print_message(&quot;Friday&quot;) /Users/ghopper/thesis/code/errors_02.py in print_message(day) 9 &quot;sunday&quot;: &quot;Aw, the weekend is almost over.&quot; 10 } &gt; 11 print(messages[day]) 12 13 KeyError: &#39;Friday&#39; . Show answer Three levels. | errors_02.py | print_message | Line 11 | KeyError. These errors occur when we are trying to look up a key that does not exist (usually in a data structure such as a dictionary). We can find more information about the KeyError and other built-in exceptions in the Python docs. | KeyError: &#39;Friday&#39; | . See the notebook. . Back to Python part two. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Variable-Scope-Qs.html",
            "relUrl": "/2021/08/02/Variable-Scope-Qs.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post7": {
            "title": "The strange attractor",
            "content": ". Questions: . How do I solve simultaneous ODEs? | How do I solve second-order ODEs (and higher)? | . Objectives: . Use Euler&#39;s method, implemented in Python, to solve a set of simultaneous ODEs | Use Euler&#39;s method, implemented in Python, to solve a second-order ODE | Understand how the same method could be applied to higher order ODEs | . . Computers don&#39;t care so much about the type of differential equation . In the previous lesson we used Euler&#39;s method to model radioactive decay. To demonstrate the method we deliberately chose a simple example (a linear, first order, separable ODE with one dependent variable). We have seen that this equation can also be solved analytically, so really there is no need for approximate numerical methods in this case. . However there are a large number of physical equations that cannot be solved analytically, and that rely on numerical methods for their modelling. . For example, the Lotka-Volterra equations for studying predator-prey interactions have multiple dependent variables and the Cahn-Hilliard equation for modelling phase separation in fluids is non-linear. These equations can be solved analytically for particular, special cases only. . Computers don&#39;t care whether an equation is linear or non-linear, multi-variable or single-variable, the numerical method for studying it is much the same - with the caveat that numerical methods are approximate and so we need to think about the accuracy of the methods used. . Simultaneous ODEs can be solved using numerical methods . One class of problems that are difficult to solve analytically are simultaenous ODEs. These are equations where the derivative of each dependent variable can depend on any of the variables (dependent or independent). For example, . begin{eqnarray} frac{ mathrm{d}x}{ mathrm{d}t} &amp;=&amp; xt + y frac{ mathrm{d}y}{ mathrm{d}t} &amp;=&amp; mathrm{sin}^2 omega t - xy end{eqnarray}A famous set of simulataneous ODEs are the Lorenz equations, which are the subject of this lesson. . begin{eqnarray} frac{ mathrm{d}x}{ mathrm{d}t} &amp;=&amp; sigma(y-x) frac{ mathrm{d}y}{ mathrm{d}t} &amp;=&amp; rx-y-xz frac{ mathrm{d}z}{ mathrm{d}t} &amp;=&amp; xy-bz end{eqnarray}There three dependent variables - $x$, $y$ and $z$, and one independent variable $t$. There are also three constants - $ sigma$, $r$ and $b$. . For particular values of $ sigma$, $r$ and $b$ the Lorenz systems has chaotic behaviour (a strong dependence on the initial conditions) and for a subset of these, there is also fractal structure called the strange attractor. . Euler&#39;s method is easily extended to simultaneous ODEs . In the previous lesson we were introduced to Euler&#39;s method for the single variable case: . begin{equation} N(t+h) = N(t) + hf(N,t). end{equation}This can be easily extended to the multi-variable case using vector notation: . begin{equation} mathbf{r}(t+h) = mathbf{r}(t) + h mathbf{f}( mathbf{r},t). end{equation}We have seen that arrays can be easily represented in Python using the NumPy library. This allows us to do arithmetic with vectors directly (rather than using verbose workarounds such as for loops), so the code is not much more complicated than the one-variable case. . First, let&#39;s import the standard scientific libraries we will be using - Numpy and Matplotlib: . import numpy as np import matplotlib.pyplot as plt . Now we define the function that describe the Lorenz system. . Note: When the operands are NumPy arrays, the operations are automatically element-wise vector operations. . def Lorenz(sigma,r,b,xyz): x = xyz[0] y = xyz[1] z = xyz[2] fx = sigma*(y-x) fy = (r*x)-y-(x*z) fz = (x*y)-(b*z) return np.array([fx,fy,fz],float) . Next we&#39;ll list the simulation parameters (start time, end time, number of time steps and step size), the initial values for $x$, $y$ and $z$, and the constants $ sigma$, $r$ and $b$. . start = 0 # start time end = 50 # end time num_steps = 3000 # number of time steps h = (end-start) / num_steps # time step size # intitial conditions: x=0, y=1, z=0 xyz = np.array([0,1,0],float) # constants sigma = 10 r = 28 b = 8/3 . We use the Numpy arange function to generate a list of evenly spaced times at which to evaluate the system. We also create an empty list to hold the values for $x$, $y$ and $z$ that we are yet to calculate. . time_list = np.arange(start,end,h) # create empty arrays to hold the calculated values x_points = [] y_points = [] z_points = [] . Finally, we apply Euler&#39;s method using a For loop. Note that the order of operations in the loop body is important. . for time in time_list: x_points.append(xyz[0]) y_points.append(xyz[1]) z_points.append(xyz[2]) xyz += h*Lorenz(sigma,r,b,xyz) . To visualise the strange attractor we can plot the values of $z$ against $y$: . plt.plot(x_points,z_points) . [&lt;matplotlib.lines.Line2D at 0x7f92d5481790&gt;] . Higher order ODEs can be re-cast as simultaneous ODEs and solved in the same way . Many physical equations are second-order or higher. The general form for a second-order differential equation with one dependent variable is: . begin{equation} frac{ mathrm{d}^2x}{ mathrm{d}t^2} = f left(x, frac{ mathrm{d}x}{ mathrm{d}t},t right) end{equation}Luckily, we can re-cast a higher order equation as a set of simultaneous equations, and then solve in the same way as above. . Let&#39;s use the non-linear pendulum as an example. For a pendulum with an art of length $l$ and a bob of mass $m$, Newton&#39;s second law ($F=ma$) provides the following equation of motion: . begin{equation} ml frac{ mathrm{d}^2 theta}{ mathrm{d}t^2} = -mg sin( theta), end{equation}where $ theta$ is the angle of displacement of the arm from the vertical and $l frac{ mathrm{d}^2 theta}{ mathrm{d}t^2}$ is the acceleration of the mass in the tangential direction. The exact solution to this equation is unknown, but we now have the knowledge needed to find a numerical approximation. . The equation can be re-written as: . begin{equation} frac{ mathrm{d}^2 theta}{ mathrm{d}t^2} = - frac{g}{l} sin( theta) end{equation}We define a new variable $ omega$: . begin{equation} frac{ mathrm{d} theta}{ mathrm{d}t} = omega end{equation}and substitute this into the equation of motion: . begin{equation} frac{ mathrm{d} omega}{ mathrm{d}t} = - frac{g}{l} sin( theta). end{equation}These two expressions form a set of simultaneous equations that can be solved numerically using the method outlined above. . . Keypoints: . Computers don&#39;t care so much about the type of differential equation | Simulatenous ODEs can also be solved using numerical methods | Euler&#39;s method is easily extended to the multi-variable case | Higher order ODEs can be re-cast as simultaneous ODEs and solved the same way | . . . Do the quick-test. . Back to Modelling with Ordinary Differential Equations. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Strange-Attractor.html",
            "relUrl": "/2021/08/02/Strange-Attractor.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post8": {
            "title": "The strange attractor - quick test",
            "content": "There are no quick test questions - can you think of a good one? Then suggest it here. . You can practice solving coupled and higher order equations in the exercises. .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Strange-Attractor-Qs.html",
            "relUrl": "/2021/08/02/Strange-Attractor-Qs.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post9": {
            "title": "Documentation and testing",
            "content": "In the course so far you have learnt the building blocks of Python. With this you can write a surprising amount of useful code! However our efforts are rewarded many times over if we can share the code we have written. Sharing your code: . clearly demonstrates your programming skills to future employers and/or supervisors | enables other researchers to use your code, progressing science forwards | establishes you an active participant in a particular domain or community of practice (people know who you are) | . However it is unfortunately not enough to stick our Python scripts / modules online and hope that other people will use them. We need to use tests to demonstrate that our software is reliable, and we need to write documentation so that others understand how best to use the code. These two topics - testing and documentation - are the focus of this lesson. . Please note that the following text has been closeley adapted, with permission, from the Code Refinery software testing lesson and the Code Refinery documentation lesson. . Untested software can be compared to uncalibrated detectors . “Before relying on a new experimental device, an experimental scientist always establishes its accuracy. A new detector is calibrated when the scientist observes &gt; its responses to known input signals. The results of this calibration are compared against the expected response.” . [From Testing and Continuous Integration with Python, created by K. Huff] . Simulations and analysis using software should be held to the same standards as experimental measurement devices! . Further motivation for testing: . A Scientist’s Nightmare: Software Problem Leads to Five Retractions | Researchers find bug in Python script may have affected hundreds of studies | . Testing helps to detect errors before they cause problems . In software tests, expected results are compared with observed results in order to establish accuracy: . As projects grow, it becomes easier to break things without noticing immediately | Software defects can be caused by both human errors and non-controllable events (i.e. environmental conditions) | Testing is essential for research software because we care about reproducibility of scientific results | . Testing also encourages others to use your code: . It provides a way for users to see if the code is installed correctly | It allows users to better judge the quality of the code | . Finally, testing encourages other developers to contribute to your code as it is easier for external developers to contribute to the project without breaking your code (or at least it is clear when they have broken the code!) . However bear in mind that tested code does not mean the code is perfect; “Program testing can be used to show the presence of bugs, but never to show their absence!” (Edsger W. Dijkstra) . Discussion question: Can you think of examples where it is not necessary to share your code? . Show answer Some examples where you may choose not to test your code: . A Jupyter notebook which produces a plot and you know by looking at the plot whether it worked | A short, ‘obviously correct’ Python script which you never intend to reuse | . Use assertions for things you believe will/should never happen. . def kelvin_to_celsius(temp_k): &quot;&quot;&quot; Converts temperature in Kelvin to Celsius. &quot;&quot;&quot; assert temp_k &gt;= 0.0, &quot;ERROR: negative T_K&quot; temp_c = temp_k - 273.15 return temp_c . Units testing is for small components (units) of a code . def fahrenheit_to_celsius(temp_f): &quot;&quot;&quot;Converts temperature in Fahrenheit to Celsius. &quot;&quot;&quot; temp_c = (temp_f - 32.0) * (5.0/9.0) return temp_c # This is the test function: `assert` raises an error if something # is wrong. def test_fahrenheit_to_celsius(): temp_c = fahrenheit_to_celsius(temp_f=100.0) expected_result = 37.777777 assert abs(temp_c - expected_result) &lt; 1.0e-6 . Unit tests are functions | Unit testing is used to test one unit: for example, a single function | . Question: In the example above we want to check if the calculated temp_c is equal to the expected_result. Why do we use the assert statement abs(temp_c - expected_result) &lt; 1.0e-6 instead of the simpler assert statement temp_c == expected_result? . Show answer Due to the inherent limitations to computational accuracy, we should not test for the exact equality between two floats. Instead we check that they are the same to within a numerical tolerance (in this case 1.0e-6). For more details please see the lesson Evaluating numerical errors and accuracy. . Another commonly used type of testing is called end-to-end. End-to-end tests check if the software is working as a whole, from beginning to end. For example, you input example data at the start of a simulation and then check that the end results of the simulation are correct. . Pytest can be used to implement a Python test suite . Rather than running unit tests one-by-one we can use pytest to automatically find and run all the tests within a project; pytest collects and runs all test functions starting with test_. . In the following steps we will make a simple Python function and use pytest to test it. . Create a new directory and change into it: | mkdir pytest-example cd pytest-example . Then create a file called example.py and copy-paste the following code into it: | def add(a, b): return a + b def test_add(): assert add(2, 3) == 5 assert add(&#39;space&#39;, &#39;ship&#39;) == &#39;spaceship&#39; . This code contains one genuine function and a test function. pytest finds any functions beginning with test_ and treats them as tests. . Let us try to test it with pytest: | pytest -v example.py . ============================================================ test session starts ================================= platform linux -- Python 3.7.2, pytest-4.3.1, py-1.8.0, pluggy-0.9.0 -- /home/user/pytest-example/venv/bin/python3 cachedir: .pytest_cache rootdir: /home/user/pytest-example, inifile: collected 1 item example.py::test_add PASSED ========================================================= 1 passed in 0.01 seconds =============================== . Yay! The test passed! . Let us break the test! Introduce a code change which breaks the code and check whether pytest detects the change: | pytest -v example.py . ============================================================ test session starts ================================= platform linux -- Python 3.7.2, pytest-4.3.1, py-1.8.0, pluggy-0.9.0 -- /home/user/pytest-example/venv/bin/python3 cachedir: .pytest_cache rootdir: /home/user/pytest-example, inifile: collected 1 item example.py::test_add FAILED ================================================================= FAILURES ======================================= _________________________________________________________________ test_add _______________________________________ def test_add(): &gt; assert add(2, 3) == 5 E assert -1 == 5 E --1 E +5 example.py:6: AssertionError ========================================================= 1 failed in 0.05 seconds ============== . Notice how pytest is smart and includes context: lines that failed, values of the relevant variables. . Question: In the example above we have compared integers. In this optional exercise we want to learn how to compare floating point numbers since they are more tricky. . The following test will fail and this might be surprising. Try it out: . def add(a, b): return a + b def test_add(): assert add(0.1, 0.2) == 0.3 . Your goal: find a more robust way to test this addition. . Show answer One solution is to use pytest.approx: . from pytest import approx def add(a, b): return a + b def test_add(): assert add(0.1, 0.2) == approx(0.3) . But maybe you didn’t know about pytest.approx: and did this instead: . def test_add(): result = add(0.1, 0.2) assert abs(result - 0.3) &lt; 1.0e-7 . This is OK but the 1.0e-7 can be a bit arbitrary. . Documentation comes in different forms . There is nothing in the programming field more despicable than an undocumented program.  — Ed Yourdon, Software Engineering pioneer . Tutorials: learning-oriented, allows the newcomer to get started | How-to guides: goal-oriented, shows how to solve a specific problem | Explanation: understanding-oriented, explains a concept | Reference: information-oriented, describes the machinery | . These are distinct. For an excellent discussion, please see What nobody tells you about documentation. . There is no one size fits all: however a good starting point is almost always to include a README file with your code. Your code may, depending on the number of users apart from yourself, also include: . Purpose | Authors | License | Recommended citation | Copy-paste-able example to get started | Dependencies and their versions or version ranges | Installation instructions | Tutorials covering key functionality | Reference documentation (e.g. API) covering all functionality | How do you want to be asked questions (mailing list or forum or chat or issue tracker) | FAQ section | Contribution guide | . Question: Visit the Github repository for effmass and explore the repository and documentation site. . Which different types (tutorials/how-to/explanation/reference) of documentation can you find? | Are all the items in the bullet point list included? | Show answer There is a README file with basic installation how-to instructions and an overview of the functionality. | There are notebook tutorials for allowing newcomers to get started. | There is API reference information here which describes how each function works. | There is a paper which explains some of the concepts behind the code (for example the different definitions of effective mass). | . | All of the bullet points on the list are included except i) there is no FAQ ii) the example is a Jupyter notebook and is not quickly copy-pastable (you would end up with the code and the surrounding text, which would then need to be removed). | The README file is important for users . The README file is important as it is usually the first thing people look at when visiting a code repository. | Use it to communitcate important information about your project. | Write your README using a markup language such as Markdown. Github will automatically format your markdown file when you push it to your Github repository. | The README should be in the top-level of your repository | To make your README extra friendly you can use emojis. | A README file might contains: A summary of the software purpose, author list, a link to the license file, a recommended citation, installation instructions and a list of code dependencies (e.g. numpy, matplotlib), a link to the issues tracker, and any other contact details. | . In-code documentation is important for code developers . In-code documentation are very useful for people wanting to contribute to your code. | They can also be used to auto-generate online documentation for functions/classes (for more information see the extension task below). | The most commonly used Python in-code documentation are comments starting with # and Python docstrings | . Question: Which of the comments below is the best and why? . # Now we check if temperature is larger then -50: if temperature &gt; -50: print(&#39;do something&#39;) . # We regard temperatures below -50 degrees as measurement errors if temperature &gt; -50: print(&#39;do something&#39;) . Show answer The first comment describes what happens in this piece of code, whereas the second describes why this piece of code is there, i.e. its purpose. Comments like the second comment are much more useful. . A docstring is a structured comment associated to a segment of code (i.e. a function or class). . We have already written basic docstrings. Here we will see how to write Google style docstrings. Let’s look at the following function: . def mean_temperature(temperatures): return sum(temperatures)/len(temperatures) . We can make it clearer what this function does and how to use it using a docstring. A good docstring describes: . What the function does | What goes in (including the type of the input variables) | What goes out (including the return type) | . def mean_temperature(temperatures): &quot;&quot;&quot; Get the mean temperature Args: data (list): A list with air temperature measurements. Returns: The mean air temperature (float) &quot;&quot;&quot; return sum(temperatures)/len(temperatures) . Two key advantages of docstrings are: . Python parses docstrings, for example calling the help function will display the docstring: try help(mean_temperature) | You can generate your documentation as you are generating the code. In fact, thinking carefully about what the input/output/behaviour should be may encourage you to write better code! | . TASKS . Write and run a unit test for the Lorenz() function in the Lorenz.py script you developed in a previous lesson. . | Write a docstring for the Lorenz() function in the Lorenz.py script. Follow the Google docstring format as in the example above. . | Upload your new file to the remote Github repository you created in the previous lesson. . | EXTENSION TASKS: Automate everything! . Automated testing using Continuous Integration allows us to automatically run tests when there is a commit to a Github repository. Following the tutorial from The Code Refinery, implement continuous integration for a Github repository holding Lorenz.py (this could be the Github repository you created in the previous lesson). Note that you will have to adapt the workflow file so that pip installs the python packages imported in your script (for Lorenz.py the packages are numpy and matplotlib). . | API (Application Programming Interface) documentation can be automatically generated using a tool such as pdoc3. These tools read in all of the docstrings within a Python package and generate a webpage accordingly. For example, see the API documentation for the effmass project. Automatic API documentation is a real gamechanger; as long as we write update the docstrings alongside our code, we can quickly generate new documentation. Following the documentation on pdoc3 generate a html page with the API documentation for Lorenz.py. In the next lesson you will learn how to host this page using Github Pages. . |",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Sharing_code.html",
            "relUrl": "/2021/08/02/Sharing_code.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post10": {
            "title": "Setup",
            "content": "To participate in this course you will need access to Python and an up-to-date web browser. You will also need a range of Python libraries from the standard scientific stack: Jupyter, Numpy, Scipy and Matplotlib. . All of the software needed for this course is pre-installed in the MPEE computers at Northumbria University. However we highly recommend you install Python on your own laptop or computer so that you can work from home, or from a cafe - wherever you work best! To install Python and the scientific libraries on your personal laptop or desktop carefully follow the instructions listed below. . You can also run the Python Jupyter Notebook files remotely through the binder or colab services whenever you see an icon (e.g. like those at the top of this page). But be warned! Any changes you make are not saved and the service can time-out after a period of inactivity (usually ~20 minutes). This service should be used as a if-nothing-else-works plan only. . You will also need a user account at github.com - Basic GitHub accounts are free. . Python . Python is a popular language for scientific computing, and great for general-purpose programming as well. Installing all of its scientific packages individually can be a bit difficult, however, so we recommend the all-in-one installer Anaconda. . Windows - video tutorial . Open this link with your web browser. . | Download the Anaconda for Windows installer with Python 3. (If you are not sure which version to choose, you probably want the 64-bit Graphical Installer Anaconda3-…-Windows-x86_64.exe) . | Double-click the executable and install Python 3 using MOST of the default settings, the only exception is to check Add Anaconda to my PATH environment variable. . | Mac OS X - video tutorial . Open this link with your web browser. . | Download the Anaconda Installer with Python 3 for macOS (you can either use the Graphical or the Command Line Installer). . | Install Python 3 by running the Anaconda Installer using all of the defaults for installation. . | A browser for Jupyter . We will teach Python using the [Jupyter notebook][https://jupyter.org/], a programming environment that runs in a web browser. Jupyter requires a reasonably up-to-date browser, preferably a current version of Chrome, Safari, or Firefox (note that Internet Explorer version 9 and below are not supported). Jupyter is installed as part of the Anaconda package for Python. . How to launch a Jupyter Notebook . Search for “Anaconda” using your system search bar | Select “Anaconda Launcher” | Click on the “Launch” button below “Jupyter Notebook”. You should see a file browser pop up as a new tab on your browser. | Click new towards the top right hand side of the browser window. | Select Python 3 in the drop-down menu bar. This will open a Python 3 Notebook file a new tab in your browser. |",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Setup.html",
            "relUrl": "/2021/08/02/Setup.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post11": {
            "title": "Python scripts and the Unix terminal",
            "content": ". Questions: . How can I convert my Jupyter Notebook into a Python script? | What are the basic Unix commands needed for running a Python script from the command line? | How can the script read user-specified values (command line arguments?) | . Objectives: . Convert a Jupyter Notebook into a Python script | Navigate around a computer using the Unix commands ls, cd and pwd, ./, .. and ~ | Run a Python script from the command line | Read in command line arguments using the sys.argv array | . Keypoints: . A Python script is a .py file that contains Python code only | Use a plain text editor to write a Python script | Use a shebang at the top of your file to indicate that it is Python code | Terminals are a way to interact with a computer without using a Graphical User Interface (GUI) | You can navigate around your computer using the Unix shell | To run your python code type the filepath into the terminal | Use sys.argv to read in command line arguments | . . A Python script is a .py file that contains Python code only . In the course so far we have used Jupyter Notebooks (.ipynb files) to develop and share code. | Jupyter Notebooks are useful as they allow us to develop a narrative (of code, text and images). | However sometimes running the code as a Python script (.py file) is more suitable. For example, you may want to run code on a High-Performance-Computer which you interact with through the command line terminal. Or perhaps you want to avoid the problems that can arise from running Jupyter notebook cells out of order. | A Python script is a .py file that contains Python code only (though comments with a # are still possible) | . Use a plain text editor to write a Python script . To write a Python script you can use any plain text editor (not Microsoft Word). | On Windows you could use Notepad. On a Mac you can use TextEdit but you must select Make plain text under the Format menu. The Sublime text editor is free to download on an unlimited trial basis and is a popular option for both systems. | . Use a shebang at the top of your file to indicate that it is Python code . At the top of your empty text file insert the following line: #!/usr/bin/env python3. | This is the Python shebang. This line is not mandatory but it has two benefits: a reader can quickly identify it as a Python script, and the script can be ran without using the Python command (more on this later). | Beneath this you write the Python code. In this example, we will copy across code from an earlier tutorial example. We will save the resulting plot to a file, and also print out some messages as the programme is running. | Save your Python file with a .py extension - e.g. Lorenz.py | . #!/usr/bin/env python3 import numpy as np import matplotlib.pyplot as plt print(&quot;Initialising the simulation...&quot;) # define function that describe the Lorenz system. def Lorenz(sigma,r,b,xyz): x = xyz[0] y = xyz[1] z = xyz[2] fx = sigma*(y-x) fy = (r*x)-y-(x*z) fz = (x*y)-(b*z) return np.array([fx,fy,fz],float) # Simulation parameters start = 0 # start time end = 50 # end time num_steps = 3000 # number of time steps h = (end-start) / num_steps # time step size # intitial conditions: x=0, y=1, z=0 xyz = np.array([0,1,0],float) # constants sigma = 10 r = 28 b = 8/3 # generate times at which to evaluate xyz time_list = np.arange(start,end,h) # create empty arrays to hold the calculated values x_points = [] y_points = [] z_points = [] print(&quot;Applying Euler&#39;s method...&quot;) # Apply Euler&#39;s method for time in time_list: x_points.append(xyz[0]) y_points.append(xyz[1]) z_points.append(xyz[2]) xyz += h*Lorenz(sigma,r,b,xyz) print(&quot;Plotting the results...&quot;) # Plot the strange attractor plt.plot(x_points,z_points) plt.savefig(&quot;Strange_attractor.png&quot;) . Terminals are a way to interact with a computer without using a Graphical User Interface (GUI) . To run a Python script we can use a terminal programme, A.K.A the command line shell. | Terminals are a way to interact with a computer without using a Graphical User Interface (GUI). | The Windows terminal uses the shell language Powershell, whilst Mac and Linux both use Unix-based shells. | The Unix-based shells are most popular for programming, and so that is what we will use here. | If you are on Windows open up Git Bash (which contains the Unix shell). If you are on Mac open up Terminal. | . You can navigate around your computer using the Unix shell . ls short for list displays the contents of a folder | pwd short for print working directory displays your current position in the system | cd is used to change directory | cd .. means change to the parent directory | cd ~ means change to the home directory | cd ./data means change to the data directory. ./data provides a path relative to our current position in the system. | cd /Users/lucy means change to the lucy directory. /Users/lucy without a . is an absolute path. | . There is much, much more you can do with the Unix shell! We won’t discuss them here but for more details see this workshop from Software Carpentry. . To run your python code type the filepath into the terminal . For example, if I have a Python file at /Users/lucy/Code/Lorenz.py then I could run it using the command /Users/lucy/Code/Lorenz.py. | Alternatively I could navigate to the folder and then type the filename: | . cd /Users/lucy/Code/ Lorenz.py . After your code has ran you should see a new file (Strange_attractor.png) appear. You should also see some messages printed to the terminal screen. | . Use sys.argv to read in command line arguments . We have seen the script print messages to the terminal but what about the other way around - how can users at the terminal pass values into the script? | For example, we may want a user to specify the end_time variable used by the simulation as an argument. | For this we can use sys.argv which is a list of arguments passed to the programme | The first item in the list, sys.argv[0], contains the name of the programme: in this case, Lorenz.py. The second item in the list, sys.argv[1], contains the first argument from the command line, the third item, sys.argv[2], contains the second argument from the command line and so on. | First, we need to edit the script To access the sys.argv list we import the sys library at the top of our script: import sys | We set the end_time equal to the first command line argument: end_time = float(sys.argv[1]) | Note that the argument is automatically read in as a string so we convert it to a float. | . | Now, if the user runs Lorenz.py 30 then end_time will equal 30. | . #!/usr/bin/env python3 import numpy as np import matplotlib.pyplot as plt import sys print(&quot;Initialising the simulation...&quot;) # define function that describe the Lorenz system. def Lorenz(sigma,r,b,xyz): x = xyz[0] y = xyz[1] z = xyz[2] fx = sigma*(y-x) fy = (r*x)-y-(x*z) fz = (x*y)-(b*z) return np.array([fx,fy,fz],float) # Simulation parameters start = 0 # start time end_time = float(sys.argv[1]) # end time num_steps = 3000 # number of time steps h = (end-start) / num_steps # time step size # intitial conditions: x=0, y=1, z=0 xyz = np.array([0,1,0],float) # constants sigma = 10 r = 28 b = 8/3 # generate times at which to evaluate xyz time_list = np.arange(start,end,h) # create empty arrays to hold the calculated values x_points = [] y_points = [] z_points = [] print(&quot;Applying Euler&#39;s method...&quot;) # Apply Euler&#39;s method for time in time_list: x_points.append(xyz[0]) y_points.append(xyz[1]) z_points.append(xyz[2]) xyz += h*Lorenz(sigma,r,b,xyz) print(&quot;Plotting the results...&quot;) # Plot the strange attractor plt.plot(x_points,z_points) plt.savefig(&quot;Strange_attractor.png&quot;) . TASKS . Adapt the programme Lorenz.py so that it accepts 3 command line arguments: one for the start_time, one for end_time and one for num_steps. | Each time the Lorenz.py script runs the previous .png file is overwritten. Adapt the script so that the plot filename contains the values of the start_time, end_time and num_steps variables. You may need to search the internet for hints on how to do this (hint: look-up string formatting) |",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Scripting.html",
            "relUrl": "/2021/08/02/Scripting.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post12": {
            "title": "Runge-Kutta method",
            "content": ". Questions: . How do I use the Runge-Kutta method for more accurate solutions? | What do the terms first-order accurate and second-order accurate mean? | . Objectives: . Use the Runge-Kutta method, implemented in Python, to solve a first-order ODE | Compare results at different levels of approximation using the matplotlib library. | . . The Runge-Kutta method is more accurate than Euler&#39;s method and runs just as fast . So far we have used Euler&#39;s method for solving ODEs. We have learnt that, using this method, the final expression for the total error is linear in $h$. However for roughly the same compute time we can reduce the total error so it is of order $h^2$ by implementing another method - the Runge-Kutta method. . Note: It is common to use the Runge-Kutta method for solving ODEs given the improved accuracy over Euler&#8217;s method. However Euler&#8217;s method is still commonly used for PDEs (where there are other, larger, sources of error). . . Note: The Runge-Kutta method is actually a family of methods. In fact, Euler&#8217;s method is the first-order Runge-Kutta method. There is then the second-order Runge-Kutta method, third-order Runge-Kutta method, and so on.. . Euler&#39;s method does not take into account the curvature of the solution, whilst Runge-Kutta methods do, by calculating the gradient at intermediate points in the (time-)step. For example, in the image below we see two estimates to the blue line. Euler&#39;s method is equivalent to the orange line, where we have taken the slope at time $t$ and extrapolated it to $t+h$. A Runge-Kutta type method performs extrapolation using the slope (or slopes) at an intermediate time (or multiple intermediate times). In this case, the green line formed from the slope at $t+ frac{h}2$ gives a better approximation at $t+h$. This green line is a visual representation of the second-order Runge Kutta method, which is also known as the &quot;midpoint method&quot;. . . Runge-Kutta methods are derived from Taylor expansion(s) around intermediate point(s) . To derive the second-order Runge-Kutta method we: . 1) estimate $x(t+h)$ using a Taylor expansion around $t+ frac{h}{2}$: . begin{equation} x(t+h) = x(t+ frac{h}{2}) + frac{h}{2} left( frac{ mathrm{d}x}{ mathrm{d}t} right)_{t+ frac{h}{2}} + frac{h^2}{8} left( frac{ mathrm{d}^2x}{ mathrm{d}t^2} right)_{t+ frac{h}{2}}+ mathcal{O}(h^3) end{equation}2) estimate $x(t)$ using a Taylor expansion around $t- frac{h}{2}$: . begin{equation} x(t) = x(t+ frac{h}{2}) - frac{h}{2} left( frac{ mathrm{d}x}{ mathrm{d}t} right)_{t+ frac{h}{2}} + frac{h^2}{8} left( frac{ mathrm{d}^2x}{ mathrm{d}t^2} right)_{t+ frac{h}{2}}+ mathcal{O}(h^3) end{equation}3) Subtract Equation 2 from Equation 1 and re-arrange: . begin{eqnarray} x(t+h) &amp;=&amp; x(t) + h left( frac{ mathrm{d}x}{ mathrm{d}t} right)_{t+ frac{h}{2}}+ mathcal{O}(h^3) x(t+h) &amp;=&amp; x(t) + hf(x(t+ frac{h}{2}),t+ frac{h}{2})+ mathcal{O}(h^3) end{eqnarray}Note that the $h^2$ term has completely disappeared, and the error term is now order $h^3$. We can say that this approximation is now accurate to order $h^2$. . The problem is that this requires knowledge of $x(t+ frac{h}{2})$ which we don&#39;t currently have. We can however estimate this using the Euler method! . begin{equation} x(t+ frac{h}{2}) = x(t) + frac{h}{2}f(x,t). end{equation}Substituting this into Equation 3 above, we can write the method for a single step as follows: . begin{eqnarray} k_1 &amp;=&amp; hf(x,t) k_2 &amp;=&amp; hf(x+ frac{k_1}{2},t+ frac{h}{2}) x(t+h) &amp;=&amp; x(t) + k_2 end{eqnarray}See how $k_1$ is used to give an estimate for $x(t+ frac{h}{2})$ in $k_2$, which is then substituted into the third equation to give an estimate for $x(t+h)$. . Note: Higher orde Runge-Kutta methods can be derived in a similar way - by calculating the Taylor series around various points and then taking a linear combination of the resulting expansions. As we increase the number of intermediate points, we increase the accuracy of the method. The downside is that the equations get increasingly complicated. . Runge-Kutta methods can be applied using the Python skills we have developed . To demonstrate the Runge-Kutta method with a simple example, we will re-visit the differential equation for nuclear decay. We will model the decay process over a period of 10 seconds, with the decay constant $ lambda=0.1$ and the initial condition $N_0 = 1000$: . begin{equation} frac{ mathrm{d}N}{ mathrm{d} t} = -0.1 N end{equation} First, let&#39;s import the standard scientific libraries we will be using - Numpy and Matplotlib: . import numpy as np import matplotlib.pyplot as plt . Let&#39;s definte the function $f(N,t)$ which describes the rate of decay. In this case, the function depends only on the number of atoms present. . def f(Num_atoms): return -0.1*Num_atoms . Next we&#39;ll list the simulation parameters: start time, end time, number of time steps and step size (which is calculated using the number of time steps). For comparison, these will be the same as we used for Euler&#39;s method. . a = 0 # start time b = 10 # end time num_steps = 5 # number of time steps h = (b-a) / num_steps # time step size . We then specify the initial conditions - which in this case is the number of atoms to begin with: . Num_atoms = 1000 # initial condition . We use the Numpy arange function to generate a list of evenly spaced times at which to evaluate the number of atoms. We also create an empty list to hold the values for $N$ over time. . time_list = np.arange(a,b,h) # create an empty list to hold the calculated N values Num_atoms_list = [] . Finally, we apply second-order Runge-Kutta method using a For loop. . for time in time_list: Num_atoms_list.append(Num_atoms) k1 = h*f(Num_atoms) k2 = h*f(Num_atoms+0.5*k1) Num_atoms += k2 . We can easily compare our various models using the matplotlib plotting library . Using the analytic solution from a previous lesson, we can define a function for calculating the number of atoms $N$ as a function of time (this is the exact solution). . def analytic_solution(time): return 1000*np.exp(-0.1*time) . We can use this to calculate the exact value for $N$ over the full time range. We use a large number of points in time (in this case 1000) to give a nice smooth curve - note that we have renamed the variables for the analytic case so we do not override the original calculation parameters. . num_steps_analytic = 1000 h_analytic = (b-a) / num_steps_analytic time_analytic_list = np.arange(a,b,h_analytic) Num_atoms_analytic_list = [] for time in time_analytic_list: Num_atoms_analytic_list.append(analytic_solution(time)) . We can also re-calculate the atom population using Euler&#39;s method for comparison to the Runge-Kutta method: . Num_atoms = 1000 Num_atoms_euler_list = [] for time in time_list: Num_atoms_euler_list.append(Num_atoms) Num_atoms += h*f(Num_atoms) . Finally we plot all three models side-by-side: . plt.plot(time_analytic_list,Num_atoms_analytic_list,label=&quot;analytic&quot;) plt.scatter(time_list, Num_atoms_list,label=&quot;Runge-Kutta (second-order)&quot;) plt.scatter(time_list, Num_atoms_euler_list,label=&quot;Euler&#39;s method&quot;) plt.xlabel(&quot;time&quot;) plt.ylabel(&quot;Number of atoms&quot;) plt.legend() . &lt;matplotlib.legend.Legend at 0x12a014e20&gt; . The second-order Runge-Kutta method is accurate to order $h^2$ . We have seen earlier in the course that Euler&#39;s method is a first-order method accurate to order $h$. | The error term for one step of the Runge-Kutta method is ${O}(h^3)$ - this makes the Runge-Kutta method accurate to order $h^2$ which is why this is called the second-order Runge Kutta method (RK2). | With the RK2 can use a fewer number of steps whilst getting the same accuracy as Euler&#39;s method. | There are higher order Runge-Kutta methods which increase the accuracy further. | . . Keypoints: . The Runge-Kutta method is more accurate than Euler&#39;s method and runs just as fast | Runge-Kutta methods are derived from Taylor expansion(s) around intermediate point(s) | Runge-Kutta methods can be applied using the Python skills we have developed | We can easily compare our various models using the matplotlib plotting library | The second-order Runge-Kutta method is accurate to order $h^2$ | . . Do the quick-test. . Back to Modelling with Ordinary Differential Equations. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Runge-Kutta.html",
            "relUrl": "/2021/08/02/Runge-Kutta.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post13": {
            "title": "Runge-Kutta method - quick test",
            "content": "There are no quick test questions - can you think of a good one? Then suggest it here. . You can practice the Runge Kutta method in the exercises and extension exercises. .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Runge-Kutta-Qs.html",
            "relUrl": "/2021/08/02/Runge-Kutta-Qs.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post14": {
            "title": "Recap questions",
            "content": "Altitude of a satellite . A satellite is launched into a circular orbit around the earth so that it orbits the planet once every $T$ seconds. The altitude $h$ above the Earth’s surface that the satellite must have is: . $h = left( frac{GMT^2}{4 pi^2} right)^{ frac{1}{3}} - R$ . where $G$ is Newton’s gravitational constant, $M$ is the mass of the Earth, and $R$ is the radius. . a) Write a piece of code which calculates the altitude $h$ (in metres) for a given value of $T$ (in seconds). . b) Use this code to calculate the altitude of satellites that orbit the Earth once a day (a “geosynchronous” orbit) and once every 45 minutes. What can you conclude from this final calculation? . The emission lines of hydrogen . . There is a simple and famous formula for calculating the wavelengths $ lambda$ of the emission lines of the hydrogen atom. . $ frac{1}{ lambda} = R left( frac{1}{m^2} - frac{1}{n^2} right)$ . where R is the Rydberg constant $R = 1.097 times 10^{-2} mathrm{nm}^{-1}$ and $m$ and $n$ are positive integers and $n&gt;m$. . a) Write a piece of code to calculate the first five transitions in the Lyman series ($m=1$, transitions to the ground state, emission in the UV-range), Balmer series ($m=2$, transitions to the first excited state, emissions in the visible region) and Paschen series ($m=3$, emissions in the infra-red). . Calculating Planck’s constant . When light is shone on the surface of a metal, the photons in the light can excite (transfer energy to) electrons in the metal and, sometimes, eject them from the surface into the free space above. The energy of the ejected electron can be calculated by measuring the minimum voltage $V$ that stops the electron moving. . We know that the energy of an ejected electron is equal to the energy of the photon that excited it minus the workfunction $ phi$ (which is the energy needed to remove it from the surface) and that the energy of a single photon is $hf$ where $h$ is Planck’s constant and $f$ is the frequency of light. Mathematically this can be expressed as: . $eV = hf - phi$, . where $e$ is the charge of the electron. . a) Read in the photoelectric measurement data from the file Planck.txt. The first column contains frequencies $f$ is hertz and the second column contains voltages $V$. Use this data to plot $V$ vs $f$. Think about the plot type - does a scatter plot of line plot make most sense? . The least-squares method is very commonly used for fitting a polynomial to a set of data. As it is so prevalent in physics and engineering, you are encouraged to watch this video which give an intuitive and mathematical description of the method. . b) Fit a straight line (polynomial of degree one) to the data using the least-squares method implemented in numpy.polyfit. Overlay this line on your data points. . c) Using the gradient of the fitted line calculate a value for Planck’s constant. Compare this to values you can find online. . The Madelung constant . The Madelung constant gives the total electric potential felt by an atom in a solid. It depends on the charge and position of other nearby atoms. . Consider the compound sodium chloride. These are arranged on a cubic lattice, with sodium having a positive charge ($+e$) and chlorine having a negative charge ($-e$). If each atom position is given by integers $(i,j,k)$ then the sodium atoms are at positions where $i+j+k$ is even and the chlorine atoms are at positions where $i+j+k$ is odd. . . For an atom at $i=j=k=0$, the Madelung constant $M$ can be approximated by using the following formulae: . $V_ mathrm{total} = sum_{i,j,k} V(i,j,k) = frac{e}{4 pi epsilon_0a}M$ . $V(i,j,k) = pm frac{e}{4 pi epsilon_0r}$ . where $r$ is the distance from the origin to the atom at position $(i,j,k)$ and $a$ is the atom spacing. The summation runs from $i,j,k=-L$ to $i,j,k=L$ but not including $i,j,k=0$ (otherwise the expression would “blow up”). . a) Write an expression (in Markdown/LaTeX) for the distance $r$ in terms of $i$, $j$, $k$ and $a$. . b) Calculate the Madelung constant for sodium chloride using a large a value as L as you can (so the code runs in about a minute or less). How does it compare with published values? .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Recap_questions.html",
            "relUrl": "/2021/08/02/Recap_questions.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post15": {
            "title": "Numerical integration - extension",
            "content": "Coming soon…. .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Random_extension.html",
            "relUrl": "/2021/08/02/Random_extension.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post16": {
            "title": "Numerical integration - exercises",
            "content": "Coming soon…. .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Random_exercises.html",
            "relUrl": "/2021/08/02/Random_exercises.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post17": {
            "title": "Calculating integrals",
            "content": "If one looks at the different problems of the integral calculus which arise naturally when one wishes to go deep into the different parts of physics, it is impossible not to be struck by the analogies existing. - Henri Poincaré . One of the most basic but also most important applications of computers in physics is the evaluation of integrals. Integrals occur widely in physics and, while some integrals can be done analytically, many cannot. In this lesson we will learn several methods for numerical integration and, as part of this, we will learn how to generate random numbers. . Before you begin . Check that Python and Jupyter Notebook are installed | Launch a Jupyter notebook | . Please see the Setup page for more details. . Lesson outline . Topic Objective Quick test . Basic numerical integration | How can I do basic numerical integration? | :mag: | . Calculating integrals using Monte Carlo methods | How do I generate random numbers? How do I integrate using Monte Carlo methods? | :flashlight: | . Resources . Lesson exercises | Extension exercise | Presentation | .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Random.html",
            "relUrl": "/2021/08/02/Random.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post18": {
            "title": "Radioactive decay",
            "content": ". Questions: . How can I describe radioactive decay using a first-order ODE? | What are initial conditions and why are they important? | . . . Objectives: . Map between physical notation for a particular problem and the more general notation for all differential equations | Solve a linear, first order, separable ODE using integration | Understand the physical importance of initial conditions | . . Radioactive decay can be modelled a linear, first-order ODE . As our first example of an ODE we will model radioactive decay using a differential equation. . We know that the decay rate is proportional to the number of atoms present. Mathematically, this relationship can be expressed as: . begin{equation} frac{d N}{d t} = - lambda N end{equation}Note that we could choose to use different variables, for example: . begin{equation} frac{d y}{d x} = cy end{equation}However we try to use variables connected to the context of the problem. For example $N$ for the Number of atoms. . For example, if we know that 10% of atoms will decay per second we could write: . begin{equation} frac{d N}{d t} = -0.1 N end{equation}where $N$ is the number of atoms and $t$ is time measured in seconds. . This equation is linear and first-order. . physical notation generic notation . number of atoms $N$ | dependent variable $y$ | . time $t$ | independent variable $x$ | . decay rate $ frac{dN}{dt}$ | differential $ frac{dy}{dx}$ | . constant of proportionality $ lambda=0.1 $ | parameter $c$ | . The equation for radioactive decay is separable and has an analytic solution . The radioactive decay equation is separable. For example, . begin{equation} frac{d N}{d t} = - lambda N end{equation}Can be seperated as . begin{equation} frac{dN}{N} = - lambda dt. end{equation}We can then integrate each side: . begin{equation} ln N = - lambda t + const. end{equation}and solve for N: . begin{equation} N = e^{- lambda t}e^{ textrm{const.}} end{equation} . Note: Remember that $ int frac{1}{x} dx = ln x + textrm{const.}$ . To model a physical system an initial value has to be provided . At the beginning (when $t=0$): . begin{equation} N = e^{- lambda t}e^{ textrm{const.}} = e^{0}e^{ textrm{const.}} = e^{ textrm{const.}} end{equation}So we can identify $e^{ textrm{const.}}$ as the amount of radioactive material that was present in the beginning. We denote this starting amount as $N_0$. . Substituting this back into Equation 4, the final solution can be more meaningfully written as: . begin{equation} N = N_0 e^{- lambda t} end{equation}We now have not just one solution, but a whole class of solutions that are dependent on the initial amount of radioactive material $N_0$. . Remember that not all mathematical solutions make physical sense. To model a physical system, this initial value (also known as initial condition) has to be provided alongside the constant of proportionality $ lambda$. . ODEs can have initial values or boundary values . ODEs have either initial values or boundary values. For example, using Newton&#39;s second laws we could calculate the distance $x$ an object travels under the influence of gravity over time $t$ . begin{equation} frac{ mathrm{d}^2x}{ mathrm{d}t^2} = -g end{equation}An initial value problem would be where we know the starting position and velocity. A boundary value problem would be where we specify the position of the ball at times $t=t_0$ and $t=t_1$. . In this course we will only study ODEs with initial values. ODEs with boundary values are more difficult to solve, but you can related materials listed under External resources. . The number of initial conditions depends on the order of the differential equation . Our radioactive decay example is a first-order ODE and so we only had to provide a single initial condition. For second-order ODEs (such as acceleration under gravity) we need to provide two initial/boundary conditions, for third-order ODEs we would need to provide three, and so on. . . Keypoints: . Radioactive decay can be modelled a linear, first-order ODE | The equation for radioactive decay is separable and has an analytic solution | To model a physical system an initial value has to be provided | The number of initial conditions depends on the order of the differential equation | . . . Do the quick-test. . Back to Modelling with Ordinary Differential Equations. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Radioactive-Decay.html",
            "relUrl": "/2021/08/02/Radioactive-Decay.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post19": {
            "title": "Radioactive decay - quick test",
            "content": "Terminology tables . In the Radioactive decay tutorial there is a table listing the dependent variable, independent variable, differential and parameter(s). Complete a similar table for the following physical systems: . physical notation generic notation .   | dependent variable(s) | .   | independent variable(s) | .   | differential(s) | .   | parameter(s)/constants(s) | . a) The amount of charge that flows every second from a capacitor, . begin{equation} frac{ mathrm{d} Q}{ mathrm{d} t} = - beta Q end{equation} . b) The motion of a non-linear pendulum driven by a force oscillating at frequency $ sigma$, . begin{equation} frac{ mathrm{d}^2 theta}{ mathrm{t}^2} = - frac{g}{l} sin( theta) + C cos( theta) sin( sigma t). end{equation} . Show answer a) . physical notation generic notation . $Q$ | dependent variable(s) | . $t$ | independent variable(s) | . $ frac{ mathrm{d}Q}{ mathrm{d}t}$ | differential(s) | . $ beta$ | parameter(s)/constant(s) | . b) . physical notation generic notation . $ theta$ | dependent variable(s) | . $t$ | independent variable(s) | . $ frac{ mathrm{d}^2 theta}{ mathrm{d} t^2}$ | differential(s) | . $l$, $C$, $ sigma$, $g$ | parameter(s)/constant(s) | .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Radioactive-Decay-Qs.html",
            "relUrl": "/2021/08/02/Radioactive-Decay-Qs.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post20": {
            "title": "Python part two - extension activity",
            "content": "The Madelung constant . Taken from Mark Newman’s book “Computational Physics, p. 74 . The Madelung constant gives the total electric potential felt by an atom in a solid. It depends on the charge and position of other nearby atoms. . Consider the compound sodium chloride. These are arranged on a cubic lattice, with sodium having a positive charge ($+e$) and chlorine having a negative charge ($-e$). If each atom position is given by integers $(i,j,k)$ then the sodium atoms are at positions where $i+j+k$ is even and the chlorine atoms are at positions where $i+j+k$ is odd. . . For an atom at $i=j=k=0$, the Madelung constant $M$ can be approximated by using the following formulae: . $V_ mathrm{total} = sum_{i,j,k} V(i,j,k) = frac{e}{4 pi epsilon_0a}M$ . $V(i,j,k) = pm frac{e}{4 pi epsilon_0r}$ . where $r$ is the distance from the origin to the atom at position $(i,j,k)$ and $a$ is the atom spacing. The summation runs from $i,j,k=-L$ to $i,j,k=L$ but not including $i,j,k=0$ (otherwise the expression would “blow up”). . a) Write an expression (in Markdown/LaTeX) for the distance $r$ in terms of $i$,$j$,$k$ and $a$. . b) Calculate the Madelung constant for sodium chloride using a large a value as L as you can (so the code runs in about a minute or less). How does it compare with published values? . . Back to Python part two. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Python_two_extension.html",
            "relUrl": "/2021/08/02/Python_two_extension.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post21": {
            "title": "Python part two - exercises",
            "content": "A function to calculate standard errors . In experimental work it is common for a quantity of interest to be calculated from a combination of direct measurements. It is important to remember that all experimentally measured quantities present an uncertainty that will affect the final result. . The uncertainty is determined by the measurement instrument and settings. For example, if we measure a triangle with a caliper (resolution 0.1mm) we will get a more accurate value than if we use a ruler (resolution 1mm). But remember that whichever instrument we use we will introduce some amount of uncertainty. . The table below outlines how the standard error can be obtained from the uncertainty associated with individual measurements. . Calculation Standard error . Z = A+B | $( Delta Z)^2 = ( Delta A)^2 + ( Delta B)^2$ | . Z = A-B | $( Delta Z)^2 = ( Delta A)^2 + ( Delta B)^2$ | . Z = AB | $ left( frac{ Delta Z}{Z} right)^2 = left( frac{ Delta A}{A} right)^2 + left( frac{ Delta B}{B} right)^2$ | . Z = frac{A}{B} | $ left( frac{ Delta Z}{Z} right)^2 = left( frac{ Delta A}{A} right)^2 + left( frac{ Delta B}{B} right)^2$ | . a) Write a function which calculates the perimeter of a triangle and the standard error associated with this perimeter. The function argument will specify the length of each triangle side and the uncertainty associated with each measurement. . b) Using conditionals, write a function which calculates the standard error for any of the operations listed in the table. The function arguments will specify $A$, $B$, $ Delta A$, $ Delta B$ and the operation type. . The emission lines of hydrogen . Taken from Mark Newman’s book “Computational Physics, p. 73 . There is a simple and famous formula for calculating the wavelengths $ lambda$ of the emission lines of the hydrogen atom. . $ frac{1}{ lambda} = R left( frac{1}{m^2} - frac{1}{n^2} right),$ . where R is the Tydberg constant ($R = 1.097 times 10^{-2} mathrm{nm}^{-1}$) and $m$ and $n$ are positive integers and $n&gt;m$. . a) Write a piece of code to calculate the Lyman series ($m=1$), Balmer series ($m=2$) and Paschen series ($m=3$). . . Back to Python part two. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Python_two_exercises.html",
            "relUrl": "/2021/08/02/Python_two_exercises.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post22": {
            "title": "Python part one - extension activity",
            "content": "Reading code . You can learn a lot from reading other people’s code. Take a look at the code for carbon_calculator.py: https://github.com/lucydot/scripts/blob/master/bitsbobs/carbon_calculator.py. . You will recognise some of the Python syntax used, other parts you may not recognise (though we will cover this syntax by the end of the course). . a) Using the internet (Python documentation, stack overflow, tutorials) can you unpick what the function read_file does? Could explain this to a non-expert? . b) When this script is run from the command line, the function carbon_calculator is called. Using the internet can you unpick what this function does (and so what the programme does as a whole)? Could you explain this to a non-expert? . c) Can you suggest ways in which the carbon_calculator.py programme might be improved? . . Back to Python part one. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Python_one_extension.html",
            "relUrl": "/2021/08/02/Python_one_extension.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post23": {
            "title": "Python part one - exercises",
            "content": "Altitude of a satellite . Adapted from Mark Newman’s book “Computational Physics, p. 30 . A satellite is launched into a circular orbit around the earth so that it orbits the planet once every $T$ seconds. The altitude $h$ above the Earth’s surface that the satellite must have is: . $ h = left( frac{GMT^2}{4 pi^2} right)^{ frac{1}{3}} - R$ . where $G$ is Newton’s gravitational constant, $M$ is the mass of the Earth, and $R$ is the radius. . a) Write a piece of code which calculates the altitude $h$ (in metres) for a given value of $T$ (in seconds). . b) Use this code to calculate the altitude of satellites that orbit the Earth once a day (a “geosynchronous” orbit) and once every 45 minutes. What can you conclude from this final calculation? . . Back to Python part one. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Python_one_exercises.html",
            "relUrl": "/2021/08/02/Python_one_exercises.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post24": {
            "title": "Python part two",
            "content": "This lesson is part two of an introduction to programming in Python for people with little or no previous programming experience. This lesson references the Jupyter Notebook, but can be followed using a regular Python interpreter as well. Please note that this lesson, like all others in the course, uses Python 3 rather than Python 2. . Before you begin . Check that Python and Jupyter Notebook are installed | Launch a Jupyter notebook | . Please see the Setup page for more details. . Lesson outline . Topic Objective Quick test . For loops | How can I make a program do many things? | :ram: | . Conditionals | How can programs do different things for different data? | :mouse: | . Writing functions | How can I create my own functions? | :palm_tree: | . Variable scope | How do function calls actually work? How can I determine where errors occurred? | :mushroom: | . Libraries | How can I use software that other people have written? How can I find out what that software does? | :cactus: | . Resources . Lesson exercises | Extension exercise | Presentation | . External resources . There are other tutorials covering Python for scientific computing, including: https://aaltoscicomp.github.io/python-for-scicomp/ | . | .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Python_basics_two.html",
            "relUrl": "/2021/08/02/Python_basics_two.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post25": {
            "title": "Python part one",
            "content": "This lesson is part one of an introduction to programming in Python for people with little or no previous programming experience. This lesson references the Jupyter Notebook, but can be followed using a regular Python interpreter as well. Please note that this lesson, like all others in the course, uses Python 3 rather than Python 2. . Before you begin . Check that Python and Jupyter Notebook are installed | Launch a Jupyter notebook | Think about the folder (directory) structure you will use for this course. The following structure is recommended: OneDrive -&gt; KD5081_Comp -&gt; Notebooks. | . Please see the Setup page for more details. . Lesson outline . Topic Objective Quick test . Running python | How can I run Python programs? | :running: | . Variables and assignment | How can I store data in programs? | :nail_care: | . Data types and type conversion | What kinds of data do programs store? How can I convert one type to another? | :dancer: | . Built-in functions, help and errors | How can I use built-in functions? How can I find out what they do? What kind of errors can occur in programs? | :droplet: | . Lists | How can I store multiple values? | :ear: | . Course resources . Lesson exercises | Extension exercise | Presentation | . External resources . There are other tutorials covering Python for scientific computing, including: https://aaltoscicomp.github.io/python-for-scicomp/ | . | .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Python_basics_one.html",
            "relUrl": "/2021/08/02/Python_basics_one.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post26": {
            "title": "Python progress report",
            "content": "This report provides class progress statistics for the Getting Started section of the Computational Physics course KD5081 at Northumbria University. . Friendly request . If you use this notebook as a basis for your own work please let me know - hearing from people who find what I&#39;ve written about useful encourages me to spend more time in the future documenting my ideas/workflows. . Student workflow . From a student&#39;s point of view the process is: . Create a Github account (it is free). | Go to the course issues page and click on “New Issue”. | Next to “Python basics checklist” click “Get started”. | Without editing any text, click “Submit new issue”. This will generate an issue with a pre-defined checklist. | Work through the tutorials and questions for the relevant section of the course (part one - “Getting Started”) and tick off the items on the checklist accordingly. | Issue template . Steps 2 to 4 in the student workflow above enable students to generate the checklist via a Github issue template which can be found here. . Automation . This notebook is hosted on Github and automatically runs after every commit, and once an hour. Automation is via a Github action. This workflow was designed following the clear advice given by the Living with machines project. . Summary plot . The end result of this notebook is a class progress summary plot, which can also be found on this page. . Adapting this for a different course / checklist . If you want to adapt this workflow for your own Github-hosted course repository, the following should work (please let me know if it does or does not!): . 1) Adapt the issue template) with a checklist for your own curriculum: . The empty check boxes - [ ] need to be immediately followed by the checklist item e.g. &quot;Open and save a Jupyter Notebook&quot; and then a newline, or the regex below will not work. | If you change the issue label (currently &quot;python_checklist&quot;) you will need to update this notebook accordingly (see below). | . 2) Upload the issue template to your repository folder .github/ISSUE_TEMPLATE/. . 3) Copy this notebook across to your course repository. You will need to edit the values in the cell below Course specific inputs. . 4) Copy the Github action to your repository folder .github/workflows/. You will need to update two fields at a minimum: the author name and the path to this notebook. . Course specific inputs . course_repo = &quot;nu-cem/CompPhys&quot; issue_template_path = &#39;.github/ISSUE_TEMPLATE/python-basics-checklist.md&#39; issue_template_label = &quot;python_checklist&quot; output_file_path = &quot;../images/progress_report.png&quot; . Prepare system . Install libraries, get Github authentication token and create tasks list. . from github import Github import matplotlib.pyplot as plt import numpy as np from dotenv import load_dotenv import os import re . load_dotenv() GH_TOKEN = os.getenv(&quot;GH_TOKEN&quot;) # this is needed to interact with the Github API . Access course repo . g = Github(GH_TOKEN) . repo = g.get_repo(course_repo) . Get checkbox items from the issue template . issue_template_content = repo.get_contents(issue_template_path).decoded_content.decode() . tasks = re.findall(r&#39; [ ] (.*) n&#39;, issue_template_content) . Retrieve and parse raised issue information . checklist_issues = repo.get_issues(labels=[issue_template_label]) . totals = [0]*len(tasks) issue_count = 0 for issue in checklist_issues: issue_count += 1 body = issue.body for i,task in enumerate(tasks): if task in body: splits = body.split(task,maxsplit=2) if splits[0][-4:-1] == &#39;[x]&#39;: totals[i] += 1 else: print(&quot;problem: &#39;{}&#39; not in string in issue # {}&quot;.format(task, issue.number)) . Plot results . fig, ax = plt.subplots(1,1,figsize=(20,len(tasks))) ax.barh(np.arange(len(tasks)),totals, align=&#39;center&#39;) ax.set_yticks(np.arange(len(tasks))) ax.set_xticks(np.arange(issue_count+0.1)) ax.set_yticklabels(tasks) ax.invert_yaxis() ax.set_xlabel(&#39;# of checked boxes&#39;) for item in ([ax.title, ax.xaxis.label, ax.yaxis.label] + ax.get_xticklabels() + ax.get_yticklabels()): item.set_fontsize(20) plt.tight_layout() plt.savefig(output_file_path,dpi=250) plt.show() .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Python-progress.html",
            "relUrl": "/2021/08/02/Python-progress.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post27": {
            "title": "Modelling Partial Differential Equations",
            "content": "It is a curious historical fact that modern quantum mechanics began with two quite different mathematical formulations: the differential equation of Schroedinger and the matrix algebra of Heisenberg. - Richard Feynman . In this section of the course we will learn how to solve another type of differential equation - the partial differential equation. These are also of vital importance to a physicist as they underly quantum mechanics (via the Schroedinger equation) and electromagnetism (via Maxwell’s equations). They are also used to model heat diffusion and wave propagation, amongst other processes. . It is usually impossible to write down explicit formulas for solutions of partial differential equations, and so there is a vast amount of research dedicated to solving these equations using computers. In this lesson we will start to explore some of these numerical approaches, with a focus on understanding the underlying mathematical methods used rather than importing pre-made functions. . Before you begin . Check that Python and Jupyter Notebook are installed | Launch a Jupyter notebook | . Please see the Setup page for more details. . Lesson outline . Topic Objective Quick test . Introduction to PDEs | Which physical systems can be described using a PDE? What are the del and Laplacian operators? When to I need boundary conditions and initial conditions? | 🍫 | . Laplace’s equation for electrostatics | How do I use the relaxation method to solve Laplace’s equation? | :evergreen_tree: | . Heat diffusion | How do I combine the relaxation and Euler methods to solve the heat diffusion equation? | :chestnut: | . Course resources . Lesson exercises | Extension exercise | Presentation | . External resources . youtube: https://youtu.be/ly4S0oi3Yz8 . youtube: https://youtu.be/ToIXSwZ1pJU .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/PDEs.html",
            "relUrl": "/2021/08/02/PDEs.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post28": {
            "title": "Modelling PDEs - extension",
            "content": "The method of finite differences for second order derivatives . In one of the tutorials we give an expression for calculating second order derivatives using the finite difference method: . begin{equation} frac{ mathrm{d} ^2f}{ mathrm{d} x^2} simeq frac{f(x+h)-2f(x)+f(x-h)}{h^2}. end{equation} . Using the fact that a second derivative is, by definition, a derivative of a derivative, and by applying the central difference method three times, derive this expression. . . Back to Modelling with Partial Differential Equations. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/PDE_extension.html",
            "relUrl": "/2021/08/02/PDE_extension.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post29": {
            "title": "Modelling PDEs - exercises",
            "content": "Modelling the Poisson equation . Adapted from Mark Newman’s book “Computational Physics, p. 412 . In one of the tutorials we have used the relaxation method to solve Laplace’s equation for electrostatics: . begin{equation} nabla^2 phi = 0 end{equation} . A more general form of this equation is Poisson’s equation: . begin{equation} nabla^2 phi = - frac{ rho}{ epsilon_0}, end{equation} . which governs the electric potential in the presence of charge density $ rho$. . Assume, as in the tutorial example for Laplace’s equation, that there is a 1 meter square. However this time all four walls of the square at fixed at zero volts and that there are two 20cm x 20cm charged areas in the box. One charge has a density +1Cm$^{-2}$, the other has a density -1Cm$^{-2}$. . Modify the code for the Laplace’s equation example to solve this problem using the relaxation method. . . Back to Modelling with Partial Differential Equations. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/PDE_exercises.html",
            "relUrl": "/2021/08/02/PDE_exercises.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post30": {
            "title": "Introduction to PDEs",
            "content": ". Questions: . Which physical systems can be described using a PDE? | What is the Laplacian operator? | When to I need boundary conditions and initial conditions? | . Objectives: . Recognise common classes of PDE: the diffusion equation, Poisson&#39;s equation and the wave equation | Express the Laplacian as a differential operator | Identify boundary value problems and initial value problems | . . Partial differential equations have multiple inputs . In the previous section of the course we studied ordinary differential equations. ODEs have a single input (also known as independent variable) - for example, time. . Partial differential equations (PDEs) have multiple inputs (independent variables). For example, think about a sheet of metal that has been heated unevenly across the surface. Over time, heat will diffuse through the 2-dimensional sheet. The temperature depends on both time and position - there are two inputs. Because PDEs have multiple inputs they are generally much more difficult to solve analytically than ODEs. However, there are a range of numerical methods that can be used to find approximate solutions. . PDEs have application across a wide variety of topics . The same type of PDE often appears in different contexts. For example, the diffusion equation takes the form: . begin{equation} nabla^2T = alpha frac{ partial T}{ partial t} end{equation}When used to describe heat diffusion, this PDE is known as the heat equation. This same PDE however can be used to model other seemingly unrelated processes such as brownian motion, or used in financial modelling via the Black-Sholes equation. . Another type of PDE is known as Poisson&#39;s equation: . begin{equation} nabla^2 phi = f(x,y,z) end{equation}Poisson&#39;s equation can be used to describe electrostatic forces, where $ phi$ is the electric potential. It can also be applied to mechanics (where $ phi$ is the gravitational potential) or thermodynamics (where $ phi$ is the temperature). When $f(x,y,z)=0$ this equation is known as Laplace&#39;s equation. . The third common type of PDE is the wave equation: . begin{equation} nabla^2r = alpha frac{ partial^2 r}{ partial t^2} end{equation}This describes mechanical processes such as the vibration of a string or the motion of a pendulum. It can also be used in electrodynamics to describe the exchange of energy between the electric and magnetic fields. . In this course we will look at techniques for solving the diffusion equation and Poisson&#39;s equation, but many of the topics we will discuss - such as boundary conditions, and finite difference methods - can be transferred to PDEs more generally. . The Laplacian operator corresponds to an average rate of change . But what is the operator $ nabla^2$?. This is the Laplacian operator. When applied to $ phi$ and written in full for a three dimensional cartesian coordinate system with dependent variables $x$, $y$ and $z$ it takes the following form: . begin{equation} nabla^2 phi = frac{ partial^2 phi}{ partial x^2} + frac{ partial^2 phi}{ partial y^2} + frac{ partial^2 phi}{ partial z^2}. end{equation}We can think of the laplacian as encoding an average rate of change. To develop an intuition for how the laplacian can be interpreted physically, we need to understand two related operators - div and curl. We will not explore these operators further in this lesson, but a related video is below: . PDEs can have boundary conditions and initial conditions . In the previous section of the course we learnt that ODEs have either initial values or boundary values. . Boundary value problems . PDEs can also be separated in a similar manner. Boundary value problems describe the behaviour of a variable in a space and we are given some constraints on the variable around the boundary of that space. For example, consider the 2-dimensional problem of a thin rectangular sheet with one side at voltage $V$ and all others at voltage zero. . . The specification that one side is at voltage $V$ and all others are at voltage zero are the boundary conditions. We could then calculate the electrostatic potential $ phi$ at all points within the sheet using the two-dimensional Laplace&#39;s equation: . begin{equation} nabla^2 phi = frac{ partial^2 phi}{ partial x^2} + frac{ partial^2 phi}{ partial y^2} = 0 end{equation}Initial value problems . Initial value problems are where the field - or other variable of interest - is varying in both space and time. We now require boundary conditions and initial values. This is a more difficult type of PDE to solve. . For example, consider heat diffusion in a two-dimensional sheet. Here we could specify that there is no heat flow in or out of the sheet - this is the boundary condition. . . We could also specify that at time $t=0$ the centre of the sheet is at temperature $T_1$, whilst surrounding areas are at temperature $T_0$. This is the initial condition. It differs from a boundary condition in that we are told what the temperature is at the start of our time grid (at $t=0$) but not at the end of our time grid (when the simulation finishes). . . We could then calculate the temperature at time $t$ at all points $[x,y]$ within the sheet using the two-dimensional Diffusion equation: . begin{equation} nabla^2T = frac{ partial^2 T}{ partial x^2} + frac{ partial^2 T}{ partial y^2}= alpha frac{ partial T}{ partial t} end{equation} . Keypoints: . PDEs have multiple inputs (independent variables) | PDEs have application across a wide variety of topics | The Laplacian operator corresponds to an average rate of change | PDEs can have boundary values and initial values | . . Do the quick-test. . Back to Modelling with Partial Differential Equations. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/PDE-Intro.html",
            "relUrl": "/2021/08/02/PDE-Intro.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post31": {
            "title": "Introduction to PDEs - quick test",
            "content": "Classifying PDEs . Decide whether the following systems are a boundary value problem or initial value problem, and whether they are diffusion-like, wave-like or poisson-like: . a) Brownian motion of small particles in a liquid (the random-walk) . begin{equation} frac{dP}{dt} = frac{l^2}{2Np^2} nabla^2P end{equation} . b) the Klein-Gordon equation for describing the energy-momentum relation of relativistic particles: . begin{equation} left( frac{1}{c^2} frac{ partial^2}{ partial t^2} - nabla^2 + frac{m^2c^2}{ hbar^2} right) phi(t,x)=0 end{equation} . Show answer a) this is an initial value problem described by the diffusion equation b) this is an initial value problem described by the wave equation . . See the notebook. . Back to Modelling with Partial Differential Equations. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/PDE-Intro-Qs.html",
            "relUrl": "/2021/08/02/PDE-Intro-Qs.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post32": {
            "title": "Build-your-own website",
            "content": "Questions: . How can I create a project website? | . Objectives: . Differentiate between git, Github and Github pages | Use Github pages and html to create a very simple website | Use Github pages and markdown to create a very simple website | Customise the website using the _config.yml file | Use Github pages, markdown and Jekyll to create a multipage website | . Keypoints: . Github pages is a static site hosting service that takes HTML files from a Github repository and publishes a website. | We can create a simple website in three short steps. | Github pages can be combined with a variety of static site generators to create a customised website. | A single page project site can be created using an README.md file on the gh-pages branch. | Github pages combined with Jekyll front matter can be used to create quick multipage sites. | Github has a range of Jekyll themes to choose from. | To access a wider range of themes and customisation options you can add a _config.yml file. | Other static site generators can be combined with Github actions for more flexibility. | . Github pages takes HTML files from a Github repository and publishes a website. . First we should differentiate between three similar sounding tools: Git is an open-source version control system that can be used online or locally. | Github is a website (owned by Microsoft) that is built on top of git. It can be used to store and share files in project repositories. | Github pages is a service provided by Github. Github pages takes HTML from a repository and publishes it as a website. | . | . Note: Github is not the only option for hosting your code. Other services include Gitlab (which is an open source project) and Bitbucket. . We can create a simple website in three short steps . To see the most simple example of how Github pages works we can create 1) create a repository 2) create a gh-pages branch and 3) add a html file. . | Step 1: Create a repository . Register for a Github account (if you do not already have one) and login | Create a new repository by clicking the plus sign at the top-right hand corner | Give your repository a name e.g. website-example | Give your repository a description e.g. A simple example of a website generated using gh-pages | Select Add a README file | Select Choose a license and select a license | Click Create repository | . | . Important: You don’t need to select a license at this stage but it’s recommended that you do. The MIT License is a popular choice as it is simple and permissive (people do almost anything they want with your project). If you are not clear which license to use you can visit https://choosealicense.com/. . Step 2: Create a gh-pages branch Click main towards the top-left hand corner | Type gh-pages into the text box (Find or create a branch) | Select `Create branch: gh-pages from ‘main’ | . | . A branch in Git is similar to the branch of a tree. A tree branch is attached to the main part of the tree. While branches can generate and fall off, the main central part of the tree continues. Similarly, a branch in Git is a way of developing new features or fixing bugs without affecting the main part of the project (the main branch). The main branch is created when we create the git repository. . Important: Github pages will automatically publish any html on the gh-pages branch only. . Step 3: Click Add file (make sure you are on the gh-pages branch) | Click Create new file | Name the file Hello-world.html | Paste the following code | . | . &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Hello World!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Soooo nice to meet you.&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; . Click Commit new file | . You can access your project webpages using the address format username.github.io/repository-name/filename.html. If you have followed the suggested naming in this example you can access your Hello-world webpage at https://username.github.io/website-example/Hello-world.html . Github pages can be combined with a variety of static site generators to create a customised website. . It would take a lot of time to write our website using html (unless we want a really, really simple website) | Instead there are several static site generators which will take plain text files (formatted using a markup language such as markdown or reStructuredText) and convert these into html. | Examples of static site generators include: Jekyll, which is used by the Software Carpentry organisation: https://swcarpentry.github.io/python-novice-inflammation/ | Mkdocs, which is used to create documentation sites, for example this one for the University of Northumbria research computing community (developed by an undergraduate student in the CIS department): https://rsc-northumbria.github.io/oswald-docs/ | hugo which can be used for developing personal or professional webpages: https://lucydot.github.io | . | Each type of static site generator comes with a range of templates to use for customising your website. | Any static site generator can be combined with Github pages to create a website. We will use Jekyll as this has extra integration support from Github pages. | . A single page project site is created using the README.md file on the gh-pages branch. . In fact, Github has already used the Jekyll static site generator behind the scenes to convert your repository README.md file to html. You can access this at https://username.github.io/website-example/. | . Note: Github will automatically convert a file named README.md on the gh-pages branch only if an index.html does not exist. . We can edit and commit changes to the README.md and our webpage will be updated. Click on the pencil icon on your repository landing page | Edit the file using markdown, e.g. The website can be accessed [here](https://lucydot.github.io/website-example/Hello-world.html). | Under Commit changes write a commit message title e.g. Include a link the website. | Click on Commit changes to save (version control) the changes made. | The changes should be reflected on the webpage: https://username.github.io/website-example/ | . | . Github pages combined with Jekyll front matter can be used to create a multipage sites. . Github will not convert any other files on the gh-pages branch to html unless the file containts top-matter in a particular format. The top-matter consists of two sets of three dashes, with variable(s) defined between, as given in the code block below. In your repository click on Add file and Create new file | Name the file Code-of-Conduct.md | Paste the following front matter and content into the file | . | . title: Code of Conduct Welcome to the Build-your-own website page. The first rule is: Be Nice! . Click Commit new file | You can see your new webpage at https://username.github.io/website-example/Code-of-Conduct. | . Important: The three dashes at the top and bottom of your front matter are very important. If your file does not start with front matter in this format Jekyll will not convert the file to html. . The front matter contains predefined global variables or custom variables. In this example, we have specified what the value of the title variable is. We can then access this variable in the main body of the page. | If you don’t want to define any variables you can always leave it empty - but you must include the two sets of triple dashed lines. | At this stage you may also want to update your README.md with links to the Hello-world webpage and the Code of Conduct. | . Info: The Code of Conduct we use here is a silly example. However for many projects and initiatives having a Code of Conduct is important. There is more information on this page. . Github has a range of Jekyll themes to choose from. . You can add a theme to your GitHub Pages site to customize your site’s look and feel. | There are a range of Jekyll themes that Github pages has built-in support for. To change the theme you can use the following steps: In your repository click on Settings | Click on Pages in the left navigation bar | Click on Choose a theme | Choose a theme to preview | Click Select theme | . | . Note: The theme will only be applied to the README.md or webpages with the Jekyll front matter. . Note: When you select a new theme the _config.yml file in your repository is automatically updated. . To access a wider range of customisation options you can fork a Jekyll template and edit the _config.yml file. . For example, you can follow the steps outlined for the beautiful-jekyll blog template: Fork (copy) the beautiful-jekyll template by clicking on the Fork button at the top right corner of the page | Under the repository Settings rename the project repository e.g. improved-website | Under the repository Settings-&gt;Github Pages choose the main (or master) branch as the source | . | This will create a website at https://username.github.io/improved-website. | To customise edit the _config.yml file | To add content edit the markdown files (see the beautiful-jekyll docs for more information). | . For more flexibility you can combine other static site generators can be combined with Github actions . . Any static site generator can be combined with Github pages to create a website. | For example, the Northumbria Research Computing Community website was built using MkDocs framework, Github Pages and Github Actions to build the webpages. The main branch of the corresponding Github repo has a mkdocs.yml file that specifies the theme, plugins used and website navigation | The main branch has a docs folder containing the website content as markdown files. In the root of the docs folder is the homepage index.md. | The main branch contains a file .github/workflows/build-docs.yml which specifies how to build and deploy the html using the markdown files | After commiting a change on the main branch, Github Actions will build the website and copy the html files to the gh-pages branch for publishing. | . | . Note: the gh-pages branch in this example includes a .nojekyll file to tell Github pages not to automatically build it using Jekyll . TASK . Use Github pages and Jekyll to create an academic website. This could include: . A landing page with a short description of your background and interests | Links to code that you have written (during this course or elsewhere) | A picture of yourself or your experimental work | . Think of it as an online CV. It is a great way to promote your work to potential employers or supervisors. .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Open_science.html",
            "relUrl": "/2021/08/02/Open_science.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post33": {
            "title": "Modelling Ordinary Differential Equations",
            "content": "“Since Newton, mankind has come to realise that the laws of physics are always expressed in the language of differential equations” – Steven Strogatz . In this section of the course we will learn how to solve ordinary differential equations. These are of vital importance to a physicist as they are at the base of classical and celestial mechanics via Newton’s equations. They are also used to model electrical circuits and radioactive decay, amongst other systems. . Broadly speaking, there are three ways to solve a differential equation: analytically, numerically (with a pre-existing function) or numerically (with a home-made function). Numerical approaches offer more flexibility but with the caveat that they are approximate and must be converged. . In this lesson we will use numerical approaches to solve ODE’s, with a strong focus on home-made numerical functions (rather than pre-made functions imported from a library). As such we will achieve a greater understanding of the underlying mathematics and approximations used - and it’s a great chance to practice our Python skills. . Before you begin . Check that Python and Jupyter Notebook are installed | Launch a Jupyter notebook | . Please see the Setup page for more details. . Lesson outline . Topic Objective Quick test . Classifying differential equations | What is the difference between an ODE and PDE? How do I classify the different types of differential equations? | :ticket: | . Radioactive decay | How can I describe radioactive decay using a first-order ODE? What are initial conditions and why are they important? | :trolleybus: | . Euler’s method | How do I use Euler’s method to solve a first-order ODE? What does the term first-order accurate mean? | :blue_car: | . The strange attractor | How do I solve differential equations with more than one variable? | :truck: | . Runge-Kutta method | How do I use the Runge-Kutta method for more accurate solutions? What do the terms first-order accurate and second-order accurate mean? | :red_car: | . Course resources . Lesson exercises | Extension exercise | Presentation | . External resources . youtube: https://youtu.be/p_di4Zn4wz4 . youtube: https://youtu.be/3d6DsjIBzJ4 .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/ODEs.html",
            "relUrl": "/2021/08/02/ODEs.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post34": {
            "title": "Modelling ODEs - extension",
            "content": "The fourth order Runge-Kutta method . We can extend the approach outlined in [the Runge-Kutta tutorial] to higher orders. The most common method for the numerical solution of ODEs is the fourth-order Runge-Kutta method (RK4). This is accurate to terms of order $h^4$ (equivalently, it carries an error or order $h^5$). It’s derivation is quite tedious, but the approach is the same as that for the second-order method: we Taylor expand around various points and take linear combinations that lead to the cancellation of terms in $h^3$, $h^4$ and so on. . The five resulting equations are: . begin{equation} k_1 = hf(x,t) end{equation} . begin{equation} k_2 = hf(x+ frac{1}{2}k_1,t+ frac{1}{2}h) end{equation} . begin{equation} k_3 = hf(x+ frac{1}{2}k_2,t+ frac{1}{2}h) end{equation} . begin{equation} k_4 = hf(x+k_3,t+h) end{equation} . begin{equation} x(t+h) = x(t) + frac{1}{6}(k_1+2k_2+2k_3+k_4) end{equation} . Use RK4 to solve the differential equation . begin{equation} frac{ mathrm{d}x}{ mathrm{d}t} = -x^3 + mathrm{sin} t end{equation} . with the initial condition $x=0$ at $t=0$. . Plot $x(t)$ for a number of steps $N$ equal to 10, 20, 50 and 1000. How does convergence compare to that when using RK2 (which was a question in the exercises)? . Dynamical systems . The motion of two bodies of mass $m_1$ and $m_2$ attracted by gravity is the Kepler problem. In this case the moving bodies experience a force varying as the inverse square of the distance between them; for body one the distance to body two is . begin{equation} mathbf{r}_{12} = mathbf{r}_1- mathbf{r}_2, end{equation} . whilst for body two the distance to body one is . begin{equation} mathbf{r}_{21} = mathbf{r}_2- mathbf{r}_1. end{equation} . So that the corresponding forces are: . begin{equation} mathbf{F}1 = - frac{Gm_1m_2}{r{12}} hat{ mathbf{r_{12}}} end{equation} . begin{equation} mathbf{F}2 = - frac{Gm_1m_2}{r{21}} hat{ mathbf{r_{21}}} end{equation} . Numerically compute and plot the orbits by integrating the equations of motion: . begin{equation} m_1 mathbf{a}_1 = mathbf{F}_1, end{equation} . begin{equation} m_2 mathbf{a}_2 = mathbf{F}_2. end{equation} . Use the Euler method for the integration: . begin{equation} mathrm{v}_1(t+ Delta t)= mathrm{v}_1(t)+ Delta t frac{ mathrm{F_1}}{m_1} end{equation} . begin{equation} mathrm{v}_2(t+ Delta t)= mathrm{v}_2(t)+ Delta t frac{ mathrm{F_2}}{m_2} end{equation} . begin{equation} mathrm{r}_1(t+ Delta t)= mathrm{r}_1(t)+ Delta t mathrm{v}_1(t) end{equation} . begin{equation} mathrm{r}_2(t+ Delta t)= mathrm{r}_2(t)+ Delta t mathrm{v}_2(t) end{equation} . Assume that the $z$ axis is perpendicular to the plane of motion so that the motion is in two dimensions. Note that the force is not constant - it depends on $r$, which couples together the equations for $ mathbf{v}$ and $ mathbf{r}$ . For the parameters assume $G=1$, $m_1=1$ and $m_2=1$. For the initial conditions, assume that $r_1 = [1,0]$, $r_2 = [-1,0]$, $v_1 = [0,0.5]$ and $v_2 = [0,-0.5]$. Integrate up to the time $t_ mathrm{max} = 20$ with a time step size of $ delta t = 0.05$. . Once you have working code, change the initial velocities and comment on what you observe. . . Back to Modelling with Ordinary Differential Equations. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/ODE_extension.html",
            "relUrl": "/2021/08/02/ODE_extension.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post35": {
            "title": "Modelling ODEs - exercises",
            "content": "Euler’s method . Use Euler’s method to solve the differential equation . begin{equation} frac{ mathrm{d}x}{ mathrm{d}t} = -x^3 + mathrm{sin} t end{equation} . with the initial condition $x=0$ at $t=0$. . Plot $x(t)$ for a number of steps $N$ equal to 10, 20, 50 and 1000. . Second order Runge-Kutta method . Use a second order Runge-Kutta method to solve the differential equation . begin{equation} frac{ mathrm{d}x}{ mathrm{d}t} = -x^3 + mathrm{sin} t end{equation} . with the initial condition $x=0$ at $t=0$. . Plot $x(t)$ for a number of steps $N$ equal to 10, 20, 50 and 1000. How does convergence compare to that when using Euler’s method? . Modelling a non-linear pendulum . In The strange attractor tutorial we use Euler’s method to solve simultaneous first order ODEs. At the end of the tutorial you are also shown how to re-cast the second order ODE for a non-linear pendulum as two simultaneous first order ODEs. Using expressions 11 and 12 on the tutorial page, and following the same method outlined as that outlined for the Strange Attractor, write a piece of code for modelling $ theta$ as a function of time. . Tip: Combine the two variable $ theta$ and $ omega$ into a single vector $ mathbf{r} = ( theta, omega)$. The method will give us a value for $ theta$ and $ omega$, but we can ignore the $ omega$ values generated if they are not needed. . . Back to Modelling with Ordinary Differential Equations. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/ODE_exercises.html",
            "relUrl": "/2021/08/02/ODE_exercises.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post36": {
            "title": "Classifying differential equations",
            "content": ". Questions: . What is a differential equation? | What is the difference between an ordinary (ODE) and partial (PDE) differential equation? | How do I classify the different types of differential equations? | . . . Objectives: . Identify the dependent and independent variables in a differential equation | Distinguish between and ODE and PDE | Identify the order of a differential equation | Distinguish between linear and non-linear equations | Distinguish between heterogeneous and homogeneous equations | Identify a separable equation | . . A differential equation is an equation that relates one or more functions and their derivatives . The functions usually represent physical quantities (e.g. $ mathbf{F}$)) | The derivative represents a rate of change (e.g. acceleration) | The differential equation represents the relationship between the two. | For example, Newton&#39;s second law for $n$ particles of mass $m$: | . begin{equation} mathbf{F}(t, mathbf{x}, mathbf{v}) = m frac{d mathbf{v}}{dt} end{equation} An independent variable is... a quantity that varies independently... . An independent variable does not depend on other variables | A dependent variable depends on the independent variable | . begin{equation} mathbf{F}(t, mathbf{x}, mathbf{v}) = m frac{d mathbf{v}}{dt} end{equation} $t$ is an independent variable | $x$ and $v$ are dependent variables | Writing $x = x(t)$ makes this relationship clear. | . Differential equations can be classified in a variety of ways . There are several ways to describe and classify differential equations. There are standard solution methods for each type, so it is useful to understand the classifications. . . Once you can cook a single piece of spaghetti, you can cook all pieces of spaghetti! . An ODE contains differentials with respect to only one variable . For example, the following equations are ODEs: . begin{equation} frac{d x}{d t} = at end{equation} begin{equation} frac{d^3 x}{d t^3} + frac{x}{t} = b end{equation}As in each case the differentials are with respect to the single variable $t$. . Partial differential equations (PDE) contain differentials with respect to several independent variables. . An example of a PDE is: . begin{equation} frac{ partial x}{ partial t} = frac{ partial x}{ partial y} end{equation}As there is one differential with respect to $t$ and one differential with respect to $y$. . Note also the difference in notation - for ODEs we use $d$ whilst for PDEs we use $ partial$. . Note: the equations in this notebook are formatted using LaTeX. . The order of a differential equation is the highest order of any differential contained in it. . For example: . $ frac{d x}{d t} = at$ is first order. . $ frac{d^3 x}{d t^3} + frac{x}{t} = b$ is third order. . Important: $ frac{d^3 x}{d t^3}$ does not equal $ left( frac{d x}{d t} right)^3$! . Linear equations do not contain higher powers of either the dependent variable or its differentials . For example: . $ frac{d^3 x}{d t^3} = at$ and $ frac{ partial x}{ partial t} = frac{ partial x}{ partial y} $ are linear. . $( frac{d x}{d t})^3 = at$ and $ frac{d^3 x}{d t^3} = x^2$ are non-linear. . Non-linear equations can be particularly nasty to solve analytically, and so are often tackled numerically. . Homogeneous equations do not contain any non-differential terms . For example: . $ frac{ partial x}{ partial t} = frac{ partial x}{ partial y}$ is a homogeneous equation. . $ frac{ partial x}{ partial t} - frac{ partial x}{ partial y}=a$ is a heterogeneous equation (unless $a=0$!). . Separable equations can be written as a product of two functions of different variables . A separable first-order one-variable differential equation takes the form . begin{equation} f(x) frac{d x}{d t} = g(t) end{equation}Separable equations are some of the easiest to solve as we can split the equation into two independent parts with fewer variables, and solve each in turn - we will see an example of this in the next lesson. . . Summary: . An independent variable is a quantity that varies independently | Differential equations can be classified in a variety of ways | An ODE contains differentials with respect to only one variable | The order is the highest order of any differential contained in it | Linear equations do not contain higher powers of either the dependent variable or its differentials | Homogeneous equations do not contain any non-differential terms | . . . Do the quick-test. . Back to Modelling with Ordinary Differential Equations. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/ODE-Types.html",
            "relUrl": "/2021/08/02/ODE-Types.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post37": {
            "title": "Classifying differential equations - quick test",
            "content": "Describing equations . Describe the following differential equations. Are they - . an ODE or PDE? | first order or higher? | linear or non-linear? | heterogeneous or homogeneous? | separable or non-separable? | . a) The oscillation of a non-linear driven pendulum, . begin{equation} frac{ mathrm{d}^2 theta}{ mathrm{d}t^2} = - frac{g}{l} sin( theta) + C cos( theta) sin( sigma t), end{equation} . where $l$ and $ sigma$ are constant parameters and $g$ is the acceleration due to gravity. . b) The one dimensional diffusion equation, . begin{equation} frac{ partial T}{ partial t} = D frac{ partial ^2 T}{ partial x^2}. end{equation} . c) The motion of mass $m_1$ in the gravitational field of mass $m_2$ and with a viscous friction term, . begin{equation} m_1 frac{ mathrm{d}^2 mathbf{r}}{ mathrm{d} t^2} = - frac{G m_1 m_2}{r^2} mathbf{r} - cv^2 mathbf{v}, end{equation} . where $v$ is the velocity. . Show answer a) This equation is a second order, linear, heterogeneous, non-separable ODE. . b) This equation is a second order, linear, homogeneous PDE. A linear, homogeneous PDE is separable and can be solved using the Separation of Variables. . c) This equation is a second order, non-linear, heterogeneous, non-separable ODE. .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/ODE-Types-Qs.html",
            "relUrl": "/2021/08/02/ODE-Types-Qs.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post38": {
            "title": "Numerical Integration",
            "content": ". Questions: . How can I do basic numerical integration? | . Objectives: . Use the rectangular-slice approximation to calculate integrals | Describe the difference between a zeroth-order and first-order integration rule | . . Depending on the functional form of f(x), it may not be possible to calculate an integral analytically . The integral of $f(x)$ from $a$ to $b$ is the area under the curve. Depending on the functional form of $f(x)$, it may not be possible to calculate the integral analytically. . Riemann sums are a family of methods used for approximating integral . The Riemann definition of the integral $I$ is: . $ I = lim_{n to infty} sum_{i=1}^N h f(x_i)$ . where the domain of integration has been split into $N$ slices, each with width $h = frac{b-a}{N}$. As we cannot in practice consider an infinite number of slices, this definition will give an approximation to the exact answer. By making $N$ large are approximation will, in many cases, be reasonable. . The simplest Riemann sum is based on rectangular slices . The simplest way to use this approach is to calculate $f(x_i)$ at some point on each slice and then calculate the area of the associated rectangle: . $ A_i = hf(x_i)$ . The integral is given by summing over all of the rectangles: . $ int_a^b f(x_i) dx approx sum_{i=1}^N A_i $ . The rectangular slices method can be translated to Python code in a straight-forward manner . For example, we may want to calculate the integral of $ sin(x)$ from 0 to $ frac{ pi}{2}$. This is an integral that can be evaluated analytically, so it doesn&#39;t usually make sense to calculate numerically - however, in this case, we can use it to establish that our method is correct. . import math def sin(x): return math.sin(x) def rectangular_slice_integral(f_x, a, b, N): integral = 0 h = (b-a) / N # h is the width of each slice for i in range(N): x = a + h*i # the x value for the slice integral += f_x(x)*h return integral . Note that the function rectangular_slice_integral has an argument f_x which is itself a function. This is valid Python - you can pass one function to another function as an argument. . rectangular_slice_integral(sin,0,math.pi/2,100) . 0.9921254566056334 . In fact, it is possible to pass the math.sin() function directly to rectangular_slice_integral(): . rectangular_slice_integral(math.sin,0,math.pi/2,100) . 0.9921254566056334 . This is pretty close to the correct value of 1. To improve our approximation we can increase the number of slices: . rectangular_slice_integral(math.sin,0,math.pi/2,200) . 0.9960678687587687 . The Riemann sums method a zeroth-order integration rule that will integrate a zeroth-order polynomial (ie, constant number) exactly. It has an error of order $h$ ($ mathcal{O}(h)$) - when we halve the rectangular width, we halve the error. . Riemann sums can be adapted for use with discrete data . Not all integrations are integrations of functions. For example, we may want to integrate experimental data, in which case there is no function to call to find the value of f(x). Instead, the most likely form of f(x) is given by the list of data values. In this case we can use the same method, but the implementation is slightly different: . def rectangular_slice_integral_discrete(data, h): return h*sum(data) . Note that this assumes the data is evenly spaced at width $h$ . . To test our function using the same example as above we need to generate a list of sin(x) values between 0 to $ frac{ pi}{2}$: . import numpy as np h = (math.pi/2)/100 sin_0_90 = [math.sin(x) for x in np.arange(0,math.pi/2,h)] . where we are using Python list comprehension and the Numpy arange function to generate a list of evenly spaced floats. . If we are simulating experimental data we should add a little noise or randomness to the data. We can use the Python standard library random and list comprehension to do this: . import random sin_0_90_noise = [x+random.uniform(-0.1,0.1) for x in sin_0_90] . We can now pass this list to our function rectangular_slice_integral_discrete: . rectangular_slice_integral_discrete(sin_0_90_noise, h) . 1.0094729791206596 . We can visualise the exact sinusoidal curve and noisy sinusoidal curve using the matplotlib plotting library: . import matplotlib.pyplot as plt plt.plot(np.arange(0,math.pi/2,h),sin_0_90,label=&quot;exact sine&quot;) plt.plot(np.arange(0,math.pi/2,h),sin_0_90_noise,label=&quot;noisy sine&quot;) . [&lt;matplotlib.lines.Line2D at 0x7fb8ee509730&gt;] . Higher-order Riemann sums increase the accuracy of our approximations . We can greatly improve the efficiency of our integration by approximating the slices as trapezoids instead of as rectangles. This is because the area under the trapezoids is a considerably better approximation to the area under the curve. . The trapezoidal rule a first-order integration rule that will integrate a first-order polynomial (ie, a straight line) exactly. We can say it is *accurate* to order $h$ ($ mathcal{O}(h)$) and has an *error* of order $h^2$ $ mathcal{O}(h^2)$ . . In many cases we can use Simpson&#39;s Rule for greater accuracy still. This technique involves fitting quadratic curves to pairs of slices and then calculating the area under the quadratics. In many cases Simpson&#39;s rule is more accurate than the trapezoidal rule, but this is not guaranteed for all integrands. . . Keypoints: . Depending on the functional form of f(x), it may not be possible to calculate an integral analytically | Riemann sums are a family of methods used for approximating integral | The simplest Riemann sum is based on rectangular slices | The rectangular slices method can be translated to Python code in a straight-forward manner | Riemann sums can be adapted for use with discrete data | Higher-order Riemann sums increase the accuracy of our approximations | . . Do the quick-test. . Back to Calculating Integrals. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Numerical-Integration.html",
            "relUrl": "/2021/08/02/Numerical-Integration.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post39": {
            "title": "Numerical integration - quick test",
            "content": "Integrating a semicircle . Use Riemann sums (with 10 rectangular slices) to calculate the value of the integral: . $ I = int_{-1}^1 sqrt{1-x^2} mathrm{d}x $ . How does this compare to exact answer? (Hint: the integrand is a semicircle of radius 1) . How can you improve the accuracy of your estimate? . Show answer We can use the same approach as in the tutorial, but with a different function for calculating the integrand. . import math def semicircle(x): return math.sqrt(1-x**2) def rectangular_slice_integral(f_x, a, b, N): integral = 0 h = (b-a) / N # h is the width of each slice for i in range(N): x = a + h*i # the x value for the slice integral += f_x(x)*h return integral rectangular_slice_integral(semicircle, -1, 1, 100) . 1.5691342555492505 . The exact answer is $ frac{ pi}{2}$. The error on our calculation is . math.pi/2 - rectangular_slice_integral(semicircle, -1, 1, 100) . 0.0016620712456461018 . To improve the accuracy we can use a larger number of slices: . math.pi/2 - rectangular_slice_integral(semicircle, -1, 1, 1000) . 5.2588293825595045e-05 .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Numerical-Integration-Qs.html",
            "relUrl": "/2021/08/02/Numerical-Integration-Qs.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post40": {
            "title": "Calculating integrals using Monte Carlo methods",
            "content": ". Questions: . How do I generate random numbers? | How do I integrate using Monte Carlo methods? | When might Monte Carlo integration be useful? | . Objectives: . Use the random module to generate random numbers | Use Monte Carlo methods to calculate the area of a circle | . . There are many different numerical methods for calculating integrals . In the previous section we studied the simplest methods for calculating integrals: the rectangular-slice method . For increased accuracy and computational efficiency, there are extensions to this approach - for example, the trapezoid method (where each slice is a trapezoid rather than rectangle) or Simpson&#39;s rule (where a quadratic curve is fitted to each slice). For certain classes of functions we can increase the performance further using more specialised approaches such as Gaussian Quadrature. . One particularly flexible and general purpose approach for calculating integrals is to use Monte Carlo integration. This approach is useful when the integrand is &quot;pathological&quot; (wildly varying) or noisy, or when the integration is performed over several variables. . Monte Carlo methods calculate the answers to exact calculations by doing random calculations . Monte Carlo methods are a broad class of algorithms that rely on random sampling to obtain numerical results. The underlying concept is to use randomness to solve problems that might be deterministic in principle. &quot;Monte Carlo&quot; is a reference to a well-known casino town, since the element of chance is core to the modelling approach, similar to various casino games. . Monte Carlo methods are applied across a wide variety of domains, most commonly mathematics, physics and finance. In physics, Monte Carlo methods are used to design particle detectors, model galaxy evolution and solve the many-body problem for quantum systems, amongst many other applications. In this lesson we will introduce one of the main uses of Monte Carlo: for integration. . The Monte Carlo &quot;area method&quot; estimates integrals by generating a uniform sample of points and counting how many fall into a planar region . Consider the shaded area as shown below. This is the integral $I$ which we wish to calculate. . . If we choose a point uniformly at random in the rectange (dashed red line) that bounds the shaded area, the probability $p$ that the point falls in the shaded area is . $$p = frac{I}{A}$$ . where $A$ is the area of the bounding rectangle. This means that the integral $I$ can be calculated if we know the area of the bounding rectangle and the probability $p$: . $$I = Ap$$ . To calculate $p$ we can randomly generate $N$ points in the bounding area and keep count as to how many lie in the shaded area. If $k$ lie in the shaded area then the fraction of points $ frac{k}{N}$ should be equal to the probability $p$. . $$I = frac{Ak}{N}$$ . We can extend this approach to higher dimensions to consider integrands lying within a bounding volume, or higher dimensional space (which is considered in the extension exercise for this lesson). . We can use the Monte Carlo area method to estimate pi . We&#39;ll now use this approach to give us an estimate for the value of pi by considering the area under a quarter-circle. . The relevant equations are: . square area: $A_s = (2 r)^2$ circle area: $A_c = pi r^2$ . The ratio of the areas can be related to $ pi$ through the following expressions: . $ frac{A_c}{A_s} = frac{ pi r^2}{4 r^2} = frac{ pi}{4}$ $ pi = 4 frac{A_c}{A_s}$ . To approximate the ratio $ frac{A_c}{A_s}$ we will generate a (uniform) pseudo-random number between 0 and 1 for our x-coordinates, and a (uniform) pseudo-random number between 0 and 1 for our y-coordinates. We will then check if our random point lies in or out of the circle. The probability $P_i$ that our point lies in the circle is related to the area ratio and so value of pi: . $P_i = frac{A_c}{A_s} = frac{ pi}{4}$ . The Monte Carlo area method can be translated into Python code . import random import math # in this function we generate random numbers and count how many lie within the circle def estimate_pi(num_points): points = [] hits = 0 for i in range(num_points): # random.random returns a random number drawn from a uniform distribution from 0 to 1 x, y = random.random(), random.random() # we test if the point is within the circle (using the equation for a circle, X^2+y^2=r^2) if x*x + y*y &lt; 1.0: hits += 1 probability = hits / num_points return probability*4 . estimate_pi(1000) . 3.104 . estimate_pi(2000) . 3.176 . This method usually improves with the number of points, however there can be some variation due to the randomness of the numbers used. If you would like others to reproduce your exact results, you can seed the (pseudo-)random number generator: . random.seed(1) print(&quot;error is {}&quot;.format(math.pi-estimate_pi(1000))) . error is 0.029592653589793017 . random.seed(1) print(&quot;error is {}&quot;.format(math.pi-estimate_pi(2000))) . error is -0.004407346410206792 . Monte Carlo integration is computationally efficient for particular types of integrand . The error when using Monte Carlo integration is proportional to $N^{- frac{1}{2}}$, which is larger than the rectangular slice approach with error order $h propto N^{-1}$ (where $N$ in this case is the number of integration slices). However Monte Carlo methods are more flexible and can be used where other methods break-down: for example, they are particularly useful for integrating functions where the integrand varies very quickly, and/or where the integral is over many variables. In many cases, for &quot;well behaved&quot; functions, an approach based on Riemann summation will give more accurate and computationally efficient results. . . Keypoints: . There are many different numerical methods for calculating integrals | Monte Carlo methods calculate the answers to exact calculations by doing random calculations | The Monte Carlo &quot;area method&quot; estimates integrals by generating a uniform sample of points and counting how many fall into a planar region | We can use the Monte Carlo area method to estimate pi | The Monte Carlo area method can be translated into Python code | Monte Carlo integration is computationally efficient for particular types of integrand | . . Do the quick-test. . Back to Calculating Integrals. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Monte-Carlo.html",
            "relUrl": "/2021/08/02/Monte-Carlo.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post41": {
            "title": "Monte Carlo methods for integration - quick test",
            "content": "Integrating a semicircle re-visited . Use Monte Carlo integration (with 100 random points) to calculate the value of the integral: . $ I = int_{-1}^1 sqrt{1-x^2} mathrm{d}x $ . How does this compare to exact answer? (Hint: the integrand is a semicircle of radius 1) . How can you improve the accuracy of your estimate? . Increase the number of points until you get an accuracy comparable (same order of magnitude) as the Riemann sum method with 100 points (which was implemented in the Numerical integration - quick test). . Use the %%timeit notebook magic to compare the calculation times for the Riemann sum method and Monte Carlo method. . Which is more efficient? . Show answer We want to calculate the area of a semicircle with radius 1. We can adapt the approach used in the Monte Carlo tutorial but, in this case, we use the fact that $P_i = frac{A_c}{A_r}$ where $A_r$ is a rectangle of length 2 (as the semicircle goes from $-1$ to $1$) and height 1. . import random import math def estimate_semicircle_area(num_points): points = [] hits = 0 for i in range(num_points): # random.uniform(a,b) returns a random number drawn from a uniform distribution from a to b x, y = random.uniform(-1,1), random.uniform(0,1) # we test if the point is within the circle (using the equation for a circle, X^2+y^2=r^2) if x*x + y*y &lt; 1.0: hits += 1 probability = hits / num_points rectangle_area = 2 return probability*rectangle_area estimate_semicircle_area(100) . 1.58 . Note that your estimate will be different as you be using a different set of random numbers. The exact answer is $ frac{ pi}{2}$. The error on our calculation is . math.pi/2 - estimate_semicircle_area(100) . -0.04920367320510355 . To improve the accuracy we can use a larger number of random points: . math.pi/2 - estimate_semicircle_area(1000) . 0.04679632679489654 . math.pi/2 - estimate_semicircle_area(10000) . -0.0048036732051033315 . Increasing the number of points to 10,000 gives an error comparable to the Riemann sum method with 100 integration slices (where the error is 0.002). Let’s use the %%timeit magic to time how long each takes to run . %%timeit estimate_semicircle_area(10000) . 6.23 ms ± 370 µs per loop (mean ± std. dev. of 7 runs, 100 loops each) . %%timeit rectangular_slice_integral(semicircle, -1, 1, 100) . 31 µs ± 1.09 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each) . As each method gives roughly the same accuracy, but the estimate_semicircle_area is 100x smaller, we can deduce that the Monte Carlo method implemented in estimate_semicircle_area is considerably less efficient than the Riemann summation method implemented in rectangular_slice_integral. However the Monte Carlo method is useful for badly behaving systems, as we will see in the lesson exercises. .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Monte-Carlo-Qs.html",
            "relUrl": "/2021/08/02/Monte-Carlo-Qs.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post42": {
            "title": "Lists",
            "content": ". Questions: . How can I store multiple values? | . Objectives: . Explain why programs need collections of values. | Write programs that create flat lists, index them, slice them, and modify them through assignment and method calls. | . Keypoints: . A list stores many values in a single structure. | Use an item&#39;s index to fetch it from a list. | Lists&#39; values can be replaced by assigning to them. | Appending items to a list lengthens it. | Use del to remove items from a list entirely. | The empty list contains no values. | Lists may contain values of different types. | Character strings can be indexed like lists. | Character strings are immutable. | Indexing beyond the end of the collection is an error. | . . A list stores many values in a single structure. . Doing calculations with a hundred variables called pressure_001, pressure_002, etc., would be at least as slow as doing them by hand. | Use a list to store many values together. Contained within square brackets [...]. | Values separated by commas ,. | . | Use len to find out how many values are in a list. | . pressures = [0.273, 0.275, 0.277, 0.275, 0.276] print(&#39;pressures:&#39;, pressures) print(&#39;length:&#39;, len(pressures)) . pressures: [0.273, 0.275, 0.277, 0.275, 0.276] length: 5 . Use an item&#39;s index to fetch it from a list. . Just like strings. | . print(&#39;zeroth item of pressures:&#39;, pressures[0]) print(&#39;fourth item of pressures:&#39;, pressures[4]) . zeroth item of pressures: 0.273 fourth item of pressures: 0.276 . Lists&#39; values can be replaced by assigning to them. . Use an index expression on the left of assignment to replace a value. | . pressures[0] = 0.265 print(&#39;pressures is now:&#39;, pressures) . pressures is now: [0.265, 0.275, 0.277, 0.275, 0.276] . Appending items to a list lengthens it. . Use list_name.append to add items to the end of a list. | . primes = [2, 3, 5] print(&#39;primes is initially:&#39;, primes) primes.append(7) primes.append(9) print(&#39;primes has become:&#39;, primes) . primes is initially: [2, 3, 5] primes has become: [2, 3, 5, 7, 9] . append is a method of lists. A method is like a function, but tied to a particular object. | Use object_name.method_name to call methods. | We will meet other methods of lists as we go along - you can use help(list) for a preview. | extend is similar to append, but it allows you to combine two lists. For example: | . teen_primes = [11, 13, 17, 19] middle_aged_primes = [37, 41, 43, 47] print(&#39;primes is currently:&#39;, primes) primes.extend(teen_primes) print(&#39;primes has now become:&#39;, primes) primes.append(middle_aged_primes) print(&#39;primes has finally become:&#39;, primes) . primes is currently: [2, 3, 5, 7, 9] primes has now become: [2, 3, 5, 7, 9, 11, 13, 17, 19] primes has finally become: [2, 3, 5, 7, 9, 11, 13, 17, 19, [37, 41, 43, 47]] . Note that while extend maintains the &quot;flat&quot; structure of the list, appending a list to a list makes the result two-dimensional. . Use del to remove items from a list entirely. . del list_name[index] removes an item from a list and shortens the list. | Not a function or a method, but a statement in the language. | . print(&#39;primes before removing last item:&#39;, primes) del primes[4] print(&#39;primes after removing last item:&#39;, primes) . primes before removing last item: [2, 3, 5, 7, 9, 11, 13, 17, 19, [37, 41, 43, 47]] primes after removing last item: [2, 3, 5, 7, 11, 13, 17, 19, [37, 41, 43, 47]] . The empty list contains no values. . Use [] on its own to represent a list that doesn&#39;t contain any values. &quot;The zero of lists.&quot; | . | Helpful as a starting point for collecting values (which we will see in the next episode). | . Lists may contain values of different types. . A single list may contain numbers, strings, and anything else. | . goals = [1, &#39;Create lists.&#39;, 2, &#39;Extract items from lists.&#39;, 3, &#39;Modify lists.&#39;] . Character strings can be indexed like lists. . Get single characters from a character string using indexes in square brackets. | . element = &#39;carbon&#39; print(&#39;zeroth character:&#39;, element[0]) print(&#39;third character:&#39;, element[3]) . zeroth character: c third character: b . Character strings are immutable. . Cannot change the characters in a string after it has been created. Immutable data types can&#39;t be changed after creation. | In contrast, lists are mutable: they can be modified in place. | . | Python considers the string to be a single value with parts, not a collection of values. | . element[0] = &#39;C&#39; . TypeError Traceback (most recent call last) /var/folders/5q/mny3pg2n7h5g21h3v32rfj9wpykqrf/T/ipykernel_11747/1676686116.py in &lt;module&gt; -&gt; 1 element[0] = &#39;C&#39; TypeError: &#39;str&#39; object does not support item assignment . Indexing beyond the end of the list or string is an error. . Python reports an IndexError if we attempt to access a value that doesn&#39;t exist. This is a kind of runtime error. | This cannot be detected as the code is parsed because the index might be calculated based on data. | . | . print(&#39;99th element of element is:&#39;, element[99]) . . Do the quick-test. . Back to Python part one. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Lists.html",
            "relUrl": "/2021/08/02/Lists.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post43": {
            "title": "Lists - quick test",
            "content": "Fill in the Blanks . Fill in the blanks so that the program below produces the output shown. . values = ____ values.____(1) values.____(3) values.____(5) print(&#39;first time:&#39;, values) values = values[____] print(&#39;second time:&#39;, values) . first time: [1, 3, 5] second time: [3, 5] . Show answer values = [] values.append(1) values.append(3) values.append(5) print(&#39;first time:&#39;, values) values = values[1:] print(&#39;second time:&#39;, values) . How Large is a Slice? . If ‘low’ and ‘high’ are both non-negative integers, how long is the list values[low:high]? . Show answer The list values[low:high] has high - low elements. For example, values[1:4] has the 3 elements values[1], values[2], and values[3]. Note that the expression will only work if high is less than the total length of the list values. . From Strings to Lists and Back . Given this: . print(&#39;string to list:&#39;, list(&#39;tin&#39;)) print(&#39;list to string:&#39;, &#39;&#39;.join([&#39;g&#39;, &#39;o&#39;, &#39;l&#39;, &#39;d&#39;])) . [&#39;t&#39;, &#39;i&#39;, &#39;n&#39;] &#39;gold&#39; . Explain in simple terms what list(&#39;some string&#39;) does. | What does &#39;-&#39;.join([&#39;x&#39;, &#39;y&#39;]) generate? | Show answer list(&#39;some string&#39;) “splits” a string into a list of its characters. | x-y | Working With the End . What does the following program print? . element = &#39;helium&#39; print(element[-1]) . How does Python interpret a negative index? | If a list or string has N elements, what is the most negative index that can safely be used with it, and what location does that index represent? | If values is a list, what does del values[-1] do? | How can you display all elements but the last one without changing values? (Hint: you will need to combine slicing and negative indexing.) | Show answer The program prints m. . Python interprets a negative index as starting from the end (as opposed to starting from the beginning). The last element is -1. | The last index that can safely be used with a list of N elements is element -N, which represents the first element. | del values[-1] removes the last element from the list. | values[:-1] | Stepping Through a List . What does the following program print? . element = &#39;fluorine&#39; print(element[::2]) print(element[::-1]) . If we write a slice as low:high:stride, what does stride do? | What expression would select all of the even-numbered items from a collection? | Show answer The program prints . furn eniroulf . stride is the step size of the slice | The slice 1::2 selects all even-numbered items from a collection: it starts with element 1 (which is the second element, since indexing starts at 0), goes on until the end (since no end is given), and uses a step size of 2 (i.e., selects every second element). | Copying (or Not) . What do these two programs print? In simple terms, explain the difference between new = old and new = old[:]. . # Program A old = list(&#39;gold&#39;) new = old # simple assignment new[0] = &#39;D&#39; print(&#39;new is&#39;, new, &#39;and old is&#39;, old) . # Program B old = list(&#39;gold&#39;) new = old[:] # assigning a slice new[0] = &#39;D&#39; print(&#39;new is&#39;, new, &#39;and old is&#39;, old) . Show answer Program A prints . &gt; &gt; new is [&#39;D&#39;, &#39;o&#39;, &#39;l&#39;, &#39;d&#39;] and old is [&#39;D&#39;, &#39;o&#39;, &#39;l&#39;, &#39;d&#39;] . Program B prints . &gt; &gt; new is [&#39;D&#39;, &#39;o&#39;, &#39;l&#39;, &#39;d&#39;] and old is [&#39;g&#39;, &#39;o&#39;, &#39;l&#39;, &#39;d&#39;] . new = old makes new a reference to the list old; new and old point towards the same object. . new = old[:] however creates a new list object new containing all elements from the list old; new and old are different objects. . . See the notebook. . Back to Python basics - part one. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Lists-Qs.html",
            "relUrl": "/2021/08/02/Lists-Qs.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post44": {
            "title": "Libraries",
            "content": "Questions: . How can I use software that other people have written? | How can I find out what that software does? | . Objectives: . Explain what software libraries are and why programmers create and use them. | Write programs that import and use libraries from Python&#39;s standard library. | Find and read documentation for standard libraries interactively (in the interpreter) and online. | . Keypoints: . Most of the power of a programming language is in its libraries. | A program must import a library module in order to use it. | Use help to learn about the contents of a library module. | Import specific items from a library to shorten programs. | Create an alias for a library when importing it to shorten programs. | . Most of the power of a programming language is in its libraries. . A library is a collection of files (called modules) that contains functions for use by other programs. It may also contain data values (e.g., numerical constants) and other things. A library&#39;s contents are supposed to be related, but there&#39;s no way to enforce that. . The Python standard library is an extensive suite of modules that comes with Python itself. There are many additional libraries that are available from the Python Package Index and Conda. . . Note: A library is a collection of modules, but the terms are often used interchangeably, especially since many libraries only consist of a single module, so don&#39;t worry if you mix these words up. . A program must import a library module before using it. . Use import to load a library module into a program&#39;s memory. Then refer to things from the module as module_name.thing_name. . For example, using math, one of the modules in the standard library: . import math print(&#39;pi is&#39;, math.pi) . pi is 3.141592653589793 . We have to refer to each item with the module&#39;s name. The expression math.pi is a variable pi that belongs to the Python math library. . This dotted notation is used everywhere in Python: the thing that appears before the dot contains the thing that appears after. . As an example, John Smith is the John that belongs to the Smith family. We could use the dot notation to write his name smith.john, just as pi is a variable that belongs to the math library. . A common mistake is to forget to specify the library when nesting expressions. For example, math.cos(pi) won&#39;t work: the reference to pi doesn&#39;t somehow &quot;inherit&quot; the function&#39;s reference to math. . print(&#39;cos(pi) is&#39;, math.cos(math.pi)) # math.cos(pi) wouldn&#39;t work . cos(pi) is -1.0 . Use help to learn about the contents of a library module. . help(math) . Help on module math: NAME math MODULE REFERENCE https://docs.python.org/3.8/library/math The following documentation is automatically generated from the Python source files. It may be incomplete, incorrect or include features that are considered implementation detail and may vary between Python implementations. When in doubt, consult the module reference at the location listed above. DESCRIPTION This module provides access to the mathematical functions defined by the C standard. FUNCTIONS acos(x, /) Return the arc cosine (measured in radians) of x. acosh(x, /) Return the inverse hyperbolic cosine of x. asin(x, /) Return the arc sine (measured in radians) of x. asinh(x, /) Return the inverse hyperbolic sine of x. atan(x, /) Return the arc tangent (measured in radians) of x. atan2(y, x, /) Return the arc tangent (measured in radians) of y/x. Unlike atan(y/x), the signs of both x and y are considered. atanh(x, /) Return the inverse hyperbolic tangent of x. ceil(x, /) Return the ceiling of x as an Integral. This is the smallest integer &gt;= x. comb(n, k, /) Number of ways to choose k items from n items without repetition and without order. Evaluates to n! / (k! * (n - k)!) when k &lt;= n and evaluates to zero when k &gt; n. Also called the binomial coefficient because it is equivalent to the coefficient of k-th term in polynomial expansion of the expression (1 + x)**n. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. copysign(x, y, /) Return a float with the magnitude (absolute value) of x but the sign of y. On platforms that support signed zeros, copysign(1.0, -0.0) returns -1.0. cos(x, /) Return the cosine of x (measured in radians). cosh(x, /) Return the hyperbolic cosine of x. degrees(x, /) Convert angle x from radians to degrees. dist(p, q, /) Return the Euclidean distance between two points p and q. The points should be specified as sequences (or iterables) of coordinates. Both inputs must have the same dimension. Roughly equivalent to: sqrt(sum((px - qx) ** 2.0 for px, qx in zip(p, q))) erf(x, /) Error function at x. erfc(x, /) Complementary error function at x. exp(x, /) Return e raised to the power of x. expm1(x, /) Return exp(x)-1. This function avoids the loss of precision involved in the direct evaluation of exp(x)-1 for small x. fabs(x, /) Return the absolute value of the float x. factorial(x, /) Find x!. Raise a ValueError if x is negative or non-integral. floor(x, /) Return the floor of x as an Integral. This is the largest integer &lt;= x. fmod(x, y, /) Return fmod(x, y), according to platform C. x % y may differ. frexp(x, /) Return the mantissa and exponent of x, as pair (m, e). m is a float and e is an int, such that x = m * 2.**e. If x is 0, m and e are both 0. Else 0.5 &lt;= abs(m) &lt; 1.0. fsum(seq, /) Return an accurate floating point sum of values in the iterable seq. Assumes IEEE-754 floating point arithmetic. gamma(x, /) Gamma function at x. gcd(x, y, /) greatest common divisor of x and y hypot(...) hypot(*coordinates) -&gt; value Multidimensional Euclidean distance from the origin to a point. Roughly equivalent to: sqrt(sum(x**2 for x in coordinates)) For a two dimensional point (x, y), gives the hypotenuse using the Pythagorean theorem: sqrt(x*x + y*y). For example, the hypotenuse of a 3/4/5 right triangle is: &gt;&gt;&gt; hypot(3.0, 4.0) 5.0 isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0) Determine whether two floating point numbers are close in value. rel_tol maximum difference for being considered &#34;close&#34;, relative to the magnitude of the input values abs_tol maximum difference for being considered &#34;close&#34;, regardless of the magnitude of the input values Return True if a is close in value to b, and False otherwise. For the values to be considered close, the difference between them must be smaller than at least one of the tolerances. -inf, inf and NaN behave similarly to the IEEE 754 Standard. That is, NaN is not close to anything, even itself. inf and -inf are only close to themselves. isfinite(x, /) Return True if x is neither an infinity nor a NaN, and False otherwise. isinf(x, /) Return True if x is a positive or negative infinity, and False otherwise. isnan(x, /) Return True if x is a NaN (not a number), and False otherwise. isqrt(n, /) Return the integer part of the square root of the input. ldexp(x, i, /) Return x * (2**i). This is essentially the inverse of frexp(). lgamma(x, /) Natural logarithm of absolute value of Gamma function at x. log(...) log(x, [base=math.e]) Return the logarithm of x to the given base. If the base not specified, returns the natural logarithm (base e) of x. log10(x, /) Return the base 10 logarithm of x. log1p(x, /) Return the natural logarithm of 1+x (base e). The result is computed in a way which is accurate for x near zero. log2(x, /) Return the base 2 logarithm of x. modf(x, /) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. perm(n, k=None, /) Number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k &lt;= n and evaluates to zero when k &gt; n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. pow(x, y, /) Return x**y (x to the power of y). prod(iterable, /, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. radians(x, /) Convert angle x from degrees to radians. remainder(x, y, /) Difference between x and the closest integer multiple of y. Return x - n*y where n*y is the closest integer multiple of y. In the case where x is exactly halfway between two multiples of y, the nearest even value of n is used. The result is always exact. sin(x, /) Return the sine of x (measured in radians). sinh(x, /) Return the hyperbolic sine of x. sqrt(x, /) Return the square root of x. tan(x, /) Return the tangent of x (measured in radians). tanh(x, /) Return the hyperbolic tangent of x. trunc(x, /) Truncates the Real x to the nearest Integral toward 0. Uses the __trunc__ magic method. DATA e = 2.718281828459045 inf = inf nan = nan pi = 3.141592653589793 tau = 6.283185307179586 FILE /Users/lucy/miniconda3/lib/python3.8/lib-dynload/math.cpython-38-darwin.so . Import specific items from a library module to shorten programs. . Use from ... import ... to load only specific items from a library module. Then refer to them directly without library name as prefix. . from math import cos, pi print(&#39;cos(pi) is&#39;, cos(pi)) . cos(pi) is -1.0 . Create an alias for a library module when importing it to shorten programs. . Use import ... as ... to give a library a short alias while importing it. Then refer to items in the library using that shortened name. . import math as m print(&#39;cos(pi) is&#39;, m.cos(m.pi)) . cos(pi) is -1.0 . Commonly used for libraries that are frequently used or have long names. - e.g., matplotlib plotting library is often aliased as mpl. But this can make programs harder to understand, since readers must learn your program&#39;s aliases. . . Do the quick-test. . Back to Python part two. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Libraries.html",
            "relUrl": "/2021/08/02/Libraries.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post45": {
            "title": "Libraries - quick test",
            "content": "Exploring the Math Module . What function from the math module can you use to calculate a square root without using sqrt? | Since the library contains this function, why does sqrt exist? | Show answer Using help(math) we see that we’ve got pow(x,y) in addition to sqrt(x), so we could use pow(x, 0.5) to find a square root. | The sqrt(x) function is arguably more readable than pow(x, 0.5) when implementing equations. Readability is a cornerstone of good programming, so it makes sense to provide a special function for this specific common case. | Also, the design of Python’s math library has its origin in the C standard, which includes both sqrt(x) and pow(x,y), so a little bit of the history of programming is showing in Python’s function names. . Locating the Right Module . You want to select a random character from a string: . bases = &#39;ACTTGCTTGAC&#39; . Which standard library module could help you? | Which function would you select from that module? Are there alternatives? | Try to write a program that uses the function. | Show answer The random module seems like it could help you. . The string has 11 characters, each having a positional index from 0 to 10. You could use random.randrange function (or the alias random.randint if you find that easier to remember) to get a random integer between 0 and 10, and then pick out the character at that position: . from random import randrange random_index = randrange(len(bases)) print(bases[random_index]) . or more compactly: . from random import randrange print(bases[randrange(len(bases))]) . Perhaps you found the random.sample function? It allows for slightly less typing: . from random import sample print(sample(bases, 1)[0]) . Note that this function returns a list of values. We will learn about lists in episode 11. . There’s also other functions you could use, but with more convoluted code as a result. . Jigsaw Puzzle (Parson’s Problem) Programming Example . Rearrange the following statements so that a random DNA base is printed and its index in the string. Not all statements may be needed. Feel free to use/add intermediate variables. . bases=&quot;ACTTGCTTGAC&quot; import math import random ___ = random.randrange(n_bases) ___ = len(bases) print(&quot;random base &quot;, bases[___], &quot;base index&quot;, ___) . Show answer import math import random bases = &quot;ACTTGCTTGAC&quot; n_bases = len(bases) idx = random.randrange(n_bases) print(&quot;random base&quot;, bases[idx], &quot;base index&quot;, idx) . When Is Help Available? . When a colleague of yours types help(math), Python reports an error: . NameError: name &#39;math&#39; is not defined . What has your colleague forgotten to do? . Show answer Importing the math module (import math) . Importing With Aliases . Fill in the blanks so that the program below prints 90.0. | Rewrite the program so that it uses import without as. | Which form do you find easier to read? | import math as m angle = ____.degrees(____.pi / 2) print(____) . Show answer import math as m angle = m.degrees(m.pi / 2) print(angle) . can bewritten as . import math angle = math.degrees(math.pi / 2) print(angle) . Since you just wrote the code and are familiar with it, you might actually find the first version easier to read. But when trying to read a huge piece of code written by someone else, or when getting back to your own huge piece of code after several months, non-abbreviated names are often easier, except where there are clear abbreviation conventions. . There Are Many Ways To Import Libraries! . Match the following print statements with the appropriate library calls. . Print commands: . print(&quot;sin(pi/2) =&quot;,sin(pi/2)) | print(&quot;sin(pi/2) =&quot;,m.sin(m.pi/2)) | print(&quot;sin(pi/2) =&quot;,math.sin(math.pi/2)) | Library calls: . from math import sin,pi | import math | import math as m | from math import * | Show answer Library calls 1 and 4. In order to directly refer to sin and pi without the library name as prefix, you need to use the from ... import ... statement. Whereas library call 1 specifically imports the two functions sin and pi, library call 4 imports all functions in the math module. | Library call 3. Here sin and pi are referred to with a shortened library name m instead of math. Library call 3 does exactly that using the import ... as ... syntax - it creates an alias for math in the form of the shortened name m. | Library call 2. Here sin and pi are referred to with the regular library name math, so the regular import ... call suffices. | Importing Specific Items . Fill in the blanks so that the program below prints 90.0. | Do you find this version easier to read than preceding ones? | Why wouldn’t programmers always use this form of import? | ____ math import ____, ____ angle = degrees(pi / 2) print(angle) . Show answer from math import degrees, pi angle = degrees(pi / 2) print(angle) . Most likely you find this version easier to read since it’s less dense. The main reason not to use this form of import is to avoid name clashes. For instance, you wouldn’t import degrees this way if you also wanted to use the name degrees for a variable or function of your own. Or if you were to also import a function named degrees from another library. . Reading Error Messages . Read the code below and try to identify what the errors are without running it. | Run the code, and read the error message. What type of error is it? | from math import log log(0) . Show answer The logarithm of x is only defined for x 0, so 0 is outside the domain of the function. | You get an error of type “ValueError”, indicating that the function received an inappropriate argument value. The additional message “math domain error” makes it clearer what the problem is. | . See the notebook. . Back to Python part two. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Libraries-Qs.html",
            "relUrl": "/2021/08/02/Libraries-Qs.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post46": {
            "title": "Getting started checklist",
            "content": "The course is built around a very widely used service in computational science and software engineering - Github. You can see the source code for this website over at the course Github repository. . Getting started checklist . We will be using Github issues to monitor your progress through the first part of the course “Getting Started”. . Create a Github account (it is free). | Go to the issues page for this course and click on “New Issue”. | Next to “Python basics checklist” click “Get started”. | Without editing any text, click “Submit new issue”. | Work through the tutorials and questions for part one of the course (“Getting Started”). Tick off items on the checklist as you progress. | . If you want to find your issue again, go back to the issues page and search for your username using `author:username` in the search bar. Class report . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Issues.html",
            "relUrl": "/2021/08/02/Issues.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post47": {
            "title": "Introduction",
            "content": "Computing has become central to virtually all research and development in academia and industry, and with the advent of Machine Learning and High-Performance Computing this dominance is set to continue. . Computational physics encompasses a wide number of areas including materials modelling, particle physics simulations, protein structure prediction and plasma modelling. In fact, it is possible to find a computational branch for every major field in physics. . The focus of this course is to equip with you with knowledge and skills needed to model a range of physical systems using numerical methods. You will also gain a number of transferable skills which can be applied across in a range of computational disciplines. . This course is split into three sections - Getting started, Getting results and Getting it out there. In the first part of the course, Getting started, we will recap the basic programming concepts and Python libraries that are applicable to a wide range of research and industry. In the middle section of the course, which is called Getting results, we will combine our Python knowledge with mathematical numerical methods to model various physical systems using differential equations. In the final section of the course, Getting it out there, we will use modern software engineering techniques to document, test and share our code. . How does this course relate to experimental physics? . The first part of this course recaps the basic skills needed for processing experimental data using Python. At the end of Getting started you will be able to read in experimental data from a plain text file, clean the data, apply basic statistical analysis and plot. We very much encourage you to apply the tools outlined in this course to your experimental analysis. . Do I need to attend the in-person labs? . We will aim to publish all course materials on this website however a large component of this course is based on the verbal explanations whilst writing code (a.k.a, “live coding”) and class discussion. It will all make much more sense if you attend the sessions in the computer lab. The computer labs will not be recorded. . Why do you use a Github website? . Blackboard collaborate is widely used at Northumbria University for teaching. However in the computational sciences (and in software engineering) Blackboard collaborate is not widely used. The aim here is to teach and learn using the tools that are already used in research and industry - hence building the course resources around the Github service. Also, the code can be nicely formatted using Markdown/html (rather than blackboard), making it easier for students to read and understand. . The source code for this website can be found in the course Github repository. If you spot any mistakes or would like to make a suggestions for improving the course please raise an issue on Github. . Blackboard collaborate will be used for posting assessments and for course announcements. .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Introduction.html",
            "relUrl": "/2021/08/02/Introduction.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post48": {
            "title": "Heat diffusion",
            "content": ". Questions: . How do I use the Forward-Time Centred-Space method (FTCS) to solve the diffusion equation? | . Objectives: . Apply the Forward-Time Centred-Space method (FTCS) to solve theat heat diffusion equation | . . The diffusion equation is an initial value problem . In the previous section we solved a boundary value problem in the form of Laplace&#39;s equation. In this section we will look at an initial value problem, which is a more complex type of PDE. An initial value problem is more complex as we are told the starting conditions and then have to predict future behaviour as a function of time. . The example we will use is the one-dimensional diffusion equation: . begin{equation} frac{ partial phi}{ partial t} = D frac{ partial^2 phi}{ partial x^2} end{equation}In this case we have a variable $ phi(x,t)$ that depends on position $x$ and time $t$ - so can we not solve it in the same way as finding the $ phi(x,y)$ Laplace&#39;s equation, which also had two independent variables? . The problem is that we only have an initial condition in the time dimension - we know the value of $ phi(x,t)$ at $t=0$ but we do not typically know the value of $t$ at a later point. In the spatial dimensions we know the boundary conditions at either end of the grid. . Instead, we will use the Forward-Time Centred-Space method (FTCS). . There are two steps to the Forward-Time Centred-Space method . Step one . Use the finite difference method to express the 1D Laplacian as a set of simulatenous equations: . begin{equation} frac{ partial^2 phi}{ partial x^2} = frac{ phi(x+a,t)+ phi(x-a,t) - 2 phi(x,t)}{a^2} end{equation}where $a$ is the grid spacing. . Substitute this back into the diffusion equation to give a set of simulataneous ODEs: . begin{equation} frac{d phi}{d t} = frac{D}{a^2}( phi(x+a,t)+ phi(x-a,t)-2 phi(x,t)) end{equation}If there are $N$ grid points then Equation 3 corresponds to a set of $N$ equations. It is an ODE as there is derivative with respect to only one variable - time. . Step two . We now have a set of simultaneous ODEs for $ phi(x,t)$. So we can use Euler&#39;s method to evolve the system forward in time. Euler&#39;s method for solving an ODE of the form $ frac{d phi}{dt} = f( phi,t)$ has the general form: . begin{equation} phi(t+h) simeq phi(t) + hf( phi, t). end{equation}Applying this to Equation 3 gives: . begin{equation} phi(x,t+h) = phi(x,t) + h frac{D}{a^2}( phi(x+a,t)+ phi(x-a,t)-2 phi(x,t)) end{equation} The FTCS method can be applied using the Python skills we have developed . Consider a 10cm rod of stainless steel initially at a uniform temperature of 20$^ mathrm{o}$ Celsius. The rod is dipped in a hot water bath at 90$^ mathrm{o}$ Celsius at one end, and held in someone&#39;s hand at the other. Assume that the hand is at constant body temperature throughout (27$^ mathrm{o}$ Celsius). . The problem can be represented visually as follows: . . Our goal is to calculate the temperature profile of the steel as a function of distance $x$ from the cold side to the hot side, and as a function of time. For simplicity let us assume that the rod is perfectly insulated so that heat only moves horizontally; as a result this problem can be modelled as 1-dimensional. Also assume that neighter the hot water bath or the hand change temperature appreciably. . Thermal conduction is described by the diffusion equation (or heat equation in this context) . begin{equation} frac{ partial phi}{ partial t} = D frac{ partial^2 phi}{ partial x^2}, end{equation}where $D$ is the material dependent thermal diffusivity. For steel $D=4.25 times10^{-6} mathrm{m}^2 mathrm{s}^{-1}$. . First, let&#39;s import the libraries we will be using . import numpy as np import matplotlib.pyplot as plt . Now let&#39;s fix some of the constants in the problem . L = 0.1 # width of the rod in metres D = 4.25e-6 # thermal diffusivity of steel . And some of the numerical parameters: . N = 100 # number of divisions in the grid a = L/N # grid spacing h = 1e-4 # time step . Let&#39;s specify the boundary conditions and the initial condition . T_left = 27.0 # temperature fixed on left side of rod T_right = 90.0 # temperature fixed on right side of rod T_middle = 20.0 # temperature of rod at the beginning . And now create an array $T$ to hold the temperature of the rod and an array $T_{ mathrm{new}}$ to calculate the temperature of the rod after evolving through time. Note that there are $N$ grid divisions but $N+1$ grid points (as we are evaluating at the boundary on each edge). . T = np.empty(N+1, float) T_new = np.empty(N+1, float) . Apply the boundary conditions and initial condition to our rod: . T[0] = T_left T[-1] = T_right T[1:-1] = T_middle T_new[0] = T_left T_new[-1] = T_right . def evolve(T,T_new): c = (h*D)/(a*a) T_new[1:N] = T[1:N] + c*(T[2:N+1]+T[0:N-1]-2*T[1:N]) return T, T_new . Note that in the function evolve we implement Equation 5. We make use of Numpy&#39;s element-by-element array manipulation to evaluate the $N-1$ equations in a single step. . epsilon = h/100 times=np.array([0.01,0.1,1,10,100]) t_end = times[-1]+epsilon t=0.0 while t &lt; t_end: T_new, T = evolve(T, T_new) t+=h for time in times: if abs(t-time)&lt;epsilon: plt.plot(T,label=&quot;{}s&quot;.format(round(t,ndigits=3))) plt.legend() plt.title(&quot;Heat diffusion along a 1D rod&quot;) plt.xlabel(&quot;Position (cm)&quot;) plt.ylabel(&quot;Temperature (degrees centigrade)&quot;) . Text(0, 0.5, &#39;Temperature (degrees centigrade)&#39;) . . Keypoints: . The diffusion equation is an initial value problem | There are two steps to the Forward-Time Centred-Space (FTCS) method | The FTCS method can be applied using the Python skills we have developed | . . Do the quick-test. . Back to Modelling with Partial Differential Equations. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Heat-Diffusion.html",
            "relUrl": "/2021/08/02/Heat-Diffusion.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post49": {
            "title": "Heat diffusion - quick test",
            "content": "There are no quick test questions for this tutorial (yet!) - can you think of one? Suggest it here. . . See the notebook. . Back to Modelling with Partial Differential Equations. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Heat-Diffusion-Qs.html",
            "relUrl": "/2021/08/02/Heat-Diffusion-Qs.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post50": {
            "title": "Programming good practice",
            "content": "Document your code . There are multiple ways you can document your code. Below are three examples: . Docstrings . Docstrings are the first statement in a module, function, class or method so programmers can understand what it does without having to read the details of the implementation. . Docstrings are string literals so must be contained within single quote marks (for single line docstrings) or triple quotes (for multiline docstrings). See the example below for a function-level docstring. . def calc_bulk_density(mass,volume): &quot;Return dry bulk density = powder mass / powder volume.&quot; return mass / volume . Docstrings are preferred over in-line comments (see below) as the docstrings can be easily accessed using the Python help() function. It is also possible to generate online documentation automatically from docstrings. . In-line comments . # bulk density is the powder mass / powder volume density = mass / volume . Markdown in a Jupyter Notebook . For more extensive discussion you can combine code and text in a single document. See this tutorial for more information about using Markdown in a Jupyter Notebook. . Focus on readability . Your code should be easily readable by others. This is a big topic! The Pep 8 Style Guide for Python code has further guidance, although it is a daunting document. The most important thing is that you are consistent within your own code. . Consistency is key . Code formatting (for example, brackets) and use of whitespace should be consistent. For example, do not mix-and-match whitespace as in the code below: . spam(ham[1], {eggs: 2}) spam( ham[ 1 ], { eggs: 2} ) . You should also avoid mixing data types where possible. For example, using a 2-dimensional Numpy array and a 1-dimensional Numpy array within a simulation would usually be better than using a 2-dimensional Numpy array and a 1-dimensional Python list. . Variable and function names . Use clear, meaningful variable and function names - don’t just use x, p and expect the reader to know what they mean! For example angular_momentum is a better variable name than omega. . Clear code structure . Import all of the libraries used at the top of your code. Also define any constants that will not change during your simulation (for example, the radius of the earth) at the top of your code. . Use Markdown to write section headings in a Jupyter Notebook. You can also use blank lines to split code into logical blocks. Split long lines of your code using a at the end of the line(s). For example: . print(&quot;this is a really really long line of code that I&#39;d like split over two lines&quot;) . Avoid duplication . Duplication of code should be avoided where possible. There are several ways this can be achieved. . Write functions . If you will re-use a block of code multiple times consider encapsulating it in a function. See this tutorial for information about writing functions. . Use external libraries . Use appropriate functions and data-types, including those from external libraries. For example, if you need to perform mathematical operations on an array of values, use Numpy arrays instead of Python lists. . Use control structures when appropriate . Use control structures appropriately. Only use if, while or for loops when necessary. . Think about reproducibility . Writing reproducible code is difficult. In fact, there are many interesting initiatives designed to improve reproducibility in the computational scientists, such as Reprohacks. . One straight-forward thing you can do is print the version number for each package you import using print(packagename.__version__) .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Good_practice.html",
            "relUrl": "/2021/08/02/Good_practice.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post51": {
            "title": "Built-in functions, help and errors",
            "content": ". Questions: . How can I use built-in functions? | How can I find out what they do? | What kind of errors can occur in programs? | . objectives: . Explain the purpose of functions. | Correctly call built-in Python functions. | Correctly nest calls to built-in functions. | Use help to display documentation for built-in functions. | Correctly describe situations in which SyntaxError and NameError occur. | . keypoints: . Use comments to add documentation to programs. | A function may take zero or more arguments. | Commonly-used built-in functions include max, min, and round. | Functions may only work for certain (combinations of) arguments. | Functions may have default values for some arguments. | Use the built-in function help to get help for a function. | The Jupyter Notebook has two ways to get help. | Every function returns something. | Python reports a syntax error when it can&#39;t understand the source of a program. | Python reports a runtime error when something goes wrong while a program is executing. | Fix syntax errors by reading the source code, and runtime errors by tracing the program&#39;s execution. | . . Use comments to add documentation to programs. . adjustment = 0.5 # Neither is this - anything after &#39;#&#39; is ignored. . A function may take zero or more arguments. . We have seen some functions already now let&#39;s take a closer look. | An argument is a value passed into a function. | len takes exactly one. | int, str, and float create a new value from an existing one. | print takes zero or more. | print with no arguments prints a blank line. Must always use parentheses, even if they&#39;re empty, so that Python knows a function is being called. | . | . print(&#39;before&#39;) print() print(&#39;after&#39;) . before after . Commonly-used built-in functions include max, min, and round. . Use max to find the largest value of one or more values. | Use min to find the smallest. | Both work on character strings as well as numbers. &quot;Larger&quot; and &quot;smaller&quot; use (0-9, A-Z, a-z) to compare letters. | . | . print(max(1, 2, 3)) print(min(&#39;a&#39;, &#39;A&#39;, &#39;0&#39;)) . 3 0 . Functions may only work for certain (combinations of) arguments. . max and min must be given at least one argument. &quot;Largest of the empty set&quot; is a meaningless question. | . | And they must be given things that can meaningfully be compared. | . print(max(1, &#39;a&#39;)) . TypeError Traceback (most recent call last) /var/folders/5q/mny3pg2n7h5g21h3v32rfj9wpykqrf/T/ipykernel_11743/2220240766.py in &lt;module&gt; -&gt; 1 print(max(1, &#39;a&#39;)) TypeError: &#39;&gt;&#39; not supported between instances of &#39;str&#39; and &#39;int&#39; . Functions may have default values for some arguments. . round will round off a floating-point number. | By default, rounds to zero decimal places. | . round(3.712) . 4 . We can specify the number of decimal places we want. | . round(3.712, 1) . 3.7 . Use the built-in function help to get help for a function. . Every built-in function has online documentation. | . help(round) . Help on built-in function round in module builtins: round(number, ndigits=None) Round a number to a given precision in decimal digits. The return value is an integer if ndigits is omitted or None. Otherwise the return value has the same type as the number. ndigits may be negative. . Python reports a syntax error when it can&#39;t understand the source of a program. . Won&#39;t even try to run the program if it can&#39;t be parsed. | . name = &#39;Feng . File &#34;/var/folders/5q/mny3pg2n7h5g21h3v32rfj9wpykqrf/T/ipykernel_11743/3103437601.py&#34;, line 2 name = &#39;Feng ^ SyntaxError: EOL while scanning string literal . age = = 52 . File &#34;/var/folders/5q/mny3pg2n7h5g21h3v32rfj9wpykqrf/T/ipykernel_11743/3760570524.py&#34;, line 2 age = = 52 ^ SyntaxError: invalid syntax . We can Look more closely at the error message: | . print(&quot;hello world&quot; . File &#34;/var/folders/5q/mny3pg2n7h5g21h3v32rfj9wpykqrf/T/ipykernel_11743/1028029194.py&#34;, line 1 print(&#34;hello world&#34; ^ SyntaxError: unexpected EOF while parsing . The message indicates a problem on first line of the input (&quot;line 1&quot;). In this case the &quot;ipython-input&quot; section of the file name tells us that we are working with input into IPython, the Python interpreter used by the Jupyter Notebook. | . | The -6- part of the filename indicates that the error occurred in cell 6 of our Notebook. | Next is the problematic line of code, indicating the problem with a ^ pointer. | . Python reports a runtime error when something goes wrong while a program is executing. . age = 53 remaining = 100 - aege # mis-spelled &#39;age&#39; . NameError Traceback (most recent call last) /var/folders/5q/mny3pg2n7h5g21h3v32rfj9wpykqrf/T/ipykernel_11743/4124232921.py in &lt;module&gt; 1 age = 53 -&gt; 2 remaining = 100 - aege # mis-spelled &#39;age&#39; NameError: name &#39;aege&#39; is not defined . Fix syntax errors by reading the source and runtime errors by tracing execution. | . The Jupyter Notebook has two additional ways to get help. . Place the cursor inside the parenthesis of the function, hold down shift, and press tab. | Or type a function name with a question mark after it: e.g. math.sqrt? | These are the same as doing e.g. help(math.sqrt) . Tip: How did we know what functions a module has and how to use them? If you are working in the IPython/Jupyter Notebook, there is an easy way to find out. If you type the name of something followed by a dot, then you can use tab completion (e.g. type math. and then press tab) to see a list of all functions and attributes that you can use. | . Every function returns something. . Every function call produces some result. | If the function doesn&#39;t have a useful result to return, it usually returns the special value None. | . result = print(&#39;example&#39;) print(&#39;result of print is&#39;, result) . . Do the quick-test. . Back to Python part one. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Functions.html",
            "relUrl": "/2021/08/02/Functions.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post52": {
            "title": "Built-in functions, help and errors - quick test",
            "content": "What Happens When . Explain in simple terms the order of operations in the following program: when does the addition happen, when does the subtraction happen, when is each function called, etc. | What is the final value of radiance? | radiance = 1.0 radiance = max(2.1, 2.0 + min(radiance, 1.1 * radiance - 0.5)) . Show answer 1.1 * radiance = 1.1 | 1.1 - 0.5 = 0.6 | min(randiance, 0.6) = 0.6 | 2.0 + 0.6 = 2.6 | max(2.1, 2.6) = 2.6 | | At the end, radiance = 2.6 | Spot the Difference . Predict what each of the print statements in the program below will print. | Does max(len(rich), poor) run or produce an error message? If it runs, does its result make any sense? | easy_string = &quot;abc&quot; print(max(easy_string)) rich = &quot;gold&quot; poor = &quot;tin&quot; print(max(rich, poor)) print(max(len(rich), len(poor))) . Show answer c | tin | 4 . | It throws a TypeError. The command is trying to run max(4, &#39;tin&#39;) and you can’t compare a string and an integer | Why Not? . Why don’t max and min return None when they are given no arguments? . Show answer max and min return TypeErrors in this case because the correct number of parameters was not supplied. If it just returned None, the error would be much harder to trace as it would likely be stored into a variable and used later in the program, which could lead to unintended behaviour. . . See the notebook. . Back to Python basics - part one. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Functions-Qs.html",
            "relUrl": "/2021/08/02/Functions-Qs.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post53": {
            "title": "For loops",
            "content": "Questions: . How can I make a program do many things? | . Objectives: . Explain what for loops are normally used for. | Trace the execution of a simple (unnested) loop and correctly state the values of variables in each iteration. | Write for loops that use the Accumulator pattern to aggregate values. | . Keypoints: . A for loop executes commands once for each value in a collection. | The first line of the for loop must end with a colon, and the body must be indented. | Indentation is always meaningful in Python. | A for loop is made up of a collection, a loop variable, and a body. | Loop variables can be called anything (but it is strongly advised to have a meaningful name to the looping variable). | The body of a loop can contain many statements. | Use range to iterate over a sequence of numbers. | The Accumulator pattern turns many values into one. | . A for loop executes commands once for each value in a collection. . Doing calculations on the values in a list one by one can be very time consuming and lead to repeated code (which should be avoided). A for loop tells Python to execute some statements once for each value in a list, a character string, or some other collection. A for loop can be translated as: &quot;for each thing in this group, do these operations&quot;. . for number in [2, 3, 5]: print(number) . 2 3 5 . This for loop is equivalent to: . print(2) print(3) print(5) . 2 3 5 . The first line of the for loop must end with a colon, and the body must be indented. . The colon at the end of the first line signals the start of a block of statements. Any consistent indentation is legal, but almost everyone uses four spaces. . for number in [2, 3, 5]: print(number) . File &#34;&lt;ipython-input-8-3a0b55365d6d&gt;&#34;, line 2 print(number) ^ IndentationError: expected an indented block . Indentation is always meaningful in Python. . firstName=&quot;Jon&quot; lastName=&quot;Smith&quot; . File &#34;&lt;ipython-input-9-fac7a181dff6&gt;&#34;, line 2 lastName=&#34;Smith&#34; ^ IndentationError: unexpected indent . This error can be fixed by removing the extra spaces at the beginning of the second line. . A for loop is made up of a collection, a loop variable, and a body. . for number in [2, 3, 5]: print(number) . 2 3 5 . The collection, [2, 3, 5], is what the loop is being run on. | The body, print(number), specifies what to do for each value in the collection. | The loop variable, number, is what changes for each iteration of the loop. | . Loop variables can be called anything. . As with all variables, loop variables are: Created on demand. | Meaningless: their names can be anything at all. | . | . for kitten in [2, 3, 5]: print(kitten) . 2 3 5 . The body of a loop can contain many statements. . But no loop should be more than a few lines long as it is hard for human beings to keep larger chunks of code in mind. . primes = [2, 3, 5] for p in primes: squared = p ** 2 cubed = p ** 3 print(p, squared, cubed) . 2 4 8 3 9 27 5 25 125 . Use range to iterate over a sequence of numbers. . The built-in function range produces a sequence of numbers. This is not a list: the numbers are produced on demand to make looping over large ranges more efficient. range(N) is the numbers 0..N-1 . for number in range(0,3): print(number) . 0 1 2 . The Accumulator pattern turns many values into one. . A common pattern in programs is to: . Initialize an accumulator variable to zero, the empty string, or the empty list. | Update the variable with values from a collection. | For example, if we would like to sum the first 10 integers we could write: . total = 0 for number in range(10): total = total + (number + 1) print(total) . 55 . Read total = total + (number + 1) as: . Add 1 to the current value of the loop variable number. | Add that to the current value of the accumulator variable total. | Assign that to total, replacing the current value. | . We have to add number + 1 because range produces 0..9, not 1..10. . . Do the quick-test. . Back to Python part two. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/For-Loops.html",
            "relUrl": "/2021/08/02/For-Loops.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post54": {
            "title": "For loops - quick test",
            "content": "Classifying Errors . Is an indentation error a syntax error or a runtime error? . Show answer An IndentationError is a syntax error. Programs with syntax errors cannot be started. A program with a runtime error will start but an error will be thrown under certain conditions. . Tracing Execution . Create a table showing the numbers of the lines that are executed when this program runs, and the values of the variables after each line is executed. . total = 0 for char in &quot;tin&quot;: total = total + 1 . Show answer Line no Variables . 1 | total = 0 | . 2 | total = 0 char = ‘t’ | . 3 | total = 1 char = ‘t’ | . 2 | total = 1 char = ‘i’ | . 3 | total = 2 char = ‘i’ | . 2 | total = 2 char = ‘n’ | . 3 | total = 3 char = ‘n’ | . Reversing a String . Fill in the blanks in the program below so that it prints “nit” (the reverse of the original character string “tin”). . original = &quot;tin&quot; result = ____ for char in original: result = ____ print(result) . Show answer original = &quot;tin&quot; result = &quot;&quot; for char in original: result = char + result print(result) . Practice Accumulating . Fill in the blanks in each of the programs below to produce the indicated result. . # Total length of the strings in the list: [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;] = 12 total = 0 for word in [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]: ____ = ____ + len(word) print(total) . Show answer total = 0 for word in [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]: total = total + len(word) print(total) . # List of word lengths: [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;] = [3, 5, 4] lengths = ____ for word in [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]: lengths.____(____) print(lengths) . Show answer lengths = [] for word in [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]: lengths.append(len(word)) print(lengths) . # Concatenate all words: [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;] = &quot;redgreenblue&quot; words = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;] result = ____ for ____ in ____: ____ print(result) . Show answer words = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;] result = &quot;&quot; for word in words: result = result + word print(result) . Cumulative Sum . Reorder and properly indent the lines of code below so that they print an array with the cumulative sum of data. The result should be [1, 3, 5, 10]. . cumulative += [sum] for number in data: cumulative = [] sum += number sum = 0 print(cumulative) data = [1,2,2,5] . Show answer sum = 0 data = [1,2,2,5] cumulative = [] for number in data: sum += number cumulative.append(sum) print(cumulative) . Identifying Variable Name Errors . Read the code below and try to identify what the errors are without running it. | Run the code and read the error message. What type of NameError do you think this is? Is it a string with no quotes, a misspelled variable, or a variable that should have been defined but was not? | Fix the error. | Repeat steps 2 and 3, until you have fixed all the errors. | for number in range(10): # use a if the number is a multiple of 3, otherwise use b if (Number % 3) == 0: message = message + a else: message = message + &quot;b&quot; print(message) . Show answer message = &quot;&quot; for number in range(10): # use a if the number is a multiple of 3, otherwise use b if (number % 3) == 0: message = message + &quot;a&quot; else: message = message + &quot;b&quot; print(message) . Identifying Item Errors . Read the code below and try to identify what the errors are without running it. | Run the code, and read the error message. What type of error is it? | Fix the error. | seasons = [&#39;Spring&#39;, &#39;Summer&#39;, &#39;Fall&#39;, &#39;Winter&#39;] print(&#39;My favorite season is &#39;, seasons[4]) . Show answer seasons = [&#39;Spring&#39;, &#39;Summer&#39;, &#39;Fall&#39;, &#39;Winter&#39;] print(&#39;My favorite season is &#39;, seasons[3]) . . See the notebook. . Back to Python part two. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/For-Loops-Qs.html",
            "relUrl": "/2021/08/02/For-Loops-Qs.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post55": {
            "title": "Laplace's equation for electrostatics",
            "content": ". Questions: . How do I use the relaxation method to solve Laplace&#39;s equation? | . Objectives: . Use the finite difference method to convert Laplace&#39;s equation into a set of linear simultaneous equations | Use the relaxation method to solve Laplace&#39;s equation | . . The method of finite differences is often used to solve partial differential equations . Consider the two-dimensional Laplace equation for the electric potential $ phi$ subject to appropriate boundary conditions: . begin{equation} frac{ partial^2 phi}{ partial x^2} + frac{ partial^2 phi}{ partial y^2} = 0 end{equation}Real physical problems are in three dimensions, but we can more easily visualise the method of finite differences - and the extension to three dimensions is straight forward. . The method of finite differences, which has already been introduced earlier in the course, involves dividing the space into a grid of discrete points $[x,y]$ and calculating numerical derivatives or at each of these points. . . In this case we consider a 2-dimensional sheet with a fixed voltage $V$ at the top side, and all other sides fixed at $0V$. . As a quick recap from what was learnt earlier in the course, we can express the Laplacian in two dimensions using finite differences: . begin{equation} frac{ partial ^2f}{ partial x^2} + frac{ partial ^2f}{ partial y^2} simeq frac{f(x+h,y)+f(x-h,y)+f(x,y+h)+f(x,y-h)-4f(x,y)}{h^2}, end{equation}The expression above is known as a five-point stencil as it uses five points to calculate the Laplacian. . The finite difference method turns our partial differential equation into a set of linear simulatenous equation . Returning to our Laplace equation for for the electric potential $ phi$: . begin{equation} frac{ partial^2 phi}{ partial x^2} + frac{ partial^2 phi}{ partial y^2} = 0 end{equation} . The numerical Laplacian can be substituted into the equation above, giving us a set of $n$ simulatenous equations for the $n$ grid points. . begin{equation} frac{ phi(x+h,y)+ phi(x-h,y)+ phi(x,y+h)+ phi(x,y-h)-4 phi(x,y)}{h^2} = 0, end{equation}where $h$ is the distance between each grid point. . To solve this set of equations we use the relaxation method . To calculate $ phi(x,y)$ we use the relaxation method, also known as the Jacobi method in the context of the Laplace equation. First we re-arrange the equation above: . begin{equation} phi(x,y)= frac{1}{4} left( phi(x+h,y)+ phi(x-h,y)+ phi(x,y+h)+ phi(x,y-h) right). end{equation} Note that because we set the Laplacian equal to zero in Equation 3 (for this particular example), the $h^2$ term has dropped out of the expression - this might not be the case for other examples. . This tells us that $ phi(x,y)$ is the average of the surrounding grid points, which can be represented visually as: . . Second, we fix $ phi(x,y)$ at the boundaries using the boundary conditions. Third, we guess the initial values of the interior $ phi(x,y)$ points - our guesses do not need to be good, and can be zero. . Finally we use Equation 4 to calculate new values of $ phi&#39;(x,y)$ at all points in space. We take these new $ phi&#39;(x,y)$ values and feed them into Equation 4 again to calculate new values. We repeat this iterative process until the $ phi(x,y)$ values converge, and that is our solution. . Convergence can be tested by specifying what the maximum difference should be between iterations. For example, that $ phi&#39;(x,y)- phi(x,y)&lt; 1e-5$ for all grid points. . The relaxation method is limited by the accuracy of the finite difference method . For solving PDEs we use the finite difference method (as part of the relaxation method). | Even if we use a very small target accuracy for convergence of the relaxation method, our accuracy will still be limited by the finite differences. Higher-order finite difference methods (such as the 5-point or 7-point methods) can be used here to improve the overrall accuracy of the calculation. | . The relaxation methods can be applied using the Python skills we have developed . We will now use our Python Skillz to solve Laplace&#39;s equation with the boundary conditions outlined above. Let&#39;s also imagine that the sheet is 1m along each side and that we want a grid spacing of 1cm. First let&#39;s import the libraries we will use: . import numpy as np import matplotlib.pyplot as plt . Now let&#39;s specify our simulation parameters... . grid_width = 101 # number of grid points for width of simulation grid_height = 101 # number of grid points for height of simulation target = 1e-6 # target accuracy to complete convergence . ...and our boundary conditions: . V_top = 1.0 # top wall voltage, in volts V_left = 0.0 # left wall voltage V_right = 0.0 # right wall voltage V_bottom = 0.0 # bottom wall voltage . Next let&#39;s create a NumPy array to hold our $ phi(x,y)$ and $ phi&#39;(x,y)$ values: . phi = np.zeros([grid_height,grid_width], float) phi_prime = np.empty([grid_height,grid_width], float) . Now we apply the boundary conditions to our array: . phi[0,:] = V_top . Now we write a function which uses the finite difference method to calculate an updated $ phi&#39;(x,y)$ . . def finite_difference(phi): for i in range(grid_height): # for each grid point for j in range(grid_width): if i==0 or i==grid_height-1 or j==0 or j==grid_width-1: phi_prime[i,j] = phi[i,j] # if at boundary, keep fixed else: # otherwise apply finite difference phi_prime[i,j] = (phi[i+1,j]+phi[i-1,j]+phi[i,j+1]+phi[i,j-1]) / 4 return phi_prime . Finally let&#39;s use the relaxation method. We repeatedly call the function finite_difference until all values of $ phi(x,y)$ are converged. . delta = 1.0 # create delta. It can take any value larger than the target accuracy while delta &gt; 1e-6: # keep running the following code until delta &lt; 1e-6 phi_prime = finite_difference(phi) # calculate phi_prime delta = np.max(np.abs(phi-phi_prime)) # calculate the maximum difference between phi and phi_prime phi,phi_prime = phi_prime,phi # Swap phi and phi-prime, ready for the next iteration . We can visualise our result using the function matplotlib.pyplot.imshow which displays our data as an image: . plt.imshow(phi_prime) . &lt;matplotlib.image.AxesImage at 0x7ffd66d69e10&gt; . This result makes sense: there is a region of high electric potential around the top side of the sheet, where the voltage is fixed at 1V, and regions of low potential around the other three walls. If we would like a colour bar to indicate the $ phi(x,y)$ values across the image then we can use the function matplotlib.pyplot.contourf to produce a filled contour plot. Note that this function flips our image (plotting the values held in the array from left to right, top to bottom) so we use numpy.flip to achieve the expected result. . plt.contourf(np.flip(phi_prime),levels=np.linspace(0,1,101)) plt.colorbar().set_label(&quot;Electric potential&quot;) . . Keypoints: . The finite difference method for numerical derivatives is often used to solve partial differential equations | The finite difference method turns our partial differential equation into a set of linear simulatenous equation | To solve this set of equations we use the relaxation method | The relaxation method is limited by the accuracy of the finite difference method | The relaxation and finite difference methods can be applied using the Python skills we have developed | . . Do the quick-test. . Back to Modelling with Partial Differential Equations. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Finite-Difference.html",
            "relUrl": "/2021/08/02/Finite-Difference.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post56": {
            "title": "Laplace's equation - quick test",
            "content": "Boundary conditions . In the tutorial we implement a finite difference method to solve Laplace’s equation. We use fixed boundary conditions, which are an example of Dirichlet-type boundary conditions. . def finite_difference(phi): for i in range(grid_height): # for each grid point for j in range(grid_width): if i==0 or i==grid_height-1 or j==0 or j==grid_width-1: phi_prime[i,j] = phi[i,j] # if at boundary, keep fixed else: # otherwise apply finite difference phi_prime[i,j] = (phi[i+1,j]+phi[i-1,j]+phi[i,j+1]+phi[i,j-1]) / 4 return phi_prime . Another form of boundary condition is a Periodic Boundary Condition. PBCs are often chosen for approximating a large (infinite) system by using a small part called a unit cell, and are most famously used for modelling periodic crystals in solid state physics. Mathematically, PBCs can be expressed for $f(x,y)$ on a two dimensional $N times N$ grid as: . begin{equation} f[N+1,y] = f[0,y], end{equation} . begin{equation} f[x,N+1] = f[x,0], end{equation} . Write a function which calculates phi_prime using a finite difference method with periodic boundary conditions. . Show answer def finite_difference(phi): for i in range(N): # for each grid point for j in range(N): i1 = i+1 j1 = j+1 i2 = i-1 j2 = j-1 if i == N-1: i1 = 0 if i == 0: i2 == N-1 if j == N-1: j1 = 0 if j == 0: j2 == N-1 phi_prime[i,j] = (phi[i1,j]+phi[i2,j]+phi[i,j1]+phi[i,j2]) / 4 return phi_prime . . See the notebook. . Back to Modelling with Partial Differential Equations. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Finite-Difference-Qs.html",
            "relUrl": "/2021/08/02/Finite-Difference-Qs.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post57": {
            "title": "Finite Difference Methods",
            "content": ". Questions: . How do I use a finite difference method to calculate derivatives? | . Objectives: . Use the finite difference method to calculate the derivative of an unknown function | . . A numerical derivative can be calculated using the forward, backward or central difference . The standard definition of a derivative is . begin{equation} frac{ mathrm{d} f}{ mathrm{d} x} = lim_{h to0} frac{f(x+h)-f(x)}{h}. end{equation}To calculate the derivative numerically we make $h$ very small and calculate . begin{equation} frac{ mathrm{d} f}{ mathrm{d} x} simeq frac{f(x+h)-f(x)}{h}. end{equation}This is the forward difference because it is measured in the forward direction from $x$. . The backward difference is measured in the backward direction from $x$: . begin{equation} frac{ mathrm{d} f}{ mathrm{d} x} simeq frac{f(x)-f(x-h)}{h}, end{equation}and the central difference uses both the forwards and backwards directions around $x$: . begin{equation} frac{ mathrm{d} f}{ mathrm{d} x} simeq frac{f(x+ frac{h}{h2})-f(x- frac{h}{2})}{h}, end{equation} . Important: The central difference is in general more accurate than the forward or backward differences, but im all cases we need to carefully converge with respect to the step size $h$ . Second-order derivatives, partial derivatives and the Laplacian can be calculated using the same approach . The second derivative is a derivative of a derivative, and so we can calculate it be applying the first derivative formulas twice. The resulting expression (after application of central differences) is: . begin{equation} frac{ mathrm{d} ^2f}{ mathrm{d} x^2} simeq frac{f(x+h)-2f(x)+f(x-h)}{h^2}. end{equation}The extension to partial derivatives is straight-forward: . begin{equation} frac{ partial f}{ partial x} simeq frac{f(x+ frac{h}{2},y)-f(x- frac{h}{2},y)}{h}, end{equation} begin{equation} frac{ partial f}{ partial y} simeq frac{f(x,y+ frac{h}{2})-f(x,y- frac{h}{2})}{h}, end{equation} begin{equation} frac{ partial ^2f}{ partial x^2} simeq frac{f(x+h,y)-2f(x,y)+f(x-h,y)}{h^2}, end{equation} begin{equation} frac{ partial ^2f}{ partial y^2} simeq frac{f(x,y+h)-2f(x,y)+f(x,y-h)}{h^2}. end{equation}By adding the two equations above, the Laplacian in two dimensions is: . begin{equation} frac{ partial ^2f}{ partial x^2} + frac{ partial ^2f}{ partial y^2} simeq frac{f(x+h,y)+f(x-h,y)+f(x,y+h)+f(x,y-h)-4f(x,y)}{h^2}, end{equation}The expression above is known as a five-point stencil as it uses five points to calculate the Laplacian. . . Keypoints: . Finite difference methods are a family of techniques used to calculate derivatives | A numerical derivative can be calculated using the forward, backward or central finite difference | Second-order derivatives, partial derivatives and the Laplacian can also be calculated using finite differences | . . Do the quick-test. . Back to Calculating Derivatives. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Finite-Difference-Method.html",
            "relUrl": "/2021/08/02/Finite-Difference-Method.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post58": {
            "title": "Finite Difference Methods - quick test",
            "content": "Coming soon… .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Finite-Difference-Method-Qs.html",
            "relUrl": "/2021/08/02/Finite-Difference-Method-Qs.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post59": {
            "title": "Evaluating numerical errors and accuracy",
            "content": ". Questions: . Which numerical errors are unavoidable in a Python programme? | How do I choose the optimum step size $h$ when using the finite difference method? | What do the terms first-order accurate and second-order accurate mean? | How can I measure the speed of my code? | . Objectives: . Understand that there are unavoidable rounding errors when working with floats | Write code for testing if two floats are equivalent (to within machine accuracy) | Calculate the optimum step size $h$ for finite difference methods | Measure the length of time a Notebook cell takes to run using the %time magic. | . . Computers have inherent limitations that lead to rounding errors . We have seen how computer programming can be used to model physical systems. However computers have inherent limitations - they cannot store real numbers with an infinite number of decimal places. | In many cases this is not a problem, but it is something to be aware of. For example, take the following piece of code: | . def add_numbers(a,b): return a+b def test_add_numbers(): assert add_numbers(0.1,0.2) == 0.3 . add_numbers is a function for adding two Python objects a and b. | test_add_numbers is a function for testing is the add_numbers function is working as expected (we will see more on testing later in the course). This function will raise an error if $0.1 + 0.2$ does not equal 0.3. | . add_numbers(1,2) . 3 . The add_numbers function works as expected if we pass it two integers. However when we run the test function we raise an assertion error: . test_add_numbers() . AssertionError Traceback (most recent call last) &lt;ipython-input-5-fee3d9bc4a88&gt; in &lt;module&gt; -&gt; 1 test_add_numbers() &lt;ipython-input-3-61c3c4878185&gt; in test_add_numbers() 3 4 def test_add_numbers(): -&gt; 5 assert add_numbers(0.1,0.2) == 0.3 AssertionError: . This rounding error is given because $0.1+0.2$ does not equal 0.3 exactly: . 0.1+0.2 . 0.30000000000000004 . This is because floating point numbers (floats) are represented on the computer to a certain precision. In Python the standard level of precision is 16 significant digits. . . Note: The largest value you can give a floating point variable is about $10^{308}$. The smallest is -$10^{308}$. If you exceed these values (which is unlikely) then the computer will return an Overflow error. In contrast, PYthon can represent integers to any precision - limited only by the memory of the machine. . Do not test for the equality of two floats . As we have seen in the previous example, we should not test for the equality of two floats. Instead we should ask if they are equal up to a given precision: . def add_numbers(a,b): return a+b epsilon = 1e-12 def test_add_numbers(): assert abs(add_numbers(0.1,0.2) - 0.3) &lt; epsilon . test_add_numbers() . Finite difference methods have two sources of error . There are two sources of errors for finite difference methods. The first is the rounding error introduced at the start of this tutorial. The second is from the approximation that the step size $h$ is small but not zero. | One way of improving the finite-$h$ approximation is to decrease the step size in space (use a higher number of points on our real space grid). However when the step size is decreased the programme will run more slowly. | We also need to think about the rounding errors associated with finite differences. Counter-intuitively, these errors can increase as we decrease the step size $h$. | . To demonstrate this, consider the Taylor expansion of $f(x)$ about $x$: . begin{equation} f(x+h) = f(x) + hf&#39;(x) + frac{1}{2}h^2f&#39;&#39;(x) + ldots end{equation}Re-arrange the expression to get the expression for the forward difference method: . begin{equation} f&#39;(x) = frac{f(x+h)}{h} - frac{1}{2}hf&#39;&#39;(x)+ ldots end{equation}A computer can typically store a number $f(x)$ to an accuracy of 16 significant figures, or $Cf(x)$ where $C=10^{-16}$. In the worst case, this makes the error $ epsilon$ on our derivative: . begin{equation} epsilon = frac{2C|f(x)|}{h} + frac{1}{2}h|f&#39;&#39;(x)|. end{equation}We want to find the value of $h$ which minimises this error so we differentiate with respect to $h$ and set the result equal to zero. . begin{equation} - frac{2C|f(x)|}{h^2} + h|f&#39;&#39;(x)| end{equation} begin{equation} h = sqrt{4C lvert frac{f(x)}{f&#39;&#39;(x)} rvert} end{equation}If $f(x)$ and $f&#39;&#39;(x)$ are order 1, then $h$ should be order $ sqrt{C}$, or $10^{-8}$. . Similar reasoning applied to the central difference formula suggests that the optimum step size for this method is $10^{-5}$. . Euler&#39;s method is a first-order method accurate to order $h$. . As we have seen in previous tutorials, numerical methods (such as Euler&#39;s method or the Runge-Kutta method) give approximate solutions. | Euler&#39;s method neglected the term in $h^2$ and higher: begin{equation} x(t+h) = x(t)+hf(x,t)+ mathcal{O}(h^2) end{equation} | This tells us the error introduced on a single step of the method is proportional to $h^2$ - this makes Euler&#39;s method a first-order method, accurate to order $h$. | However the cumulative error over several steps is proportional to $h$ | So to make our error half as large we need to double the number of steps (halve the step size) and double the length of the calculation. | . The second-order Runge-Kutta method is accurate to order $h^2$. . The error term for one step of the Runge-Kutta method is ${O}(h^3)$ - this makes the Runge-Kutta method accurate to order $h^2$ which is why this is called the second-order Runge Kutta method (RK2). | With the RK2 can use a fewer number of steps whilst getting the same accuracy as Euler&#39;s method. | There are higher order Runge-Kutta methods which increase the accuracy further. | . Use the %time magic to measure the length of time a Jupyter Notebook cell takes to run . def sum_integers(max_integer): count = 0 for i in range(max_integer): count += max_integer + 1 return count . %time sum = sum_integers(1000000) . CPU times: user 100 ms, sys: 3.79 ms, total: 104 ms Wall time: 110 ms . . Keypoints: . Computers have inherent limitations that lead to rounding errors | Do not test for the equality of two floats | Finite difference methods have two sources of error | The relaxation method for PDEs is limited by the accuracy of the finite difference method. | Euler&#39;s method is a first-order method accurate to order $h$. | The second-order Runge-Kutta method is accurate to order $h^2$. | . . Do the quick-test. . Back to Modelling with Partial Differential Equations. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Evaluating-Accuracy.html",
            "relUrl": "/2021/08/02/Evaluating-Accuracy.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post60": {
            "title": "Evaluating the accuracy of numerical methods - quick test",
            "content": "There are no quick test questions for this tutorial (yet!) - can you think of one? Suggest it here. . . See the notebook. . Back to Modelling with Partial Differential Equations. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Evaluating-Accuracy-Qs.html",
            "relUrl": "/2021/08/02/Evaluating-Accuracy-Qs.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post61": {
            "title": "Euler's method",
            "content": ". Questions: . How do I use Euler&#39;s method to solve a first-order ODE? | What does the term first-order accurate mean? | . . . Objectives: . Use Euler&#39;s method, implemented in Python, to solve a first-order ODE | Understand that this method is approximate and the significance of step size $h$ | Compare results at different levels of approximation using the matplotlib library. | . . There are a variety of ways to solve an ODE . In the previous lesson we considered nuclear decay: . begin{equation} frac{ mathrm{d} N}{ mathrm{d} t} = - lambda N end{equation}This is one of the simplest examples of am ODE - a first-order, linear, separable differential equation with one dependent variable. We saw that we could model the number of atoms $N$ by finding an analytic solution through integration: . begin{equation} N = N_0 e^{- lambda t} end{equation}However there is more than one way to crack an egg (or solve a differential equation). We could have, instead, used an approximate, numerical method. One such method - Euler&#39;s method - is this subject of this lesson. . A function can be approximated using a Taylor expansion . The Taylor series is a polynomial expansion of a function about a point. For example, the image below shows $ mathrm{sin}(x)$ and its Taylor approximation by polynomials of degree 1, 3, 5, 7, 9, 11, and 13 at $x = 0$. . Credit: Image By IkamusumeFan - CC BY-SA 3.0, https://commons.wikimedia.org/w/index.php?curid=27865201 The Taylor series of $f(x)$ evaluated at point $a$ can be expressed as: . begin{equation} f(x) = f(a) + frac{ mathrm{d} f}{ mathrm{d} x}(x-a) + frac{1}{2!} frac{ mathrm{d} ^2f}{ mathrm{d} x^2}(x-a)^2 + frac{1}{3!} frac{ mathrm{d} ^3f}{ mathrm{d} x^3}(x-a)^3 end{equation} Returning to our example of nuclear decay, we can use a Taylor expansion to write the value of $N$ a short interval $h$ later: . begin{equation} N(t+h) = N(t) + h frac{ mathrm{d}N}{ mathrm{d}t} + frac{1}{2}h^2 frac{ mathrm{d}^2N}{ mathrm{d}t^2} + ldots end{equation} begin{equation} N(t+h) = N(t) + hf(N,t) + mathcal{O}(h^2) end{equation} If you want to know more about Taylor expansion, there is aan excellent video explanation from user 3blue1brown on Youtube: . If the step size $h$ is small then higher order terms can be neglected . If $h$ is small and $h^2$ is very small we can neglect the terms in $h^2$ and higher and we get: . begin{equation} N(t+h) = N(t) + hf(N,t). end{equation} Euler&#39;s method can be used to approximate the solution of differential equations . We can keep applying the equation above so that we calculate $N(t)$ at a succession of equally spaced points for as long as we want. If $h$ is small enough we can get a good approximation to the solution of the equation. This method for solving differential equations is called Euler&#39;s method, after Leonhard Euler, its inventor. . . . Note: Although we are neglecting terms $h^2$ and higher, Euler&#8217;s method typically has an error linear in $h$ as the error accumulates over repeated steps. This means that if we want to double the accuracy of our calculation we need to double the number of steps, and double the calcuation time. . . Note: So far we have looked at an example where the input (or independent variable) is time. This isn&#8217;t always the case - but it is the most common case in physics, as we are often interested in how things evolve with time. . Euler&#39;s method can be applied using the Python skills we have developed . Let&#39;s use Euler&#39;s method to solve the differential equation for nuclear decay. We will model the decay process over a period of 10 seconds, with the decay constant $ lambda=0.1$ and the initial condition $N_0 = 1000$. . begin{equation} frac{ mathrm{d}N}{ mathrm{d} t} = -0.1 N end{equation} First, let&#39;s import the standard scientific libraries we will be using - Numpy and Matplotlib: . import numpy as np import matplotlib.pyplot as plt . Let&#39;s definte the function $f(N,t)$ which describes the rate of decay. In this case, the function depends only on the number of atoms present. . def f(Num_atoms): return -0.1*Num_atoms . Next we&#39;ll list the simulation parameters and initial conditions: start time, end time, number of starting atoms (which is an initial condition), number of time steps and step size (which is calculated using the number of time steps). . a = 0 # start time b = 10 # end time Num_atoms = 1000 # initial condition num_steps = 5 # number of time steps h = (b-a) / num_steps # time step size . We use the Numpy arange function to generate a list of evenly spaced times at which to evaluate the number of atoms. We also create an empty list to hold the values for $N$ that we are yet to calculate. . time_list = np.arange(a,b,h) # create an empty list to hold the calculated N values Num_atoms_list = [] . Finally, we apply Euler&#39;s method using a For loop. Note that the order of operations in the loop body is important. . for time in time_list: Num_atoms_list.append(Num_atoms) Num_atoms += h*f(Num_atoms) . We can easily visualise our results, and compare against the analytical solution, using the matplotlib plotting library . plt.scatter(time_list, Num_atoms_list) plt.xlabel(&quot;time&quot;) plt.ylabel(&quot;Number of atoms&quot;) plt.show() . Using the analytic solution from the previous lesson, we can define a function for calculating the number of atoms $N$ as a function of time (this is the exact solution). . def analytic_solution(time): return 1000*np.exp(-0.1*time) . We can use this to calculate the exact value for $N$ over the full time range. Note that we use a large number of points in time (in this case 1000) to give a nice smooth curve: . num_steps = 1000 h = (b-a) / num_steps time_analytic_list = np.arange(a,b,h) Num_atoms_analytic_list = [] for time in time_analytic_list: Num_atoms_analytic_list.append(analytic_solution(time)) . Finally, we plot the approximate Euler method results against the exact analytical solution: . plt.plot(time_analytic_list,Num_atoms_analytic_list) plt.scatter(time_list, Num_atoms_list) plt.xlabel(&quot;time&quot;) plt.ylabel(&quot;Number of atoms&quot;) . Text(0, 0.5, &#39;Number of atoms&#39;) . We can see that the error is increasing over time. We can calculate the error at $t=8$: . print(&quot;Analytic solution at t=8: &quot;,round(analytic_solution(8))) print(&quot;Numerical solution at t=8: &quot;,round(Num_atoms_list[-1])) print(&quot;Error is: &quot;,round(analytic_solution(8)-Num_atoms_list[-1])) . Analytic solution at t=8: 449 Numerical solution at t=8: 410 Error is: 40 . Euler&#39;s method is a first-order method accurate to order $h$. . Numerical methods give approximate solutions. | Euler&#39;s method neglects the term in $h^2$ and higher: begin{equation} x(t+h) = x(t)+hf(x,t)+ mathcal{O}(h^2) end{equation} | This tells us the error introduced on a single step of the method is proportional to $h^2$ - this makes Euler&#39;s method a first-order method, accurate to order $h$. | However the cumulative error over several steps is proportional to $h$ | So to make our error half as large we need to double the number of steps (halve the step size) and double the length of the calculation. | . . Keypoints: . There are a variety of ways to solve an ODE | A function can be approximated using a Taylor expansion | If the step size $h$ is small then higher order terms can be neglected | Euler&#39;s method can be used to approximate the solution of differential equations | Euler&#39;s method can be applied using the Python skills we have developed | We can easily visualise our results, and compare against the analytical solution, using the matplotlib plotting library | Euler&#39;s method is a first-order method accurate to order $h$. | . . . Do the quick-test. . Back to Modelling with Ordinary Differential Equations. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Eulers-Method.html",
            "relUrl": "/2021/08/02/Eulers-Method.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post62": {
            "title": "Euler's method - quick test",
            "content": "There are no quick test questions - can you think of a good one? Then suggest it here. . You can practice Euler’s method in the exercises. .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Eulers-Method-Qs.html",
            "relUrl": "/2021/08/02/Eulers-Method-Qs.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post63": {
            "title": "Calculating derivatives - extension",
            "content": "Coming soon…. .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Derivatives_extension.html",
            "relUrl": "/2021/08/02/Derivatives_extension.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post64": {
            "title": "Calculating derivatives - exercises",
            "content": "Coming soon…. .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Derivatives_exercise.html",
            "relUrl": "/2021/08/02/Derivatives_exercise.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post65": {
            "title": "Calculating derivatives",
            "content": "The origin of the notion of derivatives is in the vague feeling of the mobility of things, and of the greater or less speed with which phenomena take place. - Émile Picard . In physics we are often looking at how things change over time or space so, like integrals, the evaluation of derivatives is one of the most important applications of computers in physics - especially when solving partial differential equations (a topic we will cover later in the course). However, unlike integrals, the derivatives of known functions can always be calculated analytically, so there’s generally less need to calculate them numerically. . In this lesson we will learn how to calculate derivatives using finite difference methods, and take a brief look at the related operation of interpolation. There are some significant practical problems with numerical derivatives; at the end of this lesson we will also learn how to evaluate the accuracy and speed that can be achieved when using these various methods. . Before you begin . Check that Python and Jupyter Notebook are installed | Launch a Jupyter notebook | . Please see the Setup page for more details. . Lesson outline . Topic Objective Quick test . Finite difference methods | How do I use a finite difference method to calculate derivatives? | :mag: | . Evaluating numerical errors, accuracy and speed | How accurate are finite difference methods? How can I measure the speed of my Python code? | :paperclip: | . Resources . Lesson exercises | Extension exercise | Presentation | .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Derivatives.html",
            "relUrl": "/2021/08/02/Derivatives.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post66": {
            "title": "Data analysis and visualisation - extension activity",
            "content": "Wave interference . Adapted from Mark Newman’s book “Computational Physics, p. 108 . When we drop a pebble in a pond waves travel out from the spot where it fell. The height of the waves at some time later could be represented by a sine wave, spreading out in a uniform circle. If the the pebble is dropped at $x_1,y_1$ (the centre of the circle) then the distance $r_1$ between a point $x,y$ and the pebble is: . $ r_1 = sqrt((x-x_1)^2+(y-y_1)^2) $ . and the sine wave for the height $h$ is . $ h_1(x,y) = h_0 sin(kr_1), $ . where $h_0$ is the amplitdue of the waves and $k$ is the wavevector, related to the wavelength $ lambda$ by $k= frac{2 pi}{ lambda}$. . Task: Write a piece of code to make an image of the wave heights over a 1 metre square region of pond. Suppose the wavelength $ lambda=5 mathrm{cm}$ and the amplitude $h_0=1$. You can choose where the pebble drops within the 1 metre square region. To make the image first create a $500 times500$ array of values representing the height $h_0$. Then use that array to make a density plot using matplotlib.pyplot.imshow. . Now suppose that we drop two pebbles in a pond. We will now have pebble one centred at $x_1,y_1$ (as above) and pebble two at $x_2,y_2$. The distance $r_2$ between a point $x,y$ and pebble two is: . $ r_2 = sqrt((x-x_2)^2+(y-y_2)^2) $ . and the sine wave for the height $h$ is . $ h_2(x,y) = h_0 sin(kr_2). $ . Assuming the waves add linearly (superpose) the total height of the surface at a point $x,y$ is . $ h_{1,2}(x,y) = h_0 sin(kr_1)+h_0 sin(kr_2). $ . Task: Write a piece of code to make an image of the wave heights over a 1 metre square region of pond. Assume again that the wavelength $ lambda=5 mathrm{cm}$ and the amplitude $h_0=1$. You can choose where the pebbles drop but they should be $20 mathrm{cm}$ apart. To make the image first create a $500 times500$ array of values representing the height $h_0$. Then use that array to make a density plot using matplotlib.pyplot.imshow. . . Back to Data analysis and visualisation. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Data_analysis_extension.html",
            "relUrl": "/2021/08/02/Data_analysis_extension.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post67": {
            "title": "Data analysis and visualisation - exercises",
            "content": "Error bars . In [Python part two] you wrote a function to calculate the perimeter of a triangle and the associated standard error. . a) Use this function to plot the perimeter of an equilateral triangle as a function of side length. Use the following side lengths: 3.1cm, 6.7cm, 9.2cm, 12.4cm and assume you use. Think carefully about the type of plot: should it be a scatter plot or line plot? . b) Re-plot this data with attached error bars using the matplotlib.pyplot.errorbar function . Calculating Planck’s constant . Adapted from Mark Newman’s book “Computational Physics, p. 124 . When light is shone on the surface of a metal, the photons in the light can excite (transfer energy to) electrons in the metal and, sometimes, eject them from the surface into the free space above. The energy of the ejected electron can be calculated by measuring the minimum voltage $V$ that stops the electron moving. . We know that the energy of an ejected electron is equal to the energy of the photon that excited it minus the workfunction $ phi$ (which is the energy needed to remove it from the surface) and that the energy of a single photon is $hf$ where $h$ is Planck’s constant and $f$ is the frequency of light. Mathematically this can be expressed as: . eV=hf−ϕeV = hf - phieV=hf−ϕ, . where $e$ is the charge of the electron. . a) Read in the photoelectric measurement data from the file Planck.txt. The first column contains frequencies $f$ is hertz and the second column contains voltages $V$. Use this data to plot $V$ vs $f$. Think about the plot type - does a scatter plot of line plot make most sense? . The least-squares method is very commonly used for fitting a polynomial to a set of data. As it is so prevalent in physics and engineering, you are encouraged to watch this video which give an intuitive and mathematical description of the method. . b) Fit a straight line (polynomial of degree one) to the data using the least-squares method implemented in numpy.polyfit. Overlay this line on your data points. . c) Using the gradient of the fitted line calculate a value for Planck’s constant. Compare this to values you can find online. . Line fitting . In the code below we calculate the velocity of a ball between times 0 and 10 and store it as a numpy array . import numpy g = 9.81 velocity_list = numpy.zeros(50) v_0 = 0 for index,time in enumerate(numpy.linspace(0,10,50)): velocity_list[index] = v_0 + g*time . We can fit a polynomial to this data using the numpy.polyfit function. In this case, we know from looking at the equation that is is a first order polynomial (straight line). . fit = numpy.polyfit(numpy.linspace(0,10,50), velocity_list, 1) print(fit) . What is the gradient and intercept of the straight line fit? Does this make physical sense? Make a scatter plot of velocity vs time. Label the x-axis and y-axis (with units) and give the plot a title. . Show answer The gradient is equal to the acceleration of the ball which is given by the gravitational constant $g$. The intercept is the starting velocity of the ball, which in this example is zero. . import matplotlib.pyplot as plt plt.scatter(numpy.linspace(0,10,50),velocity_list) plt.xlabel(&quot;Time (s)&quot;) plt.ylabel(&quot;Velocity (m/s)&quot;) plt.title(&quot;Velocity of an object accelerated by gravity&quot;) . Use the polyval function to generate and plot velocities over the timeframe 30 to 100 seconds. . Show answer import matplotlib.pyplot as plt time_range = numpy.linspace(30,100,70) plt.plot(time_range,np.polyval(fit,time_range)) plt.xlabel(&quot;Time (s)&quot;) plt.ylabel(&quot;Velocity (m/s)&quot;) plt.title(&quot;Velocity of an object accelerated by gravity&quot;) . Error bars and exponential growth . This question is partly modelled on the a blog post. There is also a nice 3Blue1Brown video on exponential growth in the context of Covid. . We have the following (hypothetical) data for the growth in Covid cases at a university over a two-week period . import numpy as np day = np.arange(0,14) case_numbers = np.array([2,3,4,8,15,32,65,128,253,512,1025,2049,4090,8191,16387]) . Assuming that the growth is exponential, fit a straight line to the log of the case number data and predict the exponential growth factor. . Show answer From scanning the blog post we can see that the growth factor is the base of the exponential. Assuming the growth is exponential, to generate a straight-(ish) line we first need to take a logarithm of the case values data. We can then fit a straight line to this to calculate the logarithm of the growth factor. . log_growth_factor, log_starting_case_number = np.polyfit(day,np.log(case_numbers),1) growth_factor = np.exp(log_growth_factor) . From inspecting the data, does the calculated growth factor make sense? . Show answer The data roughly doubles each day. The calculated growth factor is 1.94, which is reassuringly close to 2. . . Back to Data analysis and visualisation. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Data_analysis_exercises.html",
            "relUrl": "/2021/08/02/Data_analysis_exercises.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post68": {
            "title": "Data analysis and visualisation",
            "content": "In this lesson we focus on one extended example: parsing, analysing and plotting UV-Vis data. . Before you begin . Download the UV-Vis data into a data sub-directory: UVVis-01.csv | Check that Python and Jupyter Notebook are installed | Launch a Jupyter notebook | . Please see the Setup page for more details. . During the first tutorial you will generate a file called UVVis-01-cleaned.csv. It is also available for download here. . Lesson outline . Topic Objective Quick test . Reading Data with Pandas | How can I import and clean my data? | :mag: | . Analysing Data with NumPy | How can I analyse my data? | :flashlight: | . Visualising Data with Matplotlib | How can I plot my data? | :paperclip: | . Resources . Lesson exercises | Extension exercise | Presentation | .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Data_analysis.html",
            "relUrl": "/2021/08/02/Data_analysis.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post69": {
            "title": "Data types and type conversion",
            "content": ". Questions: . What kinds of data do programs store? | How can I convert one type to another? | . Objectives: . Explain key differences between integers and floating point numbers. | Explain key differences between numbers and character strings. | Use built-in functions to convert between integers, floating point numbers, and strings. | . Keypoints: . Every value has a type. | Use the built-in function type to find the type of a value. | Types control what operations can be done on values. | Strings can be added and multiplied. | Use an index to get a single character from a string. | Use a slice to get a substring. | Use the built-in function len to find the length of a string. | Convert numbers to strings or vice versa when operating on them. | You can mix integers and floats freely in operations. | Variables only change value when something is assigned to them. | . . Every value has a type. . Every value in a program has a specific type. | Integer (int): represents positive or negative whole numbers like 3 or -512. | Floating point number (float): represents real numbers like 3.14159 or -2.5. | Character string (usually called &quot;string&quot;, str): text. Written in either single quotes or double quotes (as long as they match). | The quote marks aren&#39;t printed when the string is displayed. | . | . Use the built-in function type to find the type of a value. . Use the built-in function type to find out what type a value has. | Works on variables as well. But remember: the value has the type the variable is just a label. | . | . print(type(52)) . &lt;class &#39;int&#39;&gt; . fitness = &#39;average&#39; print(type(fitness)) . &lt;class &#39;str&#39;&gt; . Types control what operations (or methods) can be performed on a given value. . A value&#39;s type determines what the program can do to it. For example, you can subtract two integers but not two strings. | . print(5 - 3) . 2 . print(&#39;hello&#39; - &#39;h&#39;) . TypeError Traceback (most recent call last) /var/folders/5q/mny3pg2n7h5g21h3v32rfj9wpykqrf/T/ipykernel_11287/13340790.py in &lt;module&gt; -&gt; 1 print(&#39;hello&#39; - &#39;h&#39;) TypeError: unsupported operand type(s) for -: &#39;str&#39; and &#39;str&#39; . You can use the &quot;+&quot; and &quot;*&quot; operators on strings. . &quot;Adding&quot; character strings concatenates them. | . full_name = &#39;Ahmed&#39; + &#39; &#39; + &#39;Walsh&#39; print(full_name) . Ahmed Walsh . Multiplying a character string by an integer N creates a new string that consists of that character string repeated N times. | . separator = &#39;=&#39; * 10 print(separator) . ========== . You can index to get a single character from a string. . The characters (individual letters, numbers, and so on) in a string are ordered. For example, the string &#39;AB&#39; is not the same as &#39;BA&#39;. Because of this ordering, we can treat the string as a list of characters. | Each position in the string (first, second, etc.) is given a number. This number is called an index or sometimes a subscript. | Indices are numbered from 0. | Use the position&#39;s index in square brackets to get the character at that position. | . atom_name = &#39;helium&#39; print(atom_name[0]) . h . Use a slice to get a substring. . A slice is a part of a string | We take a slice by using [start:stop], where start is replaced with the index of the first element we want and stop is replaced with the index of the element just after the last element we want. | Mathematically, you might say that a slice selects [start:stop). | The difference between stop and start is the slice&#39;s length. | Taking a slice does not change the contents of the original string. Instead, the slice is a copy of part of the original string. | You can slice any list-like thing and we will come back to slicing several times in this course | . atom_name = &#39;sodium&#39; print(atom_name[4:6]) . um . Use the built-in function len to find the length of a string. . print(len(&#39;helium&#39;)) . 6 . Nested functions are evaluated from the inside out, just like in mathematics. | len is a built-in function because it is always available - you do not need to import a particular library to access it | Numbers do not have a length | . print(len(52)) . TypeError Traceback (most recent call last) /var/folders/5q/mny3pg2n7h5g21h3v32rfj9wpykqrf/T/ipykernel_11287/2246900780.py in &lt;module&gt; -&gt; 1 print(len(52)) TypeError: object of type &#39;int&#39; has no len() . Convert numbers to strings or vice versa when operating on them. . You cannot add numbers and strings. | . print(1 + &#39;2&#39;) . TypeError Traceback (most recent call last) /var/folders/5q/mny3pg2n7h5g21h3v32rfj9wpykqrf/T/ipykernel_11287/3905401405.py in &lt;module&gt; -&gt; 1 print(1 + &#39;2&#39;) TypeError: unsupported operand type(s) for +: &#39;int&#39; and &#39;str&#39; . This is not allowed because it&#39;s ambiguous: should 1 + &#39;2&#39; be 3 or &#39;12&#39;? | Some types can be converted to other types by using the type name as a function. | . print(1 + int(&#39;2&#39;)) print(str(1) + &#39;2&#39;) . 3 12 . You can mix integers and floats freely in operations. . Integers and floating-point numbers can be mixed in arithmetic. | Python 3 automatically converts integers to floats as needed. | . print(&#39;half is&#39;, 1 / 2.0) print(&#39;three squared is&#39;, 3.0 ** 2) . half is 0.5 three squared is 9.0 . Variables only change value when something is assigned to them. . If we make one cell in a spreadsheet depend on another, and update the latter, the former updates automatically. | This does not happen in programming languages. | . first = 1 second = 5 * first first = 2 print(&#39;first is&#39;, first, &#39;and second is&#39;, second) . first is 2 and second is 5 . The computer reads the value of first when doing the multiplication, creates a new value, and assigns it to second. | The value of second is not updated when we re-assign the value of first. | . . Tip: By now we have seen plenty of Error messages. Don&#8217;t be afraid of Error messages - they won&#8217;t break the computer! In the next lesson we will learn how to use these messages to fix our code more efficiently. . . Do the quick-test. . Back to Python part one. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Data-Types.html",
            "relUrl": "/2021/08/02/Data-Types.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post70": {
            "title": "Data types and type conversion - quick test",
            "content": "Slicing . If you assign a = 123, what happens if you try to get the second digit of a via a[1]? . Show answer Numbers are not stored in the written representation, so they can’t be treated like strings. . a = 123 print(a[1]) . TypeError: &#39;int&#39; object is not subscriptable . More slicing . What does the following program print? . atom_name = &#39;carbon&#39; print(&#39;atom_name[1:3] is:&#39;, atom_name[1:3]) . Show answer atom_name[1:3] is: ar . Even more slicing . Open a Notebook to help answer the following questions: . What does thing[low:] (without a value after the colon) do? | What does thing[:high] (without a value before the colon) do? | What does thing[:] (just a colon) do? | What does thing[-2] do? | Show answer Slices from low to the end (inclusive) | Slices from the start to high (exclusive) | Slices from the start to the end | Selects the second last element | Decimals . What type of value is 3.4? How can you find out? . Show answer It is a floating-point number (often abbreviated “float”). . print(type(3.4)) . &lt;class &#39;float&#39;&gt; . Choose a Type . What type of value (integer, floating point number, or character string) would you use to represent each of the following? . Number of days since the start of the year. | Time elapsed from the start of the year until now in days. | Serial number of a piece of lab equipment. | A lab specimen’s age | Current population of a city. | Average population of a city over time. | Show answer The answers to the questions are: . Integer, since the number of days would lie between 1 and 365. | Floating point, since fractional days are required | Character string if serial number contains letters and numbers, otherwise integer if the serial number consists only of numerals | This will vary! How do you define a specimen’s age? whole days since collection (integer)? date and time (string)? | Choose floating point to represent population as large aggreates (eg millions), or integer to represent population in units of individuals. | Floating point number, since an average is likely to have a fractional part. | Division Types . In Python 3, the // operator performs integer (whole-number) floor division, the / operator performs floating-point division, and the ‘%’ (or modulo) operator calculates and returns the remainder from integer division: . print(&#39;5 // 3:&#39;, 5//3) print(&#39;5 / 3:&#39;, 5/3) print(&#39;5 % 3:&#39;, 5%3) . 5 // 3: 1 5 / 3: 1.6666666666666667 5 % 3: 2 . However in Python 2 (and other languages), the / operator between two integer types perform a floor (//) division. To perform a float division, we have to convert one of the integers to float. . print(&#39;5 // 3:&#39;, 1) print(&#39;5 / 3:&#39;, 1 ) print(&#39;5 / float(3):&#39;, 1.6666667 ) print(&#39;float(5) / 3:&#39;, 1.6666667 ) print(&#39;float(5 / 3):&#39;, 1.0 ) print(&#39;5 % 3:&#39;, 2) . If num_subjects is the number of subjects taking part in a study, and num_per_survey is the number that can take part in a single survey, write an expression that calculates the number of surveys needed to reach everyone once. . Show answer We want the minimum number of surveys that reaches everyone once, which is the rounded up value of num_subjects / num_per_survey. This is equivalent to performing an integer division with // and adding 1. . num_subjects = 600 num_per_survey = 42 num_surveys = num_subjects // num_per_survey + 1 print(num_subjects, &#39;subjects,&#39;, num_per_survey, &#39;per survey:&#39;, num_surveys) . 600 subjects, 42 per survey: 15 . Arithmetic with Different Types . Which of the following will print 2.0? Note: there may be more than one right answer. . first = 1.0 second = &quot;1&quot; third = &quot;1.1&quot; . first + float(second) | float(second) + float(third) | first + int(third) | first + int(float(third)) | int(first) + int(float(third)) | 2.0 * second | Show answer Answer: 1 and 4 . Complex Numbers . Python provides complex numbers, which are written as 1.0+2.0j. If val is an imaginary number, its real and imaginary parts can be accessed using dot notation as val.real and val.imag. . Why do you think Python uses j instead of i for the imaginary part? | What do you expect 1+2j + 3 to produce? | What do you expect ‘4j’ to be? What about 4 j or `4 + j’? &gt; | Show answer Standard mathematics treatments typically use i to denote an imaginary number. However, from media reports it was an early convention established from electrical engineering that now presents a technically expensive area to change. Stack Overflow provides additional explanation and discussion | 4+2j | 4j, syntax error, depends on the value of j | . See the notebook. . Back to Python basics - part one. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Data-Types-Qs.html",
            "relUrl": "/2021/08/02/Data-Types-Qs.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post71": {
            "title": "Conditionals",
            "content": "Questions: . How can programs do different things for different data? | . Objectives: . Correctly write programs that use if and else statements and simple Boolean expressions (without logical operators). | Trace the execution of unnested conditionals and conditionals inside loops. | . Keypoints: . Use if statements to control whether or not a block of code is executed. | Conditionals are often used inside loops. | Use else to execute a block of code when an if condition is not true. | Use elif to specify additional tests. | Conditions are tested once, in order. | Compound Relations Using and, or, and Parentheses. | . Use if statements to control whether or not a block of code is executed. . An if statement (more properly called a conditional statement) controls whether some block of code is executed or not. . The if statement structure is similar to a for statement: . First line opens with if and ends with a colon | Body containing one or more statements is indented (usually by 4 spaces) | . mass = 3.54 if mass &gt; 3.0: print(mass, &#39;is large&#39;) mass = 2.07 if mass &gt; 3.0: print (mass, &#39;is large&#39;) . 3.54 is large . Conditionals are often used inside loops. . There is not much point using a conditional when we know the value (as above). But conditionals can be useful when we have a collection to process. . masses = [3.54, 2.07, 9.22, 1.86, 1.71] for m in masses: if m &gt; 3.0: print(m, &#39;is large&#39;) . 3.54 is large 9.22 is large . . An else can be used following an if. This allows us to specify an alternative to execute when the if branch isn&#39;t taken. . masses = [3.54, 2.07, 9.22, 1.86, 1.71] for m in masses: if m &gt; 3.0: print(m, &#39;is large&#39;) else: print(m, &#39;is small&#39;) . 3.54 is large 2.07 is small 9.22 is large 1.86 is small 1.71 is small . Use elif to specify additional tests. . We may want to provide several alternative choices, each with its own test. We can use elif (short for &quot;else if&quot;) and a condition to specify these. An elif must always associated with an if, and it must come before the else (which is the &quot;catch all&quot;). . masses = [3.54, 2.07, 9.22, 1.86, 1.71] for m in masses: if m &gt; 9.0: print(m, &#39;is HUGE&#39;) elif m &gt; 3.0: print(m, &#39;is large&#39;) else: print(m, &#39;is small&#39;) . 3.54 is large 2.07 is small 9.22 is HUGE 1.86 is small 1.71 is small . Conditions are tested once, in order. . Python steps through the branches of the conditional in order, testing each in turn - so the ordering matters. Python does not automatically go back and re-evaluate if values change. . grade = 85 if grade &gt;= 70: print(&#39;grade is C&#39;) elif grade &gt;= 80: print(&#39;grade is B&#39;) elif grade &gt;= 90: print(&#39;grade is A&#39;) . grade is C . velocity = 10.0 if velocity &gt; 20.0: print(&#39;moving too fast&#39;) else: print(&#39;adjusting velocity&#39;) velocity = 50.0 . adjusting velocity . We can use conditionals in a loop to &quot;evolve&quot; the values of variables. . velocity = 10.0 for i in range(5): # execute the loop 5 times print(i, &#39;:&#39;, velocity) if velocity &gt; 20.0: print(&#39;moving too fast&#39;) velocity = velocity - 5.0 else: print(&#39;moving too slow&#39;) velocity = velocity + 10.0 print(&#39;final velocity:&#39;, velocity) . 0 : 10.0 moving too slow 1 : 20.0 moving too slow 2 : 30.0 moving too fast 3 : 25.0 moving too fast 4 : 20.0 moving too slow final velocity: 30.0 . The program must have a print statement outside the body of the loop to show the final value of velocity, since its value is updated by the last iteration of the loop. . Compound Relations Using and, or, and Parentheses . Often, you want some combination of things to be true. You can combine relations within a conditional using and and or. Continuing the example above, suppose you have . mass = [ 3.54, 2.07, 9.22, 1.86, 1.71] velocity = [10.00, 20.00, 30.00, 25.00, 20.00] i = 0 for i in range(5): if mass[i] &gt; 5 and velocity[i] &gt; 20: print(&quot;Fast heavy object. Duck!&quot;) elif mass[i] &gt; 2 and mass[i] &lt;= 5 and velocity[i] &lt;= 20: print(&quot;Normal traffic&quot;) elif mass[i] &lt;= 2 and velocity[i] &lt;= 20: print(&quot;Slow light object. Ignore it&quot;) else: print(&quot;Whoa! Something is up with the data. Check it&quot;) . Normal traffic Normal traffic Fast heavy object. Duck! Whoa! Something is up with the data. Check it Slow light object. Ignore it . Just like with arithmetic, you can and should use parentheses whenever there is possible ambiguity. A good general rule is to always use parentheses when mixing and and or in the same condition. That is, instead of: . if mass[i] &lt;= 2 or mass[i] &gt;= 5 and velocity[i] &gt; 20: . write one of these: . if (mass[i] &lt;= 2 or mass[i] &gt;= 5) and velocity[i] &gt; 20: . if mass[i] &lt;= 2 or (mass[i] &gt;= 5 and velocity[i] &gt; 20): . so it is perfectly clear to a reader (and to Python) what you really mean. . . Do the quick-test. . Back to Python part two. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Conditionals.html",
            "relUrl": "/2021/08/02/Conditionals.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post72": {
            "title": "Conditionals - quick test",
            "content": "Tracing Execution . What does this program print? . pressure = 71.9 if pressure 50.0: pressure = 25.0 elif pressure &lt;= 50.0: pressure = 0.0 print(pressure) . Show answer 25.0 . Trimming Values . Fill in the blanks so that this program creates a new list containing zeroes where the original list’s values were negative and ones where the original list’s values were positive. . original = [-1.5, 0.2, 0.4, 0.0, -1.3, 0.4] result = ____ for value in original: if ____: result.append(0) else: ____ print(result) . [0, 1, 1, 1, 0, 1] . Show answer original = [-1.5, 0.2, 0.4, 0.0, -1.3, 0.4] result = [] for value in original: if value&lt;0.0: result.append(0) else: result.append(1) print(result) . Initializing . Modify this program so that it finds the largest and smallest values in the list no matter what the range of values originally is. . values = [...some test data...] smallest, largest = None, None for v in values: if ____: smallest, largest = v, v ____: smallest = min(____, v) largest = max(____, v) print(smallest, largest) . What are the advantages and disadvantages of using this method to find the range of the data? . Show answer values = [-2,1,65,78,-54,-24,100] smallest, largest = None, None for v in values: if smallest==None and largest==None: smallest, largest = v, v else: smallest = min(smallest, v) largest = max(largest, v) print(smallest, largest) . . See the notebook. . Back to Python part two. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Conditionals-Qs.html",
            "relUrl": "/2021/08/02/Conditionals-Qs.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post73": {
            "title": "Evaluating numerical errors, accuracy and speed",
            "content": ". Questions: . Which numerical errors are unavoidable in a Python programme? | How do I choose the optimum step size $h$ when using the finite difference method? | How can I measure the speed of my code? | . Objectives: . Understand that there are unavoidable rounding errors when working with floats | Write code for testing if two floats are equivalent (to within machine accuracy) | Calculate the optimum step size $h$ for finite difference methods | Measure the length of time a Notebook cell takes to run using the %time magic. | . . Computers have inherent limitations that lead to rounding errors . We have seen how computer programming can be used to model physical systems. However computers have inherent limitations - they cannot store real numbers with an infinite number of decimal places. | In many cases this is not a problem, but it is something to be aware of. For example, take the following piece of code: | . def add_numbers(a,b): return a+b def test_add_numbers(): assert add_numbers(0.1,0.2) == 0.3 . add_numbers is a function for adding two Python objects a and b. | test_add_numbers is a function for testing is the add_numbers function is working as expected (we will see more on testing later in the course). This function will raise an error if $0.1 + 0.2$ does not equal 0.3. | . add_numbers(1,2) . 3 . The add_numbers function works as expected if we pass it two integers. However when we run the test function we raise an assertion error: . test_add_numbers() . AssertionError Traceback (most recent call last) &lt;ipython-input-3-fee3d9bc4a88&gt; in &lt;module&gt; -&gt; 1 test_add_numbers() &lt;ipython-input-1-61c3c4878185&gt; in test_add_numbers() 3 4 def test_add_numbers(): -&gt; 5 assert add_numbers(0.1,0.2) == 0.3 AssertionError: . This rounding error is given because $0.1+0.2$ does not equal 0.3 exactly: . 0.1+0.2 . This is because floating point numbers (floats) are represented on the computer to a certain precision. In Python the standard level of precision is 16 significant digits. . . Note: The largest value you can give a floating point variable is about $10^{308}$. The smallest is -$10^{308}$. If you exceed these values (which is unlikely) then the computer will return an Overflow error. In contrast, PYthon can represent integers to any precision - limited only by the memory of the machine. . Do not test for the equality of two floats . As we have seen in the previous example, we should not test for the equality of two floats. Instead we should ask if they are equal up to a given precision: . def add_numbers(a,b): return a+b epsilon = 1e-12 def test_add_numbers(): assert abs(add_numbers(0.1,0.2) - 0.3) &lt; epsilon . test_add_numbers() . Finite difference methods have two sources of error . There are two sources of errors for finite difference methods. The first is the rounding error introduced at the start of this tutorial. The second is from the approximation that the step size $h$ is small but not zero. | One way of improving the finite-$h$ approximation is to decrease the step size in space (use a higher number of points on our real space grid). However when the step size is decreased the programme will run more slowly. | We also need to think about the rounding errors associated with finite differences. Counter-intuitively, these errors can increase as we decrease the step size $h$. | . To demonstrate this, consider the Taylor expansion of $f(x)$ about $x$: . begin{equation} f(x+h) = f(x) + hf&#39;(x) + frac{1}{2}h^2f&#39;&#39;(x) + ldots end{equation}Re-arrange the expression to get the expression for the forward difference method: . begin{equation} f&#39;(x) = frac{f(x+h)}{h} - frac{1}{2}hf&#39;&#39;(x)+ ldots end{equation}A computer can typically store a number $f(x)$ to an accuracy of 16 significant figures, or $Cf(x)$ where $C=10^{-16}$. In the worst case, this makes the error $ epsilon$ on our derivative: . begin{equation} epsilon = frac{2C|f(x)|}{h} + frac{1}{2}h|f&#39;&#39;(x)|. end{equation}We want to find the value of $h$ which minimises this error so we differentiate with respect to $h$ and set the result equal to zero. . begin{equation} - frac{2C|f(x)|}{h^2} + h|f&#39;&#39;(x)| end{equation} begin{equation} h = sqrt{4C lvert frac{f(x)}{f&#39;&#39;(x)} rvert} end{equation}If $f(x)$ and $f&#39;&#39;(x)$ are order 1, then $h$ should be order $ sqrt{C}$, or $10^{-8}$. . Similar reasoning applied to the central difference formula suggests that the optimum step size for this method is $10^{-5}$. . Use the %time magic to measure the length of time a Jupyter Notebook cell takes to run . It is often possible to use a range of numerical methods to achieve the same level of accuracy. In this case, we may want to consider code speed - which method will run the fastest? This is a particularly important question when writing code that is computationally intensive. To measure the length of time it takes for a Jupyter Notebook cell to run we can use the % time magic . def sum_integers(max_integer): count = 0 for i in range(max_integer): count += max_integer + 1 return count . %time sum = sum_integers(1000000) . . Keypoints: . Computers have inherent limitations that lead to rounding errors | Do not test for the equality of two floats | Finite difference methods have two sources of error | Use the %time magic to measure the length of time a Jupyter Notebook cell takes to run | . . Do the quick-test. . Back to Calculating Derivatives. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Computational-Efficiency.html",
            "relUrl": "/2021/08/02/Computational-Efficiency.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post74": {
            "title": "Evaluating accuracy and speed - quick test",
            "content": "Coming soon… .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Computational-Efficiency-Qs.html",
            "relUrl": "/2021/08/02/Computational-Efficiency-Qs.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post75": {
            "title": "Cleaning data with Pandas",
            "content": "Questions: . How can I import and clean tabular data in Python? | . Objectives: . Read tabular data from a file into a program using pandas. | Remove unwanted data columns | Swap row and column data (transpose) | . Keypoints: . Use the pandas library to work with tabular data in Python | The read_csv function is used to read in .csv data | The read_csv function has several keywords which can simplify data parsing | The dataframe object has a transpose method which will transpose rows and columns | The dataframe object has a to_csv method which will write the dataframe to a file | . Use the pandas library to work with tabular data in Python . import pandas . Importing a library is like getting a piece of lab equipment out of a storage locker and setting it up on the bench. Libraries provide additional functionality to the basic Python package, much like a new piece of equipment adds functionality to a lab space. Just like in the lab, importing too many libraries can sometimes complicate and slow down your programs - so we only import what we need for each program. Once we&#39;ve imported the library, we can ask the library to read our data file for us: . &#160;The read_csv function is used to read in .csv data . pandas.read_csv(&quot;../data/UVVis-01.csv&quot;) . 1500 0.000447125 1500.1 -0.003662238 1500.2 0.002232673 1500.3 0.006085097 1500.4 0.006157242 1500.5 0.012101169 1500.6 0.012067685 1500.7 0.012077134 1500.8 0.003981831 1500.9 0.004210402 . 0 1499 | 0.000656 | 1499 | -0.003497 | 1499 | 0.002297 | 1499 | 0.006312 | 1499 | 0.006317 | 1499 | 0.012318 | 1499 | 0.012270 | 1499 | 0.012277 | 1499 | 0.004222 | 1499 | 0.004369 | . 1 1498 | 0.000864 | 1498 | -0.003343 | 1498 | 0.002475 | 1498 | 0.006419 | 1498 | 0.006479 | 1498 | 0.012420 | 1498 | 0.012395 | 1498 | 0.012400 | 1498 | 0.004328 | 1498 | 0.004388 | . 2 1497 | 0.001073 | 1497 | -0.003682 | 1497 | 0.002223 | 1497 | 0.006161 | 1497 | 0.006196 | 1497 | 0.012130 | 1497 | 0.012126 | 1497 | 0.012140 | 1497 | 0.004078 | 1497 | 0.004146 | . 3 1496 | 0.001281 | 1496 | -0.004053 | 1496 | 0.002251 | 1496 | 0.005537 | 1496 | 0.006273 | 1496 | 0.012027 | 1496 | 0.012201 | 1496 | 0.012225 | 1496 | 0.004151 | 1496 | 0.004150 | . 4 1495 | 0.001489 | 1495 | -0.003248 | 1495 | 0.002604 | 1495 | 0.006554 | 1495 | 0.006091 | 1495 | 0.012618 | 1495 | 0.012195 | 1495 | 0.012387 | 1495 | 0.004266 | 1495 | 0.004467 | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . 1295 204 | 10.000000 | 204 | -0.182566 | 204 | 0.183470 | 204 | -0.398002 | 204 | 0.366597 | 204 | -0.039593 | 204 | 0.138509 | 204 | 0.238752 | 204 | 0.197595 | 204 | 0.108584 | . 1296 203 | 0.614484 | 203 | -0.770955 | 203 | 0.306131 | 203 | 0.651660 | 203 | 0.294760 | 203 | 0.120459 | 203 | 0.110172 | 203 | 0.041537 | 203 | 0.129144 | 203 | -0.008039 | . 1297 202 | 10.000000 | 202 | -0.122420 | 202 | 0.331976 | 202 | 0.048607 | 202 | -0.006551 | 202 | 0.223929 | 202 | 0.245652 | 202 | 0.031154 | 202 | -0.133139 | 202 | 0.089558 | . 1298 201 | 1.296677 | 201 | -0.007074 | 201 | 0.377199 | 201 | 0.894186 | 201 | 0.422728 | 201 | 0.123843 | 201 | 0.134249 | 201 | 0.153293 | 201 | -0.066743 | 201 | 0.084118 | . 1299 200 | 1.666697 | 200 | -0.182474 | 200 | 0.035342 | 200 | 0.568853 | 200 | 0.383505 | 200 | 0.240436 | 200 | 0.016508 | 200 | -0.267420 | 200 | 0.155004 | 200 | 0.143566 | . 1300 rows × 20 columns . pandas.read_csv has one argument: the pathname of the file we want to read. . Since we haven&#39;t told it to do anything else with the function&#39;s output, the notebook displays it. In this case, that output is the data we just loaded. By default, only a few rows and columns are shown (with ... to omit elements when displaying big arrays). To save space, Python displays numbers as 1. instead of 1.0 when there&#39;s nothing interesting after the decimal point. . Note: the pandas read_csv function can also read .txt files . The read_csv function has several keywords which can simplify data parsing . This data we have read in is from a UV-Vis experiment. The rows are the data for each wavelength, and the columns are the individual samples. We will analyse the data using the numpy Python library, but before we do this we must clean up the dataframe. There are three things we would like to do: . Delete the repeated wavelength columns | Set the correct column headings (numpy has automatically set the first row of data as the column headings) | Transpose the data (swap rows and columns; so each row corresponds to a different sample) | . We are able to do all the first two things on this list with the following command: . pandas.read_csv(&quot;../data/UVVis-01.csv&quot;,usecols=[1,3,5,7,9,11,13,15,17,19],header=None) . 1 3 5 7 9 11 13 15 17 19 . 0 0.000447 | -0.003662 | 0.002233 | 0.006085 | 0.006157 | 0.012101 | 0.012068 | 0.012077 | 0.003982 | 0.004210 | . 1 0.000656 | -0.003497 | 0.002297 | 0.006312 | 0.006317 | 0.012318 | 0.012270 | 0.012277 | 0.004222 | 0.004369 | . 2 0.000864 | -0.003343 | 0.002475 | 0.006419 | 0.006479 | 0.012420 | 0.012395 | 0.012400 | 0.004328 | 0.004388 | . 3 0.001073 | -0.003682 | 0.002223 | 0.006161 | 0.006196 | 0.012130 | 0.012126 | 0.012140 | 0.004078 | 0.004146 | . 4 0.001281 | -0.004053 | 0.002251 | 0.005537 | 0.006273 | 0.012027 | 0.012201 | 0.012225 | 0.004151 | 0.004150 | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . 1296 10.000000 | -0.182566 | 0.183470 | -0.398002 | 0.366597 | -0.039593 | 0.138509 | 0.238752 | 0.197595 | 0.108584 | . 1297 0.614484 | -0.770955 | 0.306131 | 0.651660 | 0.294760 | 0.120459 | 0.110172 | 0.041537 | 0.129144 | -0.008039 | . 1298 10.000000 | -0.122420 | 0.331976 | 0.048607 | -0.006551 | 0.223929 | 0.245652 | 0.031154 | -0.133139 | 0.089558 | . 1299 1.296677 | -0.007074 | 0.377199 | 0.894186 | 0.422728 | 0.123843 | 0.134249 | 0.153293 | -0.066743 | 0.084118 | . 1300 1.666697 | -0.182474 | 0.035342 | 0.568853 | 0.383505 | 0.240436 | 0.016508 | -0.267420 | 0.155004 | 0.143566 | . 1301 rows × 10 columns . pandas.read_csv now has two parameters: the usecols keyword which specifies the columns to read in and the header keyword which, when we set to False, tells the read_csv function that there is no heading data in the file and that the headers should be set to an integer range. . Our call to pandas.read_csv read our file but didn&#39;t save the data in memory. To do that, we need to assign the array to a variable. Just as we can assign a single value to a variable, we can also assign an array of values to a variable using the same syntax. Let&#39;s re-run pandas.read_csv and save the returned data: . data = pandas.read_csv(&quot;../data/UVVis-01.csv&quot;,usecols=[1,3,5,7,9,11,13,15,17,19],header=None) . This statement doesn&#39;t produce any output because we&#39;ve assigned the output to the variable data. If we want to check that the data have been loaded, we can print the variable&#39;s value: . print(data) . 1 3 5 7 9 11 13 0 0.000447 -0.003662 0.002233 0.006085 0.006157 0.012101 0.012068 1 0.000656 -0.003497 0.002297 0.006312 0.006317 0.012318 0.012270 2 0.000864 -0.003343 0.002475 0.006419 0.006479 0.012420 0.012395 3 0.001073 -0.003682 0.002223 0.006161 0.006196 0.012130 0.012126 4 0.001281 -0.004053 0.002251 0.005537 0.006273 0.012027 0.012201 ... ... ... ... ... ... ... ... 1296 10.000000 -0.182566 0.183470 -0.398002 0.366597 -0.039593 0.138509 1297 0.614484 -0.770955 0.306131 0.651660 0.294760 0.120459 0.110172 1298 10.000000 -0.122420 0.331976 0.048607 -0.006551 0.223929 0.245652 1299 1.296677 -0.007074 0.377199 0.894186 0.422728 0.123843 0.134249 1300 1.666697 -0.182474 0.035342 0.568853 0.383505 0.240436 0.016508 15 17 19 0 0.012077 0.003982 0.004210 1 0.012277 0.004222 0.004369 2 0.012400 0.004328 0.004388 3 0.012140 0.004078 0.004146 4 0.012225 0.004151 0.004150 ... ... ... ... 1296 0.238752 0.197595 0.108584 1297 0.041537 0.129144 -0.008039 1298 0.031154 -0.133139 0.089558 1299 0.153293 -0.066743 0.084118 1300 -0.267420 0.155004 0.143566 [1301 rows x 10 columns] . Now that the data are in memory, we can manipulate them. First, let&#39;s ask what type of thing data refers to: . print(type(data)) . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; . The output tells us that data currently refers to an pandas DataFrame, the functionality for which is provided by the pandas library. . . Note: A Pandas DataFrame is a two-dimensional labeled data structure with columns of potentially different types. In this case, all the columns are floats, but one column could, for example, contain strings. . The dataframe object has a transpose method which will transpose rows and columns . We can now use the transpose method to swap the rows and columns of data, and assign this to the variable data. . data = data.transpose() print(data) . 0 1 2 3 4 5 6 1 0.000447 0.000656 0.000864 0.001073 0.001281 0.001489 0.001698 3 -0.003662 -0.003497 -0.003343 -0.003682 -0.004053 -0.003248 -0.003364 5 0.002233 0.002297 0.002475 0.002223 0.002251 0.002604 0.002554 7 0.006085 0.006312 0.006419 0.006161 0.005537 0.006554 0.006481 9 0.006157 0.006317 0.006479 0.006196 0.006273 0.006091 0.006526 11 0.012101 0.012318 0.012420 0.012130 0.012027 0.012618 0.012511 13 0.012068 0.012270 0.012395 0.012126 0.012201 0.012195 0.012277 15 0.012077 0.012277 0.012400 0.012140 0.012225 0.012387 0.012464 17 0.003982 0.004222 0.004328 0.004078 0.004151 0.004266 0.004383 19 0.004210 0.004369 0.004388 0.004146 0.004150 0.004467 0.004354 7 8 9 ... 1291 1292 1293 1 0.001906 0.002115 0.002323 ... 10.000000 1.599422 0.799607 3 -0.003756 -0.003421 -0.003197 ... -0.240760 -0.231315 -0.374800 5 0.002299 0.002547 0.002783 ... 0.087444 0.041145 -0.006616 7 0.006209 0.006302 0.006670 ... 0.135279 0.244758 0.566806 9 0.006298 0.006508 0.006617 ... 0.134994 0.245157 0.259086 11 0.012321 0.012475 0.012604 ... 0.467557 0.165135 -0.109406 13 0.012258 0.012480 0.012621 ... 0.090278 0.305513 0.293082 15 0.012261 0.012446 0.012704 ... 0.149705 -0.132876 0.255289 17 0.004193 0.004393 0.004612 ... 0.064985 0.336980 0.046652 19 0.004168 0.004432 0.004675 ... 0.226917 -0.033665 0.195483 1294 1295 1296 1297 1298 1299 1300 1 1.331530 10.000000 10.000000 0.614484 10.000000 1.296677 1.666697 3 -0.278240 -0.156592 -0.182566 -0.770955 -0.122420 -0.007074 -0.182474 5 0.190282 0.233568 0.183470 0.306131 0.331976 0.377199 0.035342 7 0.385321 0.135433 -0.398002 0.651660 0.048607 0.894186 0.568853 9 0.470504 1.172563 0.366597 0.294760 -0.006551 0.422728 0.383505 11 0.214783 0.169591 -0.039593 0.120459 0.223929 0.123843 0.240436 13 -0.083408 0.090353 0.138509 0.110172 0.245652 0.134249 0.016508 15 0.248235 0.051080 0.238752 0.041537 0.031154 0.153293 -0.267420 17 -0.005865 0.099780 0.197595 0.129144 -0.133139 -0.066743 0.155004 19 0.004864 0.040286 0.108584 -0.008039 0.089558 0.084118 0.143566 [10 rows x 1301 columns] . The dataframe object has a to_csv method which will write the dataframe to a file . The final thing left to do is print our cleaned dataset to a file for analysing later. To do this we can use the to_csv DataFrame method. We set the header and index parameters to False as we do not want to print these to the file. . data.to_csv(&#39;../data/UVVis-01-cleaned.csv&#39;, header=False, index=False) . . Do the quick-test. . Back to data analysis and visualisation. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Cleaning-Data.html",
            "relUrl": "/2021/08/02/Cleaning-Data.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post76": {
            "title": "Cleaning data - quick test",
            "content": "Pandas or Numpy . Pandas and NumPy are both essential libraries for scientific computation due to their intuitive syntax and high-performance matrix computation capabilities. In which contexts might Pandas be a more useful library than Numpy (and vice-verca)? . Show answer The Pandas module works well with tabular data. Pandas provides 2d table object called DataFrame. | The NumPy module works well with numerical data. NumPy provides a multi-dimensional array, well suited to matrix operations. | If memory is a limiting factor, NumPy typically consumes less memory than Pandas. | . Crack the code . Crack the code using the dataframe df . . df.loc[3,0:1] df.loc[0,4] df.loc[3,4] df.loc[0,4] df.loc[0,3] df.loc[3,3] df.loc[4,2:3] . Show answer Mmm, tasty tasty “stewed veg”. . . See the notebook. . Back to Data analysis and visualisation. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Cleaning-Data-Qs.html",
            "relUrl": "/2021/08/02/Cleaning-Data-Qs.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post77": {
            "title": "Python basics recap",
            "content": "A pre-requisite for this course is a basic understanding of Python. If you need to recap on the basics, you can use the Python for Physicists website - this covers all of the pre-requisite knowledge needed. . To self-assess your level of understanding, we recommend using ChooChoo the Checklist tool. Your course instructor will need to setup a ChooChoo repository and send you the link. Student instructions for using ChooChoo can be found here. .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Choochoo.html",
            "relUrl": "/2021/08/02/Choochoo.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post78": {
            "title": "Practice question - the physics of burger flipping",
            "content": "In this lesson you will do a practice question in the same style as the coursework assessment for KD5081. . Before you begin . Check that Python and Jupyter Notebook are installed | Launch a Jupyter notebook | . Please see the Setup page for more details. . Resources . Some context: flip your steak! | Article summary | Practice coursework pdf | .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Burger_flipping.html",
            "relUrl": "/2021/08/02/Burger_flipping.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post79": {
            "title": "Analysing data with NumPy",
            "content": "Questions: . How can I import and analyse tabular data files in Python? | . Objectives: . Read tabular data from a file into a program using numpy. | Select individual values and subsections from data. | Perform operations on arrays of data. | . Keypoints: . Use the numpy library to work with arrays in Python. | The expression array.shape gives the shape of an array. | Use array[x, y] to select a single element from a 2D array. | Array indices start at 0, not 1. | All the indexing and slicing that we&#39;ve used on lists and strings also works on arrays. | Use low:high to specify a slice that includes indices from low to high-1. | Arithmetic operations are done element-by-element. | Use numpy.mean(array), numpy.max(array), and numpy.min(array) to calculate simple statistics. | Use numpy.mean(array, axis=0) or numpy.mean(array, axis=1) to calculate the mean along a particular column or row | . Use the numpy library to work with arrays in Python. . In general you should use the NumPy library if you want to do fancy things with numbers, especially if you have matrices or arrays. . import numpy . First lets ask the library to read our cleaned data file for us: . numpy.loadtxt(fname=&#39;../data/UVVis-01-cleaned.csv&#39;, delimiter=&#39;,&#39;) . array([[ 4.47125000e-04, 6.55591000e-04, 8.64056000e-04, ..., 1.00000000e+01, 1.29667747e+00, 1.66669679e+00], [-3.66223800e-03, -3.49741500e-03, -3.34321500e-03, ..., -1.22419536e-01, -7.07442700e-03, -1.82473719e-01], [ 2.23267300e-03, 2.29731000e-03, 2.47505900e-03, ..., 3.31975669e-01, 3.77199233e-01, 3.53418890e-02], ..., [ 1.20771340e-02, 1.22769590e-02, 1.24000520e-02, ..., 3.11538220e-02, 1.53292596e-01, -2.67419547e-01], [ 3.98183100e-03, 4.22229500e-03, 4.32843200e-03, ..., -1.33138746e-01, -6.67433520e-02, 1.55003861e-01], [ 4.21040200e-03, 4.36906300e-03, 4.38802100e-03, ..., 8.95578190e-02, 8.41182170e-02, 1.43565789e-01]]) . The expression numpy.loadtxt(...) is a function call that asks Python to run the function loadtxt which belongs to the numpy library. . numpy.loadtxt has two parameters: the name of the file we want to read and the delimeter that separates values on a line. These both need to be character strings , so we put them in quotes. . Let&#39;s re-run numpy.loadtxt and save the returned data: . data = numpy.loadtxt(fname=&#39;../data/UVVis-01-cleaned.csv&#39;, delimiter=&#39;,&#39;) . Remember, this statement doesn&#39;t produce any output because we&#39;ve assigned the output to the variable data. If we want to check that the data have been loaded, we can print the variable&#39;s value: . print(data) . [[ 4.47125000e-04 6.55591000e-04 8.64056000e-04 ... 1.00000000e+01 1.29667747e+00 1.66669679e+00] [-3.66223800e-03 -3.49741500e-03 -3.34321500e-03 ... -1.22419536e-01 -7.07442700e-03 -1.82473719e-01] [ 2.23267300e-03 2.29731000e-03 2.47505900e-03 ... 3.31975669e-01 3.77199233e-01 3.53418890e-02] ... [ 1.20771340e-02 1.22769590e-02 1.24000520e-02 ... 3.11538220e-02 1.53292596e-01 -2.67419547e-01] [ 3.98183100e-03 4.22229500e-03 4.32843200e-03 ... -1.33138746e-01 -6.67433520e-02 1.55003861e-01] [ 4.21040200e-03 4.36906300e-03 4.38802100e-03 ... 8.95578190e-02 8.41182170e-02 1.43565789e-01]] . First, let&#39;s ask what type of thing data refers to: . print(type(data)) . &lt;class &#39;numpy.ndarray&#39;&gt; . The output tells us that data currently refers to an N-dimensional array, the functionality for which is provided by the NumPy library. The rows are the individual samples, and the columns are the absorption at each wavelength. . . Note: A Numpy array contains one or more elements of the same type. The type function will only tell you that a variable is a NumPy array but won&#39;t tell you the type of thing inside the array. We can find out the type of the data contained in the NumPy array using print(data.dtype). . The expression array.shape gives the shape of an array. . With the following command, we can see the array&#39;s shape: . print(data.shape) . (10, 1301) . The output tells us that the data array variable contains 10 rows and 1301 columns. When we created the variable data to store our absorption data, we didn&#39;t just create the array; we also created information about the array, called members or attributes. This extra information describes data in the same way an adjective describes a noun. data.shape is an attribute of data which describes the dimensions of data. We use the same dotted notation for the attributes of variables that we use for the functions in libraries because they have the same part-and-whole relationship. . Use array[x, y] to select a single element from a 2D array. . If we want to get a single number from the array, we must provide an index in square brackets after the variable name, just as we do in math when referring to an element of a matrix. Our absorption data has two dimensions, so we will need to use two indices to refer to one specific value: . print(&#39;first value in data:&#39;, data[0, 0]) . first value in data: 0.000447125 . print(&#39;middle value in data:&#39;, data[5, 600]) . middle value in data: 0.05236074 . Array indices start at 0, not 1. . The expression data[5, 600] accesses the element at row 5, column 600. While this expression may not surprise you, data[0, 0] might. Programming languages like Fortran, MATLAB and R start counting at 1 because that&#39;s what human beings have done for thousands of years. Languages in the C family (including C++, Java, Perl, and Python) count from 0 because it represents an offset from the first value in the array (the second value is offset by one index from the first value). This is closer to the way that computers represent arrays (if you are interested in the historical reasons behind counting indices from zero, you can read Mike Hoye&#39;s blog post). As a result, if we have an M×N array in Python, its indices go from 0 to M-1 on the first axis and 0 to N-1 on the second. It takes a bit of getting used to, but one way to remember the rule is that the index is how many steps we have to take from the start to get the item we want. . . . Note: What may also surprise you is that when Python displays an array, it shows the element with index [0, 0] in the upper left corner rather than the lower left. This is consistent with the way mathematicians draw matrices but different from the Cartesian coordinates. The indices are (row, column) instead of (column, row) for the same reason, which can be confusing when plotting data. . All the indexing and slicing that we&#39;ve used on lists and strings also works on arrays. . An index like [5, 600] selects a single element of an array, but we can select whole sections as well. For example, we can select the first ten days (columns) of values for the first four patients (rows) like this: . print(data[0:4, 0:10]) . [[ 0.00044712 0.00065559 0.00086406 0.00107252 0.00128099 0.00148945 0.00169792 0.00190638 0.00211485 0.00232331] [-0.00366224 -0.00349741 -0.00334322 -0.0036817 -0.00405294 -0.00324795 -0.00336376 -0.00375587 -0.00342078 -0.00319713] [ 0.00223267 0.00229731 0.00247506 0.00222341 0.00225055 0.00260366 0.00255431 0.00229944 0.00254705 0.00278302] [ 0.0060851 0.00631194 0.00641883 0.00616071 0.00553703 0.00655359 0.00648117 0.00620936 0.00630154 0.00666987]] . Use low:high to specify a slice that includes indices from low to high-1. . The slice 0:4 means, &quot;Start at index 0 and go up to, but not including, index 4.&quot;Again, the up-to-but-not-including takes a bit of getting used to, but the rule is that the difference between the upper and lower bounds is the number of values in the slice. . We don&#39;t have to start slices at 0: . print(data[5:10, 0:10]) . [[0.01210117 0.01231773 0.01241982 0.01212973 0.01202739 0.01261753 0.01251138 0.01232068 0.01247477 0.01260437] [0.01206768 0.01227019 0.01239462 0.01212571 0.01220084 0.01219452 0.0122772 0.01225797 0.01248005 0.01262111] [0.01207713 0.01227696 0.01240005 0.01214027 0.01222512 0.01238692 0.01246438 0.01226141 0.01244613 0.01270402] [0.00398183 0.0042223 0.00432843 0.00407767 0.00415076 0.00426605 0.00438313 0.00419297 0.00439255 0.0046121 ] [0.0042104 0.00436906 0.00438802 0.00414603 0.0041499 0.00446744 0.00435411 0.00416835 0.00443187 0.00467494]] . We also don&#39;t have to include the upper and lower bound on the slice. If we don&#39;t include the lower bound, Python uses 0 by default; if we don&#39;t include the upper, the slice runs to the end of the axis, and if we don&#39;t include either (i.e., if we just use &#39;:&#39; on its own), the slice includes everything: . small = data[:3, 36:] print(&#39;small is:&#39;) print(small) . small is: [[ 7.95187800e-03 8.16034400e-03 8.36880900e-03 ... 1.00000000e+01 1.29667747e+00 1.66669679e+00] [-2.69293800e-03 -2.44559000e-03 -2.69407000e-03 ... -1.22419536e-01 -7.07442700e-03 -1.82473719e-01] [ 3.43972300e-03 3.70568000e-03 3.41978900e-03 ... 3.31975669e-01 3.77199233e-01 3.53418890e-02]] . The above example selects rows 0 through 2 and columns 36 through to the end of the array. . Arithmetic operations are done element-by-element . Arrays also know how to perform common mathematical operations on their values. The simplest operations with data are arithmetic: addition, subtraction, multiplication, and division. When you do such operations on arrays, the operation is done element-by-element. Thus: . doubledata = data * 2.0 . will create a new array doubledata each element of which is twice the value of the corresponding element in data: . print(&#39;original:&#39;) print(data[:3, 36:]) print(&#39;doubledata:&#39;) print(doubledata[:3, 36:]) . original: [[ 7.95187800e-03 8.16034400e-03 8.36880900e-03 ... 1.00000000e+01 1.29667747e+00 1.66669679e+00] [-2.69293800e-03 -2.44559000e-03 -2.69407000e-03 ... -1.22419536e-01 -7.07442700e-03 -1.82473719e-01] [ 3.43972300e-03 3.70568000e-03 3.41978900e-03 ... 3.31975669e-01 3.77199233e-01 3.53418890e-02]] doubledata: [[ 1.59037560e-02 1.63206880e-02 1.67376180e-02 ... 2.00000000e+01 2.59335494e+00 3.33339357e+00] [-5.38587600e-03 -4.89118000e-03 -5.38814000e-03 ... -2.44839072e-01 -1.41488540e-02 -3.64947438e-01] [ 6.87944600e-03 7.41136000e-03 6.83957800e-03 ... 6.63951338e-01 7.54398466e-01 7.06837780e-02]] . If, instead of taking an array and doing arithmetic with a single value (as above), you did the arithmetic operation with another array of the same shape, the operation will be done on corresponding elements of the two arrays. Thus: . tripledata = doubledata + data . will give you an array where tripledata[0,0] will equal doubledata[0,0] plus data[0,0], and so on for all other elements of the arrays. . print(&#39;tripledata:&#39;) print(tripledata[:3, 36:]) . tripledata: [[ 2.38556340e-02 2.44810320e-02 2.51064270e-02 ... 3.00000000e+01 3.89003241e+00 5.00009036e+00] [-8.07881400e-03 -7.33677000e-03 -8.08221000e-03 ... -3.67258608e-01 -2.12232810e-02 -5.47421157e-01] [ 1.03191690e-02 1.11170400e-02 1.02593670e-02 ... 9.95927007e-01 1.13159770e+00 1.06025667e-01]] . Use numpy.mean(array), numpy.max(array), and numpy.min(array) to calculate simple statistics. . Often, we want to do more than add, subtract, multiply, and divide array elements. NumPy knows how to do more complex operations, too. If we want to find the average absorption for all samples across all wavelengths, for example, we can ask NumPy to compute data&#39;s mean value: . print(numpy.mean(data)) . 0.0814548568076864 . mean is a function that takes an array as an argument. . . Note: Generally, a function uses inputs to produce outputs. However, some functions produce outputs without needing any input. For example, checking the current time with print(time.ctime()) doesn&#39;t require any input. For functions that don&#39;t take in any arguments, we still need parentheses () to tell Python to go and do something for us. . NumPy has lots of useful functions that take an array as input. Let&#39;s use three of those functions to get some descriptive values about the dataset. We&#39;ll also use multiple assignment, a convenient Python feature that will enable us to do this all in one line. . maxval, minval, stdval = numpy.max(data), numpy.min(data), numpy.std(data) print(&#39;maximum absorption:&#39;, maxval) print(&#39;minimum absorption:&#39;, minval) print(&#39;standard deviation:&#39;, stdval) . maximum absorption: 10.0 minimum absorption: -1.036568046 standard deviation: 0.24849228257073133 . Here we&#39;ve assigned the return value from numpy.max(data) to the variable maxval, the value from numpy.min(data) to minval, and so on. . Use numpy.mean(array, axis=0) or numpy.mean(array, axis=1) to calculate the mean along a particular column or row . When analyzing data, though, we often want to look at variations in statistical values, such as the maximum absorption per sample or the average absorption per wavelength. One way to do this is to create a new temporary array of the data we want, then ask it to do the calculation: . sample_0 = data[0, :] # 0 on the first axis (rows), everything on the second (columns) print(&#39;maximum absorption for sample 0:&#39;, sample_0.max()) . maximum absorption for sample 0: 10.0 . . Tip: Everything in a line of code following the &#8217;#&#8217; symbol is a comment that is ignored by Python. Comments allow programmers to leave explanatory notes for other programmers or their future selves. . We don&#39;t actually need to store the row in a variable of its own. Instead, we can combine the selection and the function call: . print(&#39;maximum absorption for sample 2:&#39;, numpy.max(data[2, :])) . maximum absorption for sample 2: 0.377199233 . What if we need the maximum absorption for each patient over all wavelengths (as in the next diagram on the left) or the average for each wavelength (as in the diagram on the right)? As the diagram below shows, we want to perform the operation across an axis: . . To support this functionality, most array functions allow us to specify the axis we want to work on. If we ask for the average across axis 0 (rows in our 2D example), we get: . print(numpy.mean(data, axis=0)) . [0.00556981 0.00575402 0.00588247 ... 1.07087656 0.34124763 0.27600167] . As a quick check, we can ask this array what its shape is: . print(numpy.mean(data, axis=0).shape) . (1301,) . The expression (1301,) tells us we have an N×1 vector, so this is the average absorption per day for all samples. If we average across axis 1 (columns in our 2D example), we get: . print(numpy.mean(data, axis=1)) . [0.13104075 0.02947129 0.02323768 0.08578812 0.07745822 0.10012283 0.10339795 0.09871813 0.08216419 0.08314941] . which is the average absorption per sample across all wavelengths. . . Do the quick-test. . Back to data analysis and visualisation. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Analysing-Data.html",
            "relUrl": "/2021/08/02/Analysing-Data.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post80": {
            "title": "Analysing data - quick test",
            "content": "Encapsulation . Fill in the blanks to create a function that takes a single filename, containing comma separated values, as an argument, loads the data in the file named by the argument, and returns the minimum value in that data. . import numpy def min_in_data(____): data = ____ return ____ . Show answer import numpy def min_in_data(filename): data = numpy.loadtxt(fname=filename, delimiter=&#39;,&#39;) return data.min() . Stacking Arrays . Arrays can be concatenated and stacked on top of one another, using NumPy’s vstack and hstack functions for vertical and horizontal stacking, respectively. . import numpy A = numpy.array([[1,2,3], [4,5,6], [7, 8, 9]]) print(&#39;A = &#39;) print(A) B = numpy.hstack([A, A]) print(&#39;B = &#39;) print(B) C = numpy.vstack([A, A]) print(&#39;C = &#39;) print(C) . A = [[1 2 3] [4 5 6] [7 8 9]] B = [[1 2 3 1 2 3] [4 5 6 4 5 6] [7 8 9 7 8 9]] C = [[1 2 3] [4 5 6] [7 8 9] [1 2 3] [4 5 6] [7 8 9]] . Write some additional code that slices the first and last columns of A, and stacks them into a 3x2 array. Make sure to print the results to verify your solution. . Show answer A ‘gotcha’ with array indexing is that singleton dimensions are dropped by default. That means A[:, 0] is a one dimensional array, which won’t stack as desired. To preserve singleton dimensions, the index itself can be a slice or array. For example, A[:, :1] returns a two dimensional array with one singleton dimension (i.e. a column vector). . D = numpy.hstack((A[:, :1], A[:, -1:])) print(&#39;D = &#39;) print(D) . D = [[1 3] [4 6] [7 9]] . An alternative way to achieve the same result is to use Numpy’s delete function to remove the second column of A. . D = numpy.delete(A, 1, 1) print(&#39;D = &#39;) print(D) . D = [[1 3] [4 6] [7 9]] . . See the notebook. . Back to Data analysis and visualisation. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Analysing-Data-Qs.html",
            "relUrl": "/2021/08/02/Analysing-Data-Qs.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post81": {
            "title": "Variables and assignment",
            "content": ". Questions: . How can I store data in programs? | . Objectives: . Write programs that assign scalar values to variables and perform calculations with those values. | Correctly trace value changes in programs that use scalar assignment. | . Keypoints: . Use variables to store values. | Use print to display values. | Variables must be created before they are used. | Variables persist between cells. | Variables can be used in calculations. | Python is case-sensitive. | Use valid and meaningful variable names. | . . Use variables to store values. . Variables are names for values. | In Python the = symbol assigns the value on the right to the name on the left. | The variable is created when a value is assigned to it. | Here, Python assigns an age to a variable age and a name in quotes to a variable first_name. | . age = 42 first_name = &#39;Ahmed&#39; . Use print to display values. . Python has a built-in function called print that prints things as text. | Call the function (i.e., tell Python to run it) by using its name. | Provide values to the function (i.e., the things to print) in parentheses. | To add a string to the printout, wrap the string in single or double quotes. | The values passed to the function are called &#39;arguments&#39; | . print(first_name, &#39;is&#39;, age, &#39;years old&#39;) . Ahmed is 42 years old . print automatically puts a single space between items to separate them. | And wraps around to a new line at the end. | . Variables must be created before they are used. . Unlike some languages, which &quot;guess&quot; a default value, if a variable doesn&#39;t exist yet, or if the name has been mis-spelled, Python reports an error. | . print(last_name) . NameError Traceback (most recent call last) /var/folders/5q/mny3pg2n7h5g21h3v32rfj9wpykqrf/T/ipykernel_792/2256896230.py in &lt;module&gt; -&gt; 1 print(last_name) 2 NameError: name &#39;last_name&#39; is not defined . The last line of an error message is usually the most informative. | We will look at error messages in detail later. | . Variables Persist Between Cells . Be aware that it is the order of execution of cells that is important in a Jupyter notebook, not the order in which they appear. Python will remember all the code that was run previously, including any variables you have defined, irrespective of the order in the notebook. Therefore if you define variables lower down the notebook and then (re)run cells further up, those defined further down will still be present. As an example, we can create 2 cells with the following content, in this order: . print(myval) . myval = 1 . If you execute this in order, the first cell will give an error. However, if you run the first cell after the second cell it will print out ‘1’. To prevent confusion, it can be helpful to use the Kernel -&gt; Restart &amp; Run All option which clears the interpreter and runs everything from a clean slate going top to bottom. . Variables can be used in calculations. . We can use variables in calculations just as if they were values. | . age = 42 age = age + 3 print(&#39;Age in three years:&#39;, age) . Age in three years: 45 . Python is case-sensitive. . Python thinks that upper- and lower-case letters are different, so Name and name are different variables. | There are conventions for using upper-case letters at the start of variable names so we will use lower-case letters for now. | . . Tip: In programming an eye for detail is important. If you include an extra full-stop, or forget a space, then you may get an error message or unexpected behaviour. . Use valid and meaningful variable names. . Python doesn&#39;t care what you call variables as long as they obey the following rules: . can only contain letters, digits, and underscore _ (typically used to separate words in long variable names) | cannot start with a digit | . | Variable names that start with underscores like __bobbins_real_age have a special meaning so we won&#39;t do that until we understand the convention. . | . flabadab = 42 ewr_422_yY = &#39;Ahmed&#39; print(ewr_422_yY, &#39;is&#39;, flabadab, &#39;years old&#39;) . Use meaningful variable names to help other people understand what the program does. | The most important &quot;other person&quot; is your future self. | . . Do the quick-test. . Back to Python part one. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/02-Variables-Assignment.html",
            "relUrl": "/2021/08/02/02-Variables-Assignment.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post82": {
            "title": "Variables and assignment - quick test",
            "content": "Swapping Values . Fill the table showing the values of the variables in this program after each statement is executed. . Command Value of x Value of y Value of swap . x = 1.0 |   |   |   | . y = 3.0 |   |   |   | . swap = x |   |   |   | . x = y |   |   |   | . y = swap |   |   |   | . Show answer Command Value of x Value of y Value of swap . x = 1.0 | 1.0 | not defined | not defined | . y = 3.0 | 1.0 | 3.0 | not defined | . swap = x | 1.0 | 3.0 | 1.0 | . x = y | 3.0 | 3.0 | 1.0 | . y = swap | 3.0 | 1.0 | 1.0 | . These three lines exchange the values in x and y using the swap variable for temporary storage. This is a fairly common programming idiom. . Predicting Values . What is the final value of position in the program below? (Try to predict the value without running the program, then check your prediction.) . initial = &#39;left&#39; position = initial initial = &#39;right&#39; . Show answer The final value of position is &#39;left&#39;. . The initial variable is assigned the value ‘left’. In the second line, the position variable also receives the string value ‘left’. In third line, the initial variable is given the value ‘right’, but the position variable retains its string value of ‘left’. . Choosing a Name . Which is a better variable name, m, min, or minutes? Why? . Hint: think about which code you would rather inherit from someone who is leaving the lab: . ts = m * 60 + s tot_sec = min * 60 + sec total_seconds = minutes * 60 + seconds . Show answer minutes is better because min might mean something like “minimum” (and actually does in Python, but we haven’t seen that yet). . . See the notebook. . Back to Python part one. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/02-Variables-Assignment-Qs.html",
            "relUrl": "/2021/08/02/02-Variables-Assignment-Qs.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post83": {
            "title": "Running python - quick test",
            "content": "Creating Lists in Markdown . Create a nested list in a Markdown cell in a notebook that looks like this: . Get funding. | Do work. Design experiment. | Collect data. | Analyze. | . | Write up. | Publish. | Show answer Note that the bullet list is indented 2 spaces so that it is inline with the items of the numbered list. . 1. Get funding. 2. Do work. * Design experiment. * Collect data. * Analyze. 3. Write up. 4. Publish. . Multiple Maths . What is displayed when a Python cell in a notebook that contains several calculations is executed? For example, what happens when this cell is executed? . 7 * 3 2 + 1 . Show answer Python returns the output of the last calculation. The output is: . 3 . Equations . Standard Markdown (such as we’re using for these notes) won’t render equations, but the Notebook will. Create a new Markdown cell and enter the following: . $ sum_{i=1}^{N} 2^{-i} approx 1$ . (It’s probably easier to copy and paste.) What does it display? What do you think the underscore, _, circumflex, ^, and dollar sign, $, do? . Show answer The notebook shows the equation as it would be rendered from LaTeX equation syntax. . The dollar sign, $, is used to tell markdown that the text in between is a latex equation. | underscore, _, is used for subscripts | circumflex, ^, is used for superscripts. | A pair of curly braces, { and }, is used to group text together so that the statement i=1 becomes the the subscript and N becomes the superscript. | Similarly, -i is in curly braces to make the whole statement the superscript for 2. | sum and approx are latex commands for “sum over” and “approximate” symbols. | . . See the notebook. . Back to Python part one. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/01-Running_python-Qs.html",
            "relUrl": "/2021/08/02/01-Running_python-Qs.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post84": {
            "title": "Running Python",
            "content": ". Questions: . How can I run Python programs? | . Objectives: . Launch the Jupyter Notebook, create new notebooks, and exit the Notebook. | Create Markdown cells in a notebook. | Create and run Python cells in a notebook. | . Keypoints: . Python programs are plain text files. | Use the Jupyter Notebook for editing and running Python. | Use the keyboard and mouse to select and edit cells. | The Notebook will turn Markdown into pretty-printed documentation. | . . There are multiple ways to run Python code . Python programmes can be written as plain text files using a text editor | They have the .py extension to let everyone (including the operating system) know it is a Python program. This is convention, not a requirement. We will use plain text files for writing Python code towards the end of this course. | For this part of the course we are going to use [Jupyter Notebooks][jupyter]. | The Notebook provides code completion and other helpful features. | Notebook files have the extension .ipynb to distinguish them from plain-text Python programs. | . You can use the Jupyter Notebook for editing and running Python. . When we type jupyter notebook in a terminal (or Git Bash) we start a Jupyter Notebook server and open the default web browser. | The server runs locally on your machine only and does not use an internet connection. | You can type code into the browser and see the result when the web page talks to the server. | This has several advantages: You can easily type, edit, and copy and paste blocks of code. | Tab complete allows you to easily access the names of things you are using and learn more about them. | It allows you to annotate your code with links, different sized text, bullets, etc. to make it more accessible to you and your collaborators. | It allows you to display figures next to the code that produces them to tell a complete story of the analysis. The notebook file is stored in a format called JSON. | Just like a webpage, what&#39;s saved looks different from what you see in your browser. | But this format allows Jupyter to mix source code, text, and images, all in one file. | . | . . Tip: You can view this page as a Notebook by clicking on either the Binder or Colab button at the top of this page. . Use the keyboard and mouse to select and edit cells. . You can create a new cell by clicking on Insert at the top of the Notebook. | Pressing the &quot;shift&quot; and the &quot;enter&quot; key together will execute the contents of the cell. | . Use command mode to speed things up . You can also use keyboard shortcuts by entering command mode using the esc key. | Notice that the border of your cell turns blue. | Type a shortcut command - for example b to create a new cell. | The list of shortcuts can be found using h. | To exit command mode and start editing the cell press enter. | . The Notebook will turn Markdown into pretty-printed documentation. . Notebooks can also render [Markdown][markdown] which is a simple plain-text format for writing lists, links, and other things that might go into a web page. | You can turn cell into a Markdown cell by selecting Markdown from the drop-down menu at the top of the Notebook | In [ ]: will disappear to show it is no longer a code cell and you will be able to write in Markdown. | . Lists . * Use asterisks * to create * bullet lists. . Use asterisks | to create | bullet lists. | . 1. Use numbers 2. to create 3. numbered lists. . Use numbers | to create | numbered lists. | 1. You can 2. also * create sub-lists . You can | also create sub-lists | . | Headings . # A Level-1 Heading . A Level-1 Heading . ## A Level-2 Heading (etc) . A Level-2 Heading (etc) . Whitespace . Line breaks don&#39;t matter. But blank lines create new paragraphs. . Line breaks don&#39;t matter. . But blank lines create new paragraphs. . Basic formatting . You can easily: . use italics with *italics* | use bold with **bold** | Create links with [...](...). | . . Do the quick-test. . Back to Python part one. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/01-Running_Python.html",
            "relUrl": "/2021/08/02/01-Running_Python.html",
            "date": " • Aug 2, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About",
          "content": "This website contains resources for the second year course “Theory, computation and experiment” (KD5081) at Northumbria University, UK. The resources have been developed by Dr Lucy Whalley. If you spot any mistakes or have any suggestions please raise an issue on the Github repository for this course. . The website is powered by Github and fastpages, which is licensed under Apache License 2.0. . The content of this website is adapted and derived from several other sources: . The Setup instructions page is a derivative of materials from Software Carpentry, used under Attribution 4.0 International (CC BY 4.0). | The tutorial “Testing and Documentation” is a derivative of the Testing lesson from Code Refinery, used under Attribution 4.0 International (CC BY 4.0). | Some of the exercises are adapted from the book Computational Physics. These are used with the permission of the book’s author, Mark Newman, and remain under his copyright. | . In addition, parts of the “Getting results” section were inspired by Rudolf Winter’s notes on ODEs and PDEs. . The content of this website unless otherwise indicated is licensed under Creative Commons Attribution 4.0 International. You can re-use any of its content as long as an attribution is included, and you indicate if changes were made. .",
          "url": "https://nu-cem.github.io/CompPhys/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
      ,"page3": {
          "title": "Links",
          "content": "Listed below are some links to external resources that complement this course. If you find other useful resources please raise an issue or email me. . Course resources and questionnaire . If you have suggested improvements for this course please raise a Github issue here. | For students at Northumbria (KD5018) there is a course ChooChoo repository here. | For students at Northumbria please complete this questionnaire during the first lecture. | . Course textbooks . Both of the textbooks below are available in the Northumbria University library (as of 2022): . Computational Physics by Mark Newman | Computational physics: problem solving with Python by Landau, Páez and Bordeianu | . Online resources . Programming basics . Martijn Stegen Programming basics workbook | . Scientific programming in Python . Aalto University Python for scientific computing | SciPy lecture notes | The Carpentries Programming in Python course | . Numerical methods . Rudolf Winter’s notes on ODEs and PDEs | Python programming and numerical methods | Numerical methods - an Inquiry-Based Approach With Python | .",
          "url": "https://nu-cem.github.io/CompPhys/links/",
          "relUrl": "/links/",
          "date": ""
      }
      
  

  
  

  

  
  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://nu-cem.github.io/CompPhys/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}