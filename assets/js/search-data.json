{
  
    
        "post0": {
            "title": "Writing functions - quick test",
            "content": "Identifying Syntax Errors . Read the code below and try to identify what the errors are without running it. | Run the code and read the error message. Is it a SyntaxError or an IndentationError? | Fix the error. | Repeat steps 2 and 3 until you have fixed all the errors. | def another_function print(&quot;Syntax errors are annoying.&quot;) print(&quot;But at least python tells us about them!&quot;) print(&quot;So they are usually not too hard to fix.&quot;) . Show answer def another_function(): print(&quot;Syntax errors are annoying.&quot;) print(&quot;But at least Python tells us about them!&quot;) print(&quot;So they are usually not too hard to fix.&quot;) . Definition and Use . What does the following program print? . def report(pressure): print(&#39;pressure is&#39;, pressure) print(&#39;calling&#39;, report, 22.5) . Show answer calling &lt;function report at 0x7fd128ff1bf8 22.5 . A function call always needs parenthesis, otherwise you get memory address of the function object. So, if we wanted to call the function named report, and give it the value 22.5 to report on, we could have our function call as follows . print(&quot;calling&quot;) report(22.5) . Order of Operations . The example above: . result = print_date(1871, 3, 19) print(&#39;result of call is:&#39;, result) . printed: . 1871/3/19 result of call is: None . Explain why the two lines of output appeared in the order they did. . What‚Äôs wrong in this example? . result = print_date(1871,3,19) def print_date(year, month, day): joined = str(year) + &#39;/&#39; + str(month) + &#39;/&#39; + str(day) print(joined) . Show answer The first line of output (1871/3/19) is from the print function inside print_date(), while the second line is from the print function below the function call. All of the code inside print_date() is executed first, and the program then ‚Äúleaves‚Äù the function and executes the rest of the code. | The problem with the example is that the function is defined after the call to the function is made. Python therefore doesn‚Äôt understand the function call. | Find the First . Fill in the blanks to create a function that takes a list of numbers as an argument and returns the first negative value in the list. What does your function do if the list is empty? . def first_negative(values): for v in ____: if ____: return ____ . Show answer def first_negative(values): for v in values: if v&lt;0: return v . If an empty list is passed to this function, it returns None: . my_list = [] print(first_negative(my_list) . None . Calling by Name . Earlier we saw this function: . def print_date(year, month, day): joined = str(year) + &#39;/&#39; + str(month) + &#39;/&#39; + str(day) print(joined) . We saw that we can call the function using named arguments, like this: . print_date(day=1, month=2, year=2003) . What does print_date(day=1, month=2, year=2003) print? | When and why is it useful to call functions this way? | Show answer 2003/2/1 | Using named arguments can make code more readable since one can see from the function call what name the different arguments have inside the function. It can also reduce the chances of passing arguments in the wrong order, since by using named arguments the order doesn‚Äôt matter. | Encapsulate of If/Print Block . The code below will run on a label-printer for chicken eggs. A digital scale will report a chicken egg mass (in grams) to the computer and then the computer will print a label. . Please re-write the code so that the if-block is folded into a function. . import random for i in range(10): # simulating the mass of a chicken egg # the (random) mass will be 70 +/- 20 grams mass=70+20.0*(2.0*random.random()-1.0) print(mass) #egg sizing machinery prints a label if(mass=85): print(&quot;jumbo&quot;) elif(mass=70): print(&quot;large&quot;) elif(mass&lt;70 and mass=55): print(&quot;medium&quot;) else: print(&quot;small&quot;) . The simplified program follows. What function definition will make it functional? . # revised version import random for i in range(10): # simulating the mass of a chicken egg # the (random) mass will be 70 +/- 20 grams mass=70+20.0*(2.0*random.random()-1.0) print(mass,print_egg_label(mass)) . Create a function definition for print_egg_label() that will work with the revised program above. Note, the function‚Äôs return value will be significant. Sample output might be 71.23 large. | A dirty egg might have a mass of more than 90 grams, and a spoiled or broken egg will probably have a mass that‚Äôs less than 50 grams. Modify your print_egg_label() function to account for these error conditions. Sample output could be 25 too light, probably spoiled. | Show answer def print_egg_label(mass): #egg sizing machinery prints a label if(mass=90): return(&quot;warning: egg might be dirty&quot;) elif(mass=85): return(&quot;jumbo&quot;) elif(mass=70): return(&quot;large&quot;) elif(mass&lt;70 and mass=55): return(&quot;medium&quot;) elif(mass&lt;50): return(&quot;too light, probably spoiled&quot;) else: return(&quot;small&quot;) . Simulating a dynamical system . In mathematics, a dynamical system is a system in which a function describes the time dependence of a point in a geometrical space. A canonical example of a dynamical system is a system called the logistic map. . Define a function called logistic_map that takes two inputs: x, representing the state of the system at time t, and a parameter r. This function should return a value representing the state of the system at time t+1. . | Using a for loop, iterate the logistic_map function defined in part 1 starting from an initial condition of 0.5 for t_final=10, 100, and 1000 periods. Store the intermediate results in a list so that after the for loop terminates you have accumulated a sequence of values representing the state of the logistic map at time t=0,1,‚Ä¶,t_final. . | Encapsulate the logic of your for loop into a function called iterate that takes the initial condition as its first input, the parameter t_final as its second input and the parameter r as its third input. The function should return the list of values representing the state of the logistic map at time t=0,1,‚Ä¶,t_final. . | Show answer 1. . def logistic_map(x, r): return r * x * (1 - x) . 2. . initial_condition = 0.5 t_final = 10 r = 1.0 trajectory = [initial_condition] for t in range(1, t_final): trajectory[t] = logistic_map(trajectory[t-1], r) . 3. . def iterate(initial_condition, t_final, r): trajectory = [initial_condition] for t in range(1, t_final): trajectory[t] = logistic_map(trajectory[t-1], r) return trajectorys . . See the notebook. . Back to Python part two. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Writing-Functions-Qs.html",
            "relUrl": "/2021/08/02/Writing-Functions-Qs.html",
            "date": " ‚Ä¢ Aug 2, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Cleaning data - quick test",
            "content": "Plot Scaling I . Why do all of our plots stop just short of the upper end of our graph? . Show answer Because matplotlib normally sets x and y axes limits to the min and max of our data (depending on data range) . If we want to change this, we can use the set_ylim(min, max) method of each ‚Äòaxes‚Äô, for example: . axes3.set_ylim(0,6) . Plot Scaling II . Update your plotting code to automatically set a more appropriate scale. (Hint: you can make use of the max and min methods to help.) . Show answer # One method axes3.set_ylabel(&#39;min&#39;) axes3.plot(numpy.min(data, axis=0)) axes3.set_ylim(0,6) . # A more automated approach min_data = numpy.min(data, axis=0) axes3.set_ylabel(&#39;min&#39;) axes3.plot(min_data) axes3.set_ylim(numpy.min(min_data), numpy.max(min_data) * 1.1) . Make Your Own Plot . Create a plot showing the standard deviation (numpy.std) of the absorption data for each day across all patients. . Show answer std_plot = matplotlib.pyplot.plot(numpy.std(data, axis=0)) matplotlib.pyplot.show() . Moving Plots Around . Modify the program to display the three plots on top of one another instead of side by side. . Show answer import numpy import matplotlib.pyplot data = numpy.loadtxt(fname=&#39;UVVis-01-cleaned.csv&#39;, delimiter=&#39;,&#39;) # change figsize (swap width and height) fig = matplotlib.pyplot.figure(figsize=(3.0, 10.0)) # change add_subplot (swap first two parameters) axes1 = fig.add_subplot(3, 1, 1) axes2 = fig.add_subplot(3, 1, 2) axes3 = fig.add_subplot(3, 1, 3) axes1.set_ylabel(&#39;average&#39;) axes1.plot(numpy.mean(data, axis=0)) axes2.set_ylabel(&#39;max&#39;) axes2.plot(numpy.max(data, axis=0)) axes3.set_ylabel(&#39;min&#39;) axes3.plot(numpy.min(data, axis=0)) fig.tight_layout() matplotlib.pyplot.show() . . See the notebook. . Back to Data analysis and visualisation. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Visualising-Data-Qs.html",
            "relUrl": "/2021/08/02/Visualising-Data-Qs.html",
            "date": " ‚Ä¢ Aug 2, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "Version control and Github",
            "content": "Version control and Github .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Version_control.html",
            "relUrl": "/2021/08/02/Version_control.html",
            "date": " ‚Ä¢ Aug 2, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "Variable scope - quick test",
            "content": "Local and Global Variable Use . Trace the values of all variables in this program as it is executed. (Use ‚Äò‚Äî‚Äô as the value of variables before and after they exist.) . limit = 100 def clip(value): return min(max(0.0, value), limit) value = -22.5 print(clip(value)) . Reading Error Messages . Read the traceback below, and identify the following: . How many levels does the traceback have? | What is the file name where the error occurred? | What is the function name where the error occurred? | On which line number in this function did the error occurr? | What is the type of error? | What is the error message? | KeyError Traceback (most recent call last) &lt;ipython-input-2-e4c4cbafeeb5&gt; in &lt;module&gt;() 1 import errors_02 -&gt; 2 errors_02.print_friday_message() /Users/ghopper/thesis/code/errors_02.py in print_friday_message() 13 14 def print_friday_message(): &gt; 15 print_message(&quot;Friday&quot;) /Users/ghopper/thesis/code/errors_02.py in print_message(day) 9 &quot;sunday&quot;: &quot;Aw, the weekend is almost over.&quot; 10 } &gt; 11 print(messages[day]) 12 13 KeyError: &#39;Friday&#39; . Show answer Three levels. | errors_02.py | print_message | Line 11 | KeyError. These errors occur when we are trying to look up a key that does not exist (usually in a data structure such as a dictionary). We can find more information about the KeyError and other built-in exceptions in the Python docs. | KeyError: &#39;Friday&#39; | . See the notebook. . Back to Python part two. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Variable-Scope-Qs.html",
            "relUrl": "/2021/08/02/Variable-Scope-Qs.html",
            "date": " ‚Ä¢ Aug 2, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "The strange attractor",
            "content": ". Questions: . How do I solve simultaneous ODEs? | How do I solve second-order ODEs (and higher)? | . Objectives: . Use Euler&#39;s method, implemented in Python, to solve a set of simultaneous ODEs | Use Euler&#39;s method, implemented in Python, to solve a second-order ODE | Understand how the same method could be applied to higher order ODEs | . . Computers don&#39;t care so much about the type of differential equation . In the previous lesson we used Euler&#39;s method to model radioactive decay. To demonstrate the method we deliberately chose a simple example (a linear, first order, separable ODE with one dependent variable). We have seen that this equation can also be solved analytically, so really there is no need for approximate numerical methods in this case. . However there are a large number of physical equations that cannot be solved analytically, and that rely on numerical methods for their modelling. . For example, the Lotka-Volterra equations for studying predator-prey interactions have multiple dependent variables and the Cahn-Hilliard equation for modelling phase separation in fluids is non-linear. These equations can be solved analytically for particular, special cases only. . Computers don&#39;t care whether an equation is linear or non-linear, multi-variable or single-variable, the numerical method for studying it is much the same - with the caveat that numerical methods are approximate and so we need to think about the accuracy of the methods used. . Simultaneous ODEs can be solved using numerical methods . One class of problems that are difficult to solve analytically are simultaenous ODEs. These are equations where the derivative of each dependent variable can depend on any of the variables (dependent or independent). For example, . begin{eqnarray} frac{ mathrm{d}x}{ mathrm{d}t} &amp;=&amp; xt + y frac{ mathrm{d}y}{ mathrm{d}t} &amp;=&amp; mathrm{sin}^2 omega t - xy end{eqnarray}A famous set of simulataneous ODEs are the Lorenz equations, which are the subject of this lesson. . begin{eqnarray} frac{ mathrm{d}x}{ mathrm{d}t} &amp;=&amp; sigma(y-x) frac{ mathrm{d}y}{ mathrm{d}t} &amp;=&amp; rx-y-xz frac{ mathrm{d}z}{ mathrm{d}t} &amp;=&amp; xy-bz end{eqnarray}There three dependent variables - $x$, $y$ and $z$, and one dependent variable $t$. There are also three constants - $ sigma$, $r$ and $b$. . For particular values of $ sigma$, $r$ and $b$ the Lorenz systems has chaotic behaviour (a strong dependence on the initial conditions) and for a subset of these, there is also fractal structure called the strange attractor. . Euler&#39;s method is easily extended to simultaneous ODEs . In the previous lesson we were introduced to Euler&#39;s method for the single variable case: . begin{equation} N(t+h) = N(t) + hf(N,t). end{equation}This can be easily extended to the multi-variable case using vector notation: . begin{equation} mathbf{r}(t+h) = mathbf{r}(t) + h mathbf{f}( mathbf{r},t). end{equation}We have seen that arrays can be easily represented in Python using the NumPy library. This allows us to do arithmetic with vectors directly (rather than using verbose workarounds such as for loops), so the code is not much more complicated than the one-variable case. . First, let&#39;s import the standard scientific libraries we will be using - Numpy and Matplotlib: . import numpy as np import matplotlib.pyplot as plt . Now we define the function that describe the Lorenz system. . Note: When the operands are NumPy arrays, the operations are automatically element-wise vector operations. . def Lorenz(sigma,r,b,xyz): x = xyz[0] y = xyz[1] z = xyz[2] fx = sigma*(y-x) fy = (r*x)-y-(x*z) fz = (x*y)-(b*z) return np.array([fx,fy,fz],float) . Next we&#39;ll list the simulation parameters (start time, end time, number of time steps and step size), the initial values for $x$, $y$ and $z$, and the constants $ sigma$, $r$ and $b$. . start = 0 # start time end = 50 # end time num_steps = 501 # number of time steps h = (b-a) / num_steps # time step size # intitial conditions: x=0, y=1, z=0 xyz = np.array([0,1,0],float) # constants sigma = 10 r = 28 b = 8/3 . We use the Numpy arange function to generate a list of evenly spaced times at which to evaluate the system. We also create an empty list to hold the values for $x$, $y$ and $z$ that we are yet to calculate. . time_list = np.arange(start,end,h) # create empty arrays to hold the calculated values x_points = [] y_points = [] z_points = [] . Finally, we apply Euler&#39;s method using a For loop. Note that the order of operations in the loop body is important. . for time in time_list: x_points.append(xyz[0]) y_points.append(xyz[1]) z_points.append(xyz[2]) xyz += h*Lorenz(sigma,r,b,xyz) . To visualise the strange attractor we can plot the values of $z$ against $y$: . plt.plot(x_points,z_points) . [&lt;matplotlib.lines.Line2D at 0x11b2b7460&gt;] . Higher order ODEs can be re-cast as simultaneous ODEs and solved in the same way . Many physical equations are second-order or higher. The general form for a second-order differential equation with one dependent variable is: . begin{equation} frac{ mathrm{d}^2x}{ mathrm{d}t^2} = f left(x, frac{ mathrm{d}x}{ mathrm{d}t},t right) end{equation}Luckily, we can re-cast a higher order equation as a set of simultaneous equations, and then solve in the same way as above. . Let&#39;s use the non-linear pendulum as an example. For a pendulum with an art of length $l$ and a bob of mass $m$, Newton&#39;s second law ($F=ma$) provides the following equation of motion: . begin{equation} ml frac{ mathrm{d}^2 theta}{ mathrm{d}t^2} = -mg sin( theta), end{equation}where $ theta$ is the angle of displacement of the arm from the vertical and $l frac{ mathrm{d}^2 theta}{ mathrm{d}t^2}$ is the acceleration of the mass in the tangential direction. The exact solution to this equation is unknown, but we now have the knowledge needed to find a numerical approximation. . The equation can be re-written as: . begin{equation} frac{ mathrm{d}^2 theta}{ mathrm{d}t^2} = - frac{g}{l} sin( theta) end{equation}We define a new variable $ omega$: . begin{equation} frac{ mathrm{d} theta}{ mathrm{d}t} = omega end{equation}and substitute this into the equation of motion: . begin{equation} frac{ mathrm{d} omega}{ mathrm{d}t} = - frac{g}{l} sin( theta). end{equation}These two expressions form a set of simultaneous equations that can be solved numerically using the method outlined above. . . Keypoints: . Computers don&#39;t care so much about the type of differential equation | Simulatenous ODEs can also be solved using numerical methods | Euler&#39;s method is easily extended to the multi-variable case | Higher order ODEs can be re-cast as simultaneous ODEs and solved the same way | . . . Do the quick-test. . Back to Modelling with Ordinary Differential Equations. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Strange-Attractor.html",
            "relUrl": "/2021/08/02/Strange-Attractor.html",
            "date": " ‚Ä¢ Aug 2, 2021"
        }
        
    
  
    
        ,"post5": {
            "title": "Documentation and testing",
            "content": "",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Sharing_code.html",
            "relUrl": "/2021/08/02/Sharing_code.html",
            "date": " ‚Ä¢ Aug 2, 2021"
        }
        
    
  
    
        ,"post6": {
            "title": "Setup",
            "content": "To participate in this course you will need access to the following software: Python, Bash, Git and Jupyter. To install this software on your personal laptop or desktop carefully follow the instructions listed below. . You will also need a user account at github.com - Basic GitHub accounts are free. . . All of the software needed for this course is pre-installed in the MPEE computers at Northumbria University . You can also run the Python Jupyter Notebook files remotely through the [binder](https://mybinder.org/) or [colab](https://colab.research.google.com) services whenever you see an icon (e.g. like those at the top of [this page](https://nu-cem.github.io/CompPhys/2021/08/02/01-Running_Python)). But be warned! Any changes you make are not saved and the service can time-out after a period of inactivity (usually ~20 minutes). Downloads . Python . Python is a popular language for scientific computing, and great for general-purpose programming as well. Installing all of its scientific packages individually can be a bit difficult, however, so we recommend the all-in-one installer Anaconda. . Windows - video tutorial . Open [https://www.anaconda.com/products/individual#download-section] with your web browser. . | Download the Anaconda for Windows installer with Python 3. (If you are not sure which version to choose, you probably want the 64-bit Graphical Installer Anaconda3-‚Ä¶-Windows-x86_64.exe) . | Double-click the executable and install Python 3 using MOST of the default settings, the only exception is to check Add Anaconda to my PATH environment variable. . | Mac OS X - video tutorial . Open [https://www.anaconda.com/products/individual#download-section] with your web browser. . | Download the Anaconda Installer with Python 3 for macOS (you can either use the Graphical or the Command Line Installer). . | Install Python 3 by running the Anaconda Installer using all of the defaults for installation. . | Bash and Git . Bash is a commonly-used shell that gives you the power to do simple tasks more quickly. Git is version-control software that allows to you to develop code more efficiently and share a public version of your code on github.com. In fact, this website is built using Bash, Git and github.com (amongst other tools) - the code can be found here. You can download both tools at the same time following the instructions below. . Windows - video tutorial . Download the Git for Windows installer | Run the installer and follow the steps below: a) Click on ‚ÄúNext‚Äù four times (two times if you‚Äôve previously installed Git). You don‚Äôt need to change anything in the Information, location, components, and start menu screens. b) From the dropdown menu select ‚ÄúUse the Nano editor by default‚Äù (NOTE: you will need to scroll up to find it) and click on ‚ÄúNext‚Äù. c) On the page that says ‚ÄúAdjusting the name of the initial branch in new repositories‚Äù, ensure that ‚ÄúLet Git decide‚Äù is selected. This will ensure the highest level of compatibility for our lessons. d) Ensure that ‚ÄúGit from the command line and also from 3rd-party software‚Äù is selected and click on ‚ÄúNext‚Äù. (If you don‚Äôt do this Git Bash will not work properly, requiring you to remove the Git Bash installation, re-run the installer and to select the ‚ÄúGit from the command line and also from 3rd-party software‚Äù option.). e) Ensure that ‚ÄúUse the native Windows Secure Channel Library‚Äù is selected and click on ‚ÄúNext‚Äù. f) Ensure that ‚ÄúCheckout Windows-style, commit Unix-style line endings‚Äù is selected and click on ‚ÄúNext‚Äù. g) Ensure that ‚ÄúUse Windows‚Äô default console window‚Äù is selected and click on ‚ÄúNext‚Äù. h) Ensure that ‚ÄúDefault (fast-forward or merge) is selected and click ‚ÄúNext‚Äù. i) Ensure that ‚ÄúGit Credential Manager Core‚Äù is selected and click on ‚ÄúNext‚Äù. j) Ensure that ‚ÄúEnable file system caching‚Äù is selected and click on ‚ÄúNext‚Äù. k) Click on ‚ÄúInstall‚Äù. l) Click on ‚ÄúFinish‚Äù or ‚ÄúNext‚Äù. . | If your ‚ÄúHOME‚Äù environment variable is not set (or you don‚Äôt know what this is): a) Open command prompt (Open Start Menu then type cmd and press Enter). b) Type the following line into the command prompt window exactly as shown: setx HOME &quot;%USERPROFILE%&quot;. c) Press Enter, you should see SUCCESS: Specified value was saved. d) Quit command prompt by typing exit then pressing Enter. | This will provide you with both Git and Bash in the Git Bash program. . Mac OS X - video tutorial . For macOS, install Git for Mac by downloading and running the most recent ‚Äúmavericks‚Äù installer from this list. Because this installer is not signed by the developer, you may have to right click (control click) on the .pkg file, click Open, and click Open on the pop up window. After installing Git, there will not be anything in your /Applications folder, as Git is a command line program. For older versions of OS X (10.5-10.8) use the most recent available installer labelled ‚Äúsnow-leopard‚Äù available here. . The default shell in some versions of macOS is Bash, and Bash is available in all versions, so no need to install anything. You access Bash from the Terminal (found in /Applications/Utilities). See the video tutorial in the link above for an example on how to open the Terminal. You may want to keep Terminal in your dock. . To see if your default shell is Bash type echo $SHELL in Terminal and press the Return key. If the message printed does not end with ‚Äò/bash‚Äô then your default is something else and you can run Bash by typing bash. . If you want to change your default shell, see this Apple Support article and follow the instructions on ‚ÄúHow to change your default shell‚Äù. . A browser for Jupyter . We will teach Python using the [Jupyter notebook][https://jupyter.org/], a programming environment that runs in a web browser. Jupyter requires a reasonably up-to-date browser, preferably a current version of Chrome, Safari, or Firefox (note that Internet Explorer version 9 and below are not supported). Jupyter was installed as part of the Anaconda package for Python. . How-to launch a Jupyter Notebook . To check that this software has installed correctly, open Git bash (or terminal) and type the command: . $ jupyter notebook . You should launch the Jupyter Notebook in the folder where you want to save your notebook files. You can find this folder using the Unix commands cd (change directory) and pwd (print working directory). We will learn more about these commands in a the lesson Python scripts and the Unix terminal . You should see a file browser pop up as a new tab on your browser. Select new and you should see Python 3 listed as an option. Clicking on this will create a new Python 3 notebook file. . How to start the command line Python interpreter . To start the Python interpreter without the notebook, you can open a terminal or Git Bash and type the command: . $ python .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Setup.html",
            "relUrl": "/2021/08/02/Setup.html",
            "date": " ‚Ä¢ Aug 2, 2021"
        }
        
    
  
    
        ,"post7": {
            "title": "Python scripts and the Unix terminal",
            "content": "Python scripts and the Unix terminal .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Scripting.html",
            "relUrl": "/2021/08/02/Scripting.html",
            "date": " ‚Ä¢ Aug 2, 2021"
        }
        
    
  
    
        ,"post8": {
            "title": "Runge-Kutta method",
            "content": ". Questions: . How do I use the Runge-Kutta method for more accurate solutions? | . Objectives: . Use the Runge-Kutta method, implemented in Python, to solve a first-order ODE | Compare results at different levels of approximation using the matplotlib library. | . . The Runge-Kutta method is more accurate than Euler&#39;s method and runs just as fast . So far we have used Euler&#39;s method for solving ODEs. We have learnt that, using this method, the final expression for the total error is linear in $h$. However for roughly the same compute time we can reduce the total error so it is of order $h^2$ by implementing another method - the Runge-Kutta method. . Note: It is common to use the Runge-Kutta method for solving ODEs given the improved accuracy over Euler&#8217;s method. However Euler&#8217;s method is still commonly used for PDEs (where there are other, larger, sources of error). &gt; Info:The Runge-Kutta method is actually a family of methods. In fact, Euler&#39;s method is the first-order Runge-Kutta method. There is then the second-order Runge-Kutta method, third-order Runge-Kutta method, and so on.. . Euler&#39;s method does not take into account the curvature of the solution, whilst Runge-Kutta methods do, by calculating the gradient at intermediate points in the (time-)step. For example, in the image below we see two estimates to the blue line. Euler&#39;s method is equivalent to the orange line, where we have taken the slope at time $t$ and extrapolated it to $t+h$. A Runge-Kutta type method performs extrapolation using the slope (or slopes) at an intermediate time (or multiple intermediate times). In this case, the green line formed from the slope at $t+ frac{h}2$ gives a better approximation at $t+h$. This green line is a visual representation of the second-order Runge Kutta method, which is also known as the &quot;midpoint method&quot;. . . Runge-Kutta methods are derived from Taylor expansion(s) around intermediate point(s) . To derive the second-order Runge-Kutta method we: . 1) estimate $x(t+h)$ using a Taylor expansion around $t+ frac{h}{2}$: . begin{equation} x(t+h) = x(t+ frac{h}{2}) + frac{h}{2} left( frac{ mathrm{d}x}{ mathrm{d}t} right)_{t+ frac{h}{2}} + frac{h^2}{8} left( frac{ mathrm{d}^2x}{ mathrm{d}t^2} right)_{t+ frac{h}{2}}+ mathcal{O}(h^3) end{equation}2) estimate $x(t)$ using a Taylor expansion around $t+ frac{h}{2}$: . begin{equation} x(t) = x(t+ frac{h}{2}) - frac{h}{2} left( frac{ mathrm{d}x}{ mathrm{d}t} right)_{t+ frac{h}{2}} + frac{h^2}{8} left( frac{ mathrm{d}^2x}{ mathrm{d}t^2} right)_{t+ frac{h}{2}}+ mathcal{O}(h^3) end{equation}3) Subtract Equation 2 from Equation 1 and re-arrange: . begin{eqnarray} x(t+h) &amp;=&amp; x(t) + h left( frac{ mathrm{d}x}{ mathrm{d}t} right))_{t+ frac{h}{2}}+ mathcal{O}(h^3) x(t+h) &amp;=&amp; x(t) + hf(x(t+ frac{h}{2}),t+ frac{h}{2})+ mathcal{O}(h^3) end{eqnarray}Note that the $h^2$ term has completely disappeared, and the error term is now order $h^3$. We can say that this approximation is now accurate to order $h^2$. . The problem is that this requires knowledge of $x(t+ frac{h}{2})$ which we don&#39;t currently have. We can however estimate this using the Euler method! . begin{equation} x(t+ frac{h}{2}) = x(t) + frac{h}{2}f(x,t). end{equation}Substituting this into Equation 3 above, we can write the method for a single step as follows: . begin{eqnarray} k_1 &amp;=&amp; hf(x,t) k_2 &amp;=&amp; hf(x+ frac{k_1}{2},t+ frac{h}{2}) x(t+h) &amp;=&amp; x(t) + k_2 end{eqnarray}See how $k_1$ is used to give an estimate for $x(t+ frac{h}{2})$ ($k_2$), which is then substituted into the third equation to give an estimate for $x(t+h)$. . Info:Higher orde Runge-Kutta methods can be derived in a similar way - by calculating the Taylor series around various points and then taking a linear combination of the resulting expansions. As we increase the number of intermediate points, we increase the accuracy of the method. The downside is that the equations get increasingly complicated. . Runge-Kutta methods can be applied using the Python skills we have developed . To demonstrate the Runge-Kutta method with a simple example, we will re-visit the differential equation for nuclear decay. We will model the decay process over a period of 10 seconds, with the decay constant $ lambda=0.1$ and the initial condition $N_0 = 1000$: . begin{equation} frac{ mathrm{d}N}{ mathrm{d} t} = -0.1 N end{equation} First, let&#39;s import the standard scientific libraries we will be using - Numpy and Matplotlib: . import numpy as np import matplotlib.pyplot as plt . Let&#39;s definte the function $f(N,t)$ which describes the rate of decay. In this case, the function depends only on the number of atoms present. . def f(Num_atoms): return -0.1*Num_atoms . Next we&#39;ll list the simulation parameters: start time, end time, number of time steps and step size (which is calculated using the number of time steps). For comparison, these will be the same as we used for Euler&#39;s method. . a = 0 # start time b = 10 # end time num_steps = 5 # number of time steps h = (b-a) / num_steps # time step size . We then specify the initial conditions - which in this case is the number of atoms to begin with: . Num_atoms = 1000 # initial condition . We use the Numpy arange function to generate a list of evenly spaced times at which to evaluate the number of atoms. We also create an empty list to hold the values for $N$ over time. . time_list = np.arange(a,b,h) # create an empty list to hold the calculated N values Num_atoms_list = [] . Finally, we apply second-order Runge-Kutta method using a For loop. . for time in time_list: Num_atoms_list.append(Num_atoms) k1 = h*f(Num_atoms) k2 = h*f(Num_atoms+0.5*k1) Num_atoms += k2 . We can easily compare our various models using the matplotlib plotting library . Using the analytic solution from a previous lesson, we can define a function for calculating the number of atoms $N$ as a function of time (this is the exact solution). . def analytic_solution(time): return 1000*np.exp(-0.1*time) . We can use this to calculate the exact value for $N$ over the full time range. We use a large number of points in time (in this case 1000) to give a nice smooth curve - note that we have renamed the variables for the analytic case so we do not override the original calculation parameters. . num_steps_analytic = 1000 h_analytic = (b-a) / num_steps_analytic time_analytic_list = np.arange(a,b,h_analytic) Num_atoms_analytic_list = [] for time in time_analytic_list: Num_atoms_analytic_list.append(analytic_solution(time)) . We can also re-calculate the atom population using Euler&#39;s method for comparison to the Runge-Kutta method: . Num_atoms = 1000 Num_atoms_euler_list = [] for time in time_list: Num_atoms_euler_list.append(Num_atoms) Num_atoms += h*f(Num_atoms) . Finally we plot all three models side-by-side: . plt.plot(time_analytic_list,Num_atoms_analytic_list,label=&quot;analytic&quot;) plt.scatter(time_list, Num_atoms_list,label=&quot;Runge-Kutta (second-order)&quot;) plt.scatter(time_list, Num_atoms_euler_list,label=&quot;Euler&#39;s method&quot;) plt.xlabel(&quot;time&quot;) plt.ylabel(&quot;Number of atoms&quot;) plt.legend() . &lt;matplotlib.legend.Legend at 0x12a014e20&gt; . Keypoints: . The Runge-Kutta method is more accurate than Euler&#39;s method and runs just as fast | Runge-Kutta methods are derived from Taylor expansion(s) around intermediate point(s) | Runge-Kutta methods can be applied using the Python skills we have developed | We can easily compare our various models using the matplotlib plotting library | . . Do the quick-test. . Back to Modelling with Ordinary Differential Equations. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Runge-Kutta.html",
            "relUrl": "/2021/08/02/Runge-Kutta.html",
            "date": " ‚Ä¢ Aug 2, 2021"
        }
        
    
  
    
        ,"post9": {
            "title": "Python part two - extension activity",
            "content": "The Madelung constant . Taken from Mark Newman‚Äôs book ‚ÄúComputational Physics, p. 74 . The Madelung constant gives the total electric potential felt by an atom in a solid. It depends on the charge and position of other nearby atoms. . Consider the compound sodium chloride. These are arranged on a cubic lattice, with sodium having a positive charge ($+e$) and chlorine having a negative charge ($-e$). If each atom position is given by integers $(i,j,k)$ then the sodium atoms are at positions where $i+j+k$ is even and the chlorine atoms are at positions where $i+j+k$ is odd. . . For an atom at $i=j=k=0$, the Madelung constant $M$ can be approximated by using the following formulae: . $V_ mathrm{total} = sum_{i,j,k} V(i,j,k) = frac{e}{4 pi epsilon_0a}M$ . $V(i,j,k) = pm frac{e}{4 pi epsilon_0r}$ . where $r$ is the distance from the origin to the atom at position $(i,j,k)$ and $a$ is the atom spacing. The summation runs from $i,j,k=-L$ to $i,j,k=L$ but not including $i,j,k=0$ (otherwise the expression would ‚Äúblow up‚Äù). . a) Write an expression (in Markdown/LaTeX) for the distance $r$ in terms of $i$,$j$,$k$ and $a$. . b) Calculate the Madelung constant for sodium chloride using a large a value as L as you can (so the code runs in about a minute or less). How does it compare with published values? . . Back to Python part two. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Python_two_extension.html",
            "relUrl": "/2021/08/02/Python_two_extension.html",
            "date": " ‚Ä¢ Aug 2, 2021"
        }
        
    
  
    
        ,"post10": {
            "title": "Python part two - exercises",
            "content": "A function to calculate standard errors . In experimental work it is common for a quantity of interest to be calculated from a combination of direct measurements. It is important to remember that all experimentally measured quantities present an uncertainty that will affect the final result. . The uncertainty is determined by the measurement instrument and settings. For example, if we measure a triangle with a caliper (resolution 0.1mm) we will get a more accurate value than if we use a ruler (resolution 1mm). But remember that whichever instrument we use we will introduce some amount of uncertainty. . The table below outlines how the standard error can be obtained from the uncertainty associated with individual measurements. . Calculation Standard error . Z = A+B | $( Delta Z)^2 = ( Delta A)^2 + ( Delta B)^2$ | . Z = A-B | $( Delta Z)^2 = ( Delta A)^2 + ( Delta B)^2$ | . Z = AB | $ left( frac{ Delta Z}{Z} right)^2 = left( frac{ Delta A}{A} right)^2 + left( frac{ Delta B}{B} right)^2$ | . Z = frac{A}{B} | $ left( frac{ Delta Z}{Z} right)^2 = left( frac{ Delta A}{A} right)^2 + left( frac{ Delta B}{B} right)^2$ | . a) Write a function which calculates the perimeter of a triangle and the standard error associated with this perimeter. The function argument will specify the length of each triangle side and the uncertainty associated with each measurement. . b) Using conditionals, write a function which calculates the standard error for any of the operations listed in the table. The function arguments will specify $A$, $B$, $ Delta A$, $ Delta B$ and the operation type. . The emission lines of hydrogen . Taken from Mark Newman‚Äôs book ‚ÄúComputational Physics, p. 73 . There is a simple and famous formula for calculating the wavelengths $ lambda$ of the emission lines of the hydrogen atom. . $ frac{1}{ lambda} = R left( frac{1}{m^2} - frac{1}{n^2} right),$ . where R is the Tydberg constant ($R = 1.097 times 10^{-2} mathrm{nm}^{-1}$) and $m$ and $n$ are positive integers and $n&gt;m$. . a) Write a piece of code to calculate the Lyman series ($m=1$), Balmer series ($m=2$) and Paschen series ($m=3$). . . Back to Python part two. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Python_two_exercises.html",
            "relUrl": "/2021/08/02/Python_two_exercises.html",
            "date": " ‚Ä¢ Aug 2, 2021"
        }
        
    
  
    
        ,"post11": {
            "title": "Python part one - extension activity",
            "content": "Reading code . You can learn a lot from reading other people‚Äôs code. Take a look at the code for carbon_calculator.py: https://github.com/lucydot/scripts/blob/master/bitsbobs/carbon_calculator.py. . You will recognise some of the Python syntax used, other parts you may not recognise (though we will cover this syntax by the end of the course). . a) Using the internet (Python documentation, stack overflow, tutorials) can you unpick what the function read_file does? Could explain this to a non-expert? . b) When this script is run from the command line, the function carbon_calculator is called. Using the internet can you unpick what this function does (and so what the programme does as a whole)? Could you explain this to a non-expert? . c) Can you suggest ways in which the carbon_calculator.py programme might be improved? . . Back to Python part one. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Python_one_extension.html",
            "relUrl": "/2021/08/02/Python_one_extension.html",
            "date": " ‚Ä¢ Aug 2, 2021"
        }
        
    
  
    
        ,"post12": {
            "title": "Python part one - exercises",
            "content": "Altitude of a satellite . Adapted from Mark Newman‚Äôs book ‚ÄúComputational Physics, p. 30 . A satellite is launched into a circular orbit around the earth so that it orbits the planet once every $T$ seconds. The altitude $h$ above the Earth‚Äôs surface that the satellite must have is: . $ h = left( frac{GMT^2}{4 pi^2} right)^{ frac{1}{3}} - R$ . where $G$ is Newton‚Äôs gravitational constant, $M$ is the mass of the Earth, and $R$ is the radius. . a) Write a piece of code which calculates the altitude $h$ (in metres) for a given value of $T$ (in seconds). . b) Use this code to calculate the altitude of satellites that orbit the Earth once a day (a ‚Äúgeosynchronous‚Äù orbit) and once every 45 minutes. What can you conclude from this final calculation? . . Back to Python part one. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Python_one_exercises.html",
            "relUrl": "/2021/08/02/Python_one_exercises.html",
            "date": " ‚Ä¢ Aug 2, 2021"
        }
        
    
  
    
        ,"post13": {
            "title": "Python part two",
            "content": "This lesson is part two of an introduction to programming in Python for people with little or no previous programming experience. This lesson references the Jupyter Notebook, but can be followed using a regular Python interpreter as well. Please note that this lesson, like all others in the course, uses Python 3 rather than Python 2. . Before you begin . Check that Python and Jupyter Notebook are installed | Launch a Jupyter notebook | . Please see the Setup page for more details. . Lesson outline . Topic Objective Quick test . For loops | How can I make a program do many things? | :ram: | . Conditionals | How can programs do different things for different data? | :mouse: | . Writing functions | How can I create my own functions? | :palm_tree: | . Variable scope | How do function calls actually work? How can I determine where errors occurred? | :mushroom: | . Libraries | How can I use software that other people have written? How can I find out what that software does? | :cactus: | . Resources . Lesson exercises | Extension exercise | Presentation | .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Python_basics_two.html",
            "relUrl": "/2021/08/02/Python_basics_two.html",
            "date": " ‚Ä¢ Aug 2, 2021"
        }
        
    
  
    
        ,"post14": {
            "title": "Python part one",
            "content": "This lesson is part one of an introduction to programming in Python for people with little or no previous programming experience. This lesson references the Jupyter Notebook, but can be followed using a regular Python interpreter as well. Please note that this lesson, like all others in the course, uses Python 3 rather than Python 2. . Before you begin . Check that Python and Jupyter Notebook are installed | Launch a Jupyter notebook | Think about the folder (directory) structure you will use for this course. The following structure is recommended: OneDrive -&gt; KD5081_Comp -&gt; Notebooks. | . Please see the Setup page for more details. . Lesson outline . Topic Objective Quick test . Running python | How can I run Python programs? | :running: | . Variables and assignment | How can I store data in programs? | :nail_care: | . Data types and type conversion | What kinds of data do programs store? How can I convert one type to another? | :dancer: | . Built-in functions, help and errors | How can I use built-in functions? How can I find out what they do? What kind of errors can occur in programs? | :droplet: | . Lists | How can I store multiple values? | :ear: | . Resources . Lesson exercises | Extension exercise | Presentation | .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Python_basics_one.html",
            "relUrl": "/2021/08/02/Python_basics_one.html",
            "date": " ‚Ä¢ Aug 2, 2021"
        }
        
    
  
    
        ,"post15": {
            "title": "Modelling Partial Differential Equations",
            "content": "It is a curious historical fact that modern quantum mechanics began with two quite different mathematical formulations: the differential equation of Schroedinger and the matrix algebra of Heisenberg. - Richard Feynman . In this section of the course we will learn how to solve another type of differential equation - the partial differential equation. These are also of vital importance to a physicist as they underly quantum mechanics (via the Schroedinger equation) and electromagnetism (via Maxwell‚Äôs equations). They are also used to model heat diffusion and wave propagation, amongst other processes. . It is usually impossible to write down explicit formulas for solutions of partial differential equations, and so there is a vast amount of research dedicated to solving these equations using computers. In this lesson we will start to explore some of these numerical approaches, with a focus on understanding the underlying mathematical methods used rather than importing pre-made functions. . Before you begin . Check that Python and Jupyter Notebook are installed | Launch a Jupyter notebook | . Please see the Setup page for more details. . Lesson outline . Topic Objective Quick test . Heat diffusion | How can I describe heat diffusion using a PDE? What are the del and Laplacian operators? | üç´ | . Finite difference methods | How do I use the finite difference method to calculate derivatives? | :evergreen_tree: | . Heat diffusion revisited | How do I combine the finite difference and Euler methods to solve a second order PDE? | :chestnut: | . Evaluating the accuracy of numerical methods | How can I quantify the accuracy of these numerical methods? | :wrench: | . Course resources . Lesson exercises | Extension exercise | Presentation | Teaching notes | . External resources . youtube: https://youtu.be/ly4S0oi3Yz8 youtube: https://youtu.be/ToIXSwZ1pJU .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/PDEs.html",
            "relUrl": "/2021/08/02/PDEs.html",
            "date": " ‚Ä¢ Aug 2, 2021"
        }
        
    
  
    
        ,"post16": {
            "title": "Build-your-own website",
            "content": "Questions: . How can I create a project website? | . Objectives: . Differentiate between git, Github and Github pages | Use Github pages and html to create a very simple website | Use Github pages and markdown to create a very simple website | Customise the website using the _config.yml file | Use Github pages, markdown and Jekyll to create a multipage website | . Keypoints: . Github pages is a static site hosting service that takes HTML files from a Github repository and publishes a website. | We can create a simple website in three short steps. | Github pages can be combined with a variety of static site generators to create a customised website. | A single page project site can be created using an README.md file on the gh-pages branch. | Github pages combined with Jekyll front matter can be used to create quick multipage sites. | Github has a range of Jekyll themes to choose from. | To access a wider range of themes and customisation options you can add a _config.yml file. | Other static site generators can be combined with Github actions for more flexibility. | . Github pages takes HTML files from a Github repository and publishes a website. . First we should differentiate between three similar sounding tools: Git is an open-source version control system that can be used online or locally. | Github is a website (owned by Microsoft) that is built on top of git. It can be used to store and share files in project repositories. | Github pages is a service provided by Github. Github pages takes HTML from a repository and publishes it as a website. | . | . Note: Github is not the only option for hosting your code. Other services include Gitlab (which is an open source project) and Bitbucket. . We can create a simple website in three short steps . To see the most simple example of how Github pages works we can create 1) create a repository 2) create a gh-pages branch and 3) add a html file. . | Step 1: Create a repository . Register for a Github account (if you do not already have one) and login | Create a new repository by clicking the plus sign at the top-right hand corner | Give your repository a name e.g. website-example | Give your repository a description e.g. A simple example of a website generated using gh-pages | Select Add a README file | Select Choose a license and select a license | Click Create repository | . | . Important: You don‚Äôt need to select a license at this stage but it‚Äôs recommended that you do. The MIT License is a popular choice as it is simple and permissive (people do almost anything they want with your project). If you are not clear which license to use you can visit https://choosealicense.com/. . Step 2: Create a gh-pages branch Click main towards the top-left hand corner | Type gh-pages into the text box (Find or create a branch) | Select `Create branch: gh-pages from ‚Äòmain‚Äô | . | . A branch in Git is similar to the branch of a tree. A tree branch is attached to the main part of the tree. While branches can generate and fall off, the main central part of the tree continues. Similarly, a branch in Git is a way of developing new features or fixing bugs without affecting the main part of the project (the main branch). The main branch is created when we create the git repository. . Important: Github pages will automatically publish any html on the gh-pages branch only. . Step 3: Click Add file (make sure you are on the gh-pages branch) | Click Create new file | Name the file Hello-world.html | Paste the following code | . | . &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Hello World!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Soooo nice to meet you.&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; . Click Commit new file | . You can access your project webpages using the address format username.github.io/repository-name/filename.html. If you have followed the suggested naming in this example you can access your Hello-world webpage at https://username.github.io/website-example/Hello-world.html . Github pages can be combined with a variety of static site generators to create a customised website. . It would take a lot of time to write our website using html (unless we want a really, really simple website) | Instead there are several static site generators which will take plain text files (formatted using a markup language such as markdown or reStructuredText) and convert these into html. | Examples of static site generators include: Jekyll, which is used by the Software Carpentry organisation: https://swcarpentry.github.io/python-novice-inflammation/ | Mkdocs, which is used to create documentation sites, for example this one for the University of Northumbria research computing community (developed by an undergraduate student in the CIS department): https://rsc-northumbria.github.io/oswald-docs/ | hugo which can be used for developing personal or professional webpages: https://lucydot.github.io | . | Each type of static site generator comes with a range of templates to use for customising your website. | Any static site generator can be combined with Github pages to create a website. We will use Jekyll as this has extra integration support from Github pages. | . A single page project site is created using the README.md file on the gh-pages branch. . In fact, Github has already used the Jekyll static site generator behind the scenes to convert your repository README.md file to html. You can access this at https://username.github.io/website-example/. | We can edit and commit changes to the README.md and our webpage will be updated. Click on the pencil icon on your repository landing page | Edit the file using markdown, e.g. The website can be accessed [here](https://lucydot.github.io/website-example/Hello-world.html). | Under Commit changes write a commit message title e.g. Include a link the website. | Click on Commit changes to save (version control) the changes made. | The changes should be reflected on the webpage: https://username.github.io/website-example/ | . | . Github pages combined with Jekyll front matter can be used to create a multipage sites. . Github pages will automatically convert any markdown file on the gh-pages branch using Jekyll if it contains top-matter in a particular format. In your repository click on Add file and Create new file | Name the file Code-of-Conduct.md | Paste the following front matter and content into the file | . | . title: Code of Conduct Welcome to the Build-your-own website page. The first rule is: Be Nice! . Click Commit new file | You can see your new webpage at https://username.github.io/website-example/Code-of-Conduct. | . Important: The three dashes at the top and bottom of your front matter are very important. If your file does not start with front matter in this format Jekyll will not convert the file to html. . The front matter contains predefined global variables or custom variables. In this example, we have specified what the value of the title variable is. We can then access this variable in the main body of the page. | If you don‚Äôt want to define any variables you can always leave it empty - but you must include the two sets of triple dashed lines. | At this stage you may also want to update your README.md with links to the Hello-world webpage and the Code of Conduct. | . Info: The Code of Conduct we use here is a silly example. However for many projects and initiatives having a Code of Conduct is important. There is more information on this page. . Github has a range of Jekyll themes to choose from. . You can add a theme to your GitHub Pages site to customize your site‚Äôs look and feel. | There are a range of Jekyll themes that Github pages has built-in support for. To change the theme you can use the following steps: In your repository click on Settings | Click on Pages in the left navigation bar | Click on Choose a theme | Choose a theme to preview | Click Select theme | . | . Note: The theme will only be applied to the README.md or webpages with the Jekyll front matter. . Note: When you select a new theme the _config.yml file in your repository is automatically updated. . To access a wider range of customisation options you can fork a Jekyll template and edit the _config.yml file. . For example, you can follow the steps outlined for the beautiful-jekyll blog template: Fork (copy) the beautiful-jekyll template by clicking on the Fork button at the top right corner of the page | Under the repository Settings rename the project repository e.g. improved-website | Under the repository Settings-&gt;Github Pages choose the gh-pages branch as the source | . | This will create a website at https://username.github.io/improved-website. | To customise edit the _config.yml file | To add content edit the markdown files (see the beautiful-jekyll docs for more information). | . For more flexibility you can combine other static site generators can be combined with Github actions . . Any static site generator can be combined with Github pages to create a website. | For example, the Northumbria Research Computing Community website was built using MkDocs framework, Github Pages and Github Actions to build the webpages. The main branch of the corresponding Github repo has a mkdocs.yml file that specifies the theme, plugins used and website navigation | The main branch has a docs folder containing the website content as markdown files. In the root of the docs folder is the homepage index.md. | The main branch contains a file .github/workflows/build-docs.yml which specifies how to build and deploy the html using the markdown files | After commiting a change on the main branch, Github Actions will build the website and copy the html files to the gh-pages branch for publishing. | . | . Note: the gh-pages branch in this example includes a .nojekyll file to tell Github pages not to automatically build it using Jekyll . TASK . Use Github pages and Jekyll to create an academic website. This could include: . A landing page with a short description of your background and interests | Links to code that you have written (during this course or elsewhere) | A picture of yourself or your experimental work | . Think of it as an online CV. It is a great way to promote your work to potential employers or supervisors. .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Open_science.html",
            "relUrl": "/2021/08/02/Open_science.html",
            "date": " ‚Ä¢ Aug 2, 2021"
        }
        
    
  
    
        ,"post17": {
            "title": "Modelling Ordinary Differential Equations",
            "content": "‚ÄúSince Newton, mankind has come to realise that the laws of physics are always expressed in the language of differential equations‚Äù ‚Äì Steven Strogatz . In this section of the course we will learn how to solve ordinary differential equations. These are of vital importance to a physicist as they are at the base of classical and celestial mechanics via Newton‚Äôs equations. They are also used to model electrical circuits and radioactive decay, amongst other systems. . Broadly speaking, there are three ways to solve a differential equation: analytically, numerically (with a pre-existing function) or numerically (with a home-made function). Numerical approaches offer more flexibility but with the caveat that they are approximate and must be converged. . In this lesson we will use numerical approaches to solve ODE‚Äôs, with a strong focus on home-made numerical functions (rather than pre-made functions imported from a library). As such we will achieve a greater understanding of the underlying mathematics and approximations used - and it‚Äôs a great chance to practice our Python skills. . Before you begin . Check that Python and Jupyter Notebook are installed | Launch a Jupyter notebook | . Please see the Setup page for more details. . Lesson outline . Topic Objective Quick test . Classifying differential equations | What is the difference between an ODE and PDE? How do I classify the different types of differential equations? | :ticket: | . Radioactive decay | How can I describe radioactive decay using a first-order ODE? What are initial conditions and why are they important? | :trolleybus: | . Euler‚Äôs method | How do I use Euler‚Äôs method to solve a first-order ODE? | :blue_car: | . The strange attractor | How do I solve differential equations with more than one variable? | :truck: | . Runge-Kutta method | How do I use the Runge-Kutta method for more accurate solutions? | :red_car: | . Course resources . Lesson exercises | Extension exercise | Presentation | Teaching notes | . External resources . Youtube: https://youtu.be/p_di4Zn4wz4 Youtube: https://youtu.be/3d6DsjIBzJ4 .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/ODEs.html",
            "relUrl": "/2021/08/02/ODEs.html",
            "date": " ‚Ä¢ Aug 2, 2021"
        }
        
    
  
    
        ,"post18": {
            "title": "Classifying differential equations",
            "content": "&#128131; Classifying differential equations &#128131; . . Questions: . What is a differential equation? | What is the difference between an ordinary (ODE) and partial (PDE) differential equation? | How do I classify the different types of differential equations? | . . . Objectives: . Identify the dependent and independent variables in a differential equation | Distinguish between and ODE and PDE | Identify the order of a differential equation | Distinguish between linear and non-linear equations | Distinguish between heterogeneous and homogeneous equations | Identify a separable equation | . . A differential equation is an equation that relates one or more functions and their derivatives . The functions usually represent physical quantities (e.g. position $x$) | The derivative represents a rate of change (e.g. speed $v$) | The differential equation represents the relationship between the two: | . begin{equation} v = frac{dx}{dt} end{equation} An independent variable is... a quantity that varies independently... . An independent variable does not depend on other variables | A dependent variable depends on the independent variable | . begin{equation} v = frac{dx}{dt} end{equation} $t$ is the independent variable | $x$ is the dependent variable | Writing $x = x(t)$ makes this relationship clear. | . Differential equations can be classified in a variety of ways . There are several ways to describe and classify differential equations. There are standard solution methods for each type, so it is useful to understand the classifications. . . Once you can cook a single piece of spaghetti, you can cook all pieces of spaghetti! . An ODE contains differentials with respect to only one variable . For example, the following equations are ODEs: . begin{equation} frac{d x}{d t} = at frac{d^3 x}{d t^3} + frac{x}{t} = b end{equation}As in each case the differentials are with respect to the single variable $t$. . Partial differential equations (PDE) contain differentials with respect to several independent variables. . An example of a PDE is: . begin{equation} frac{ partial x}{ partial t} = frac{ partial x}{ partial y} end{equation}As there is one differential with respect to $t$ and one differential with respect to $y$. . Note also the difference in notation - for ODEs we use $d$ whilst for PDEs we use $ partial$. . Note: the equations in this notebook are formatted using LaTeX. . The order of a differential equation is the highest order of any differential contained in it. . For example: . $ frac{d x}{d t} = at$ is first order. . $ frac{d^3 x}{d t^3} + frac{x}{t} = b$ is third order. . Important: $ frac{d^3 x}{d t^3}$ does not equal $ left( frac{d x}{d t} right)^3$! . Linear equations do not contain higher powers of either the dependent variable or its differentials . For example: . $ frac{d^3 x}{d t^3} = at$ and $ frac{ partial x}{ partial t} = frac{ partial x}{ partial y} $ are linear. . $( frac{d x}{d t})^3 = at$ and $ frac{d^3 x}{d t^3} = x^2$ are non-linear. . Non-linear equations can be particularly nasty to solve analytically, and so are often tackled numerically. . Homogeneous equations do not contain any non-differential terms . For example: . $ frac{ partial x}{ partial t} = frac{ partial x}{ partial y}$ is a homogeneous equation. . $ frac{ partial x}{ partial t} - frac{ partial x}{ partial y}=a$ is a heterogeneous equation (unless $a=0$!). . Separable equations can be written as a product of two functions of different variables . A separable first-order one-variable differential equation takes the form . begin{equation} f(x) frac{d x}{d t} = g(t) end{equation}Separable equations are some of the easiest to solve as we can split the equation into two independent parts with fewer variables, and solve each in turn - we will see an example of this in the next lesson. . . Summary: . An independent variable is a quantity that varies independently | Differential equations can be classified in a variety of ways | An ODE contains differentials with respect to only one variable | The order is the highest order of any differential contained in it | Linear equations do not contain higher powers of either the dependent variable or its differentials | Homogeneous equations do not contain any non-differential terms | . . . Do the quick-test. . Back to Modelling with Ordinary Differential Equations. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/ODE-Types.html",
            "relUrl": "/2021/08/02/ODE-Types.html",
            "date": " ‚Ä¢ Aug 2, 2021"
        }
        
    
  
    
        ,"post19": {
            "title": "Lists",
            "content": ". Questions: . How can I store multiple values? | . Objectives: . Explain why programs need collections of values. | Write programs that create flat lists, index them, slice them, and modify them through assignment and method calls. | . Keypoints: . A list stores many values in a single structure. | Use an item&#39;s index to fetch it from a list. | Lists&#39; values can be replaced by assigning to them. | Appending items to a list lengthens it. | Use del to remove items from a list entirely. | The empty list contains no values. | Lists may contain values of different types. | Character strings can be indexed like lists. | Character strings are immutable. | Indexing beyond the end of the collection is an error. | . . A list stores many values in a single structure. . Doing calculations with a hundred variables called pressure_001, pressure_002, etc., would be at least as slow as doing them by hand. | Use a list to store many values together. Contained within square brackets [...]. | Values separated by commas ,. | . | Use len to find out how many values are in a list. | . pressures = [0.273, 0.275, 0.277, 0.275, 0.276] print(&#39;pressures:&#39;, pressures) print(&#39;length:&#39;, len(pressures)) . pressures: [0.273, 0.275, 0.277, 0.275, 0.276] length: 5 . Use an item&#39;s index to fetch it from a list. . Just like strings. | . print(&#39;zeroth item of pressures:&#39;, pressures[0]) print(&#39;fourth item of pressures:&#39;, pressures[4]) . zeroth item of pressures: 0.273 fourth item of pressures: 0.276 . Lists&#39; values can be replaced by assigning to them. . Use an index expression on the left of assignment to replace a value. | . pressures[0] = 0.265 print(&#39;pressures is now:&#39;, pressures) . pressures is now: [0.265, 0.275, 0.277, 0.275, 0.276] . Appending items to a list lengthens it. . Use list_name.append to add items to the end of a list. | . primes = [2, 3, 5] print(&#39;primes is initially:&#39;, primes) primes.append(7) primes.append(9) print(&#39;primes has become:&#39;, primes) . primes is initially: [2, 3, 5] primes has become: [2, 3, 5, 7, 9] . append is a method of lists. A method is like a function, but tied to a particular object. | Use object_name.method_name to call methods. | We will meet other methods of lists as we go along - you can use help(list) for a preview. | extend is similar to append, but it allows you to combine two lists. For example: | . teen_primes = [11, 13, 17, 19] middle_aged_primes = [37, 41, 43, 47] print(&#39;primes is currently:&#39;, primes) primes.extend(teen_primes) print(&#39;primes has now become:&#39;, primes) primes.append(middle_aged_primes) print(&#39;primes has finally become:&#39;, primes) . primes is currently: [2, 3, 5, 7, 9] primes has now become: [2, 3, 5, 7, 9, 11, 13, 17, 19] primes has finally become: [2, 3, 5, 7, 9, 11, 13, 17, 19, [37, 41, 43, 47]] . Note that while extend maintains the &quot;flat&quot; structure of the list, appending a list to a list makes the result two-dimensional. . Use del to remove items from a list entirely. . del list_name[index] removes an item from a list and shortens the list. | Not a function or a method, but a statement in the language. | . print(&#39;primes before removing last item:&#39;, primes) del primes[4] print(&#39;primes after removing last item:&#39;, primes) . primes before removing last item: [2, 3, 5, 7, 9, 11, 13, 17, 19, [37, 41, 43, 47]] primes after removing last item: [2, 3, 5, 7, 11, 13, 17, 19, [37, 41, 43, 47]] . The empty list contains no values. . Use [] on its own to represent a list that doesn&#39;t contain any values. &quot;The zero of lists.&quot; | . | Helpful as a starting point for collecting values (which we will see in the next episode). | . Lists may contain values of different types. . A single list may contain numbers, strings, and anything else. | . goals = [1, &#39;Create lists.&#39;, 2, &#39;Extract items from lists.&#39;, 3, &#39;Modify lists.&#39;] . Character strings can be indexed like lists. . Get single characters from a character string using indexes in square brackets. | . element = &#39;carbon&#39; print(&#39;zeroth character:&#39;, element[0]) print(&#39;third character:&#39;, element[3]) . zeroth character: c third character: b . Character strings are immutable. . Cannot change the characters in a string after it has been created. Immutable data types can&#39;t be changed after creation. | In contrast, lists are mutable: they can be modified in place. | . | Python considers the string to be a single value with parts, not a collection of values. | . element[0] = &#39;C&#39; . TypeError Traceback (most recent call last) /var/folders/5q/mny3pg2n7h5g21h3v32rfj9wpykqrf/T/ipykernel_11747/1676686116.py in &lt;module&gt; -&gt; 1 element[0] = &#39;C&#39; TypeError: &#39;str&#39; object does not support item assignment . Indexing beyond the end of the list or string is an error. . Python reports an IndexError if we attempt to access a value that doesn&#39;t exist. This is a kind of runtime error. | This cannot be detected as the code is parsed because the index might be calculated based on data. | . | . print(&#39;99th element of element is:&#39;, element[99]) . . Do the quick-test. . Back to Python part one. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Lists.html",
            "relUrl": "/2021/08/02/Lists.html",
            "date": " ‚Ä¢ Aug 2, 2021"
        }
        
    
  
    
        ,"post20": {
            "title": "Lists - quick test",
            "content": "Fill in the Blanks . Fill in the blanks so that the program below produces the output shown. . values = ____ values.____(1) values.____(3) values.____(5) print(&#39;first time:&#39;, values) values = values[____] print(&#39;second time:&#39;, values) . first time: [1, 3, 5] second time: [3, 5] . Show answer values = [] values.append(1) values.append(3) values.append(5) print(&#39;first time:&#39;, values) values = values[1:] print(&#39;second time:&#39;, values) . How Large is a Slice? . If ‚Äòlow‚Äô and ‚Äòhigh‚Äô are both non-negative integers, how long is the list values[low:high]? . Show answer The list values[low:high] has high - low elements. For example, values[1:4] has the 3 elements values[1], values[2], and values[3]. Note that the expression will only work if high is less than the total length of the list values. . From Strings to Lists and Back . Given this: . print(&#39;string to list:&#39;, list(&#39;tin&#39;)) print(&#39;list to string:&#39;, &#39;&#39;.join([&#39;g&#39;, &#39;o&#39;, &#39;l&#39;, &#39;d&#39;])) . [&#39;t&#39;, &#39;i&#39;, &#39;n&#39;] &#39;gold&#39; . Explain in simple terms what list(&#39;some string&#39;) does. | What does &#39;-&#39;.join([&#39;x&#39;, &#39;y&#39;]) generate? | Show answer list(&#39;some string&#39;) ‚Äúsplits‚Äù a string into a list of its characters. | x-y | Working With the End . What does the following program print? . element = &#39;helium&#39; print(element[-1]) . How does Python interpret a negative index? | If a list or string has N elements, what is the most negative index that can safely be used with it, and what location does that index represent? | If values is a list, what does del values[-1] do? | How can you display all elements but the last one without changing values? (Hint: you will need to combine slicing and negative indexing.) | Show answer The program prints m. . Python interprets a negative index as starting from the end (as opposed to starting from the beginning). The last element is -1. | The last index that can safely be used with a list of N elements is element -N, which represents the first element. | del values[-1] removes the last element from the list. | values[:-1] | Stepping Through a List . What does the following program print? . element = &#39;fluorine&#39; print(element[::2]) print(element[::-1]) . If we write a slice as low:high:stride, what does stride do? | What expression would select all of the even-numbered items from a collection? | Show answer The program prints . furn eniroulf . stride is the step size of the slice | The slice 1::2 selects all even-numbered items from a collection: it starts with element 1 (which is the second element, since indexing starts at 0), goes on until the end (since no end is given), and uses a step size of 2 (i.e., selects every second element). | Copying (or Not) . What do these two programs print? In simple terms, explain the difference between new = old and new = old[:]. . # Program A old = list(&#39;gold&#39;) new = old # simple assignment new[0] = &#39;D&#39; print(&#39;new is&#39;, new, &#39;and old is&#39;, old) . # Program B old = list(&#39;gold&#39;) new = old[:] # assigning a slice new[0] = &#39;D&#39; print(&#39;new is&#39;, new, &#39;and old is&#39;, old) . Show answer Program A prints . &gt; &gt; new is [&#39;D&#39;, &#39;o&#39;, &#39;l&#39;, &#39;d&#39;] and old is [&#39;D&#39;, &#39;o&#39;, &#39;l&#39;, &#39;d&#39;] . Program B prints . &gt; &gt; new is [&#39;D&#39;, &#39;o&#39;, &#39;l&#39;, &#39;d&#39;] and old is [&#39;g&#39;, &#39;o&#39;, &#39;l&#39;, &#39;d&#39;] . new = old makes new a reference to the list old; new and old point towards the same object. . new = old[:] however creates a new list object new containing all elements from the list old; new and old are different objects. . . See the notebook. . Back to Python basics - part one. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Lists-Qs.html",
            "relUrl": "/2021/08/02/Lists-Qs.html",
            "date": " ‚Ä¢ Aug 2, 2021"
        }
        
    
  
    
        ,"post21": {
            "title": "Libraries - quick test",
            "content": "Exploring the Math Module . What function from the math module can you use to calculate a square root without using sqrt? | Since the library contains this function, why does sqrt exist? | Show answer Using help(math) we see that we‚Äôve got pow(x,y) in addition to sqrt(x), so we could use pow(x, 0.5) to find a square root. | The sqrt(x) function is arguably more readable than pow(x, 0.5) when implementing equations. Readability is a cornerstone of good programming, so it makes sense to provide a special function for this specific common case. | Also, the design of Python‚Äôs math library has its origin in the C standard, which includes both sqrt(x) and pow(x,y), so a little bit of the history of programming is showing in Python‚Äôs function names. . Locating the Right Module . You want to select a random character from a string: . bases = &#39;ACTTGCTTGAC&#39; . Which standard library module could help you? | Which function would you select from that module? Are there alternatives? | Try to write a program that uses the function. | Show answer The random module seems like it could help you. . The string has 11 characters, each having a positional index from 0 to 10. You could use random.randrange function (or the alias random.randint if you find that easier to remember) to get a random integer between 0 and 10, and then pick out the character at that position: . from random import randrange random_index = randrange(len(bases)) print(bases[random_index]) . or more compactly: . from random import randrange print(bases[randrange(len(bases))]) . Perhaps you found the random.sample function? It allows for slightly less typing: . from random import sample print(sample(bases, 1)[0]) . Note that this function returns a list of values. We will learn about lists in episode 11. . There‚Äôs also other functions you could use, but with more convoluted code as a result. . Jigsaw Puzzle (Parson‚Äôs Problem) Programming Example . Rearrange the following statements so that a random DNA base is printed and its index in the string. Not all statements may be needed. Feel free to use/add intermediate variables. . bases=&quot;ACTTGCTTGAC&quot; import math import random ___ = random.randrange(n_bases) ___ = len(bases) print(&quot;random base &quot;, bases[___], &quot;base index&quot;, ___) . Show answer import math import random bases = &quot;ACTTGCTTGAC&quot; n_bases = len(bases) idx = random.randrange(n_bases) print(&quot;random base&quot;, bases[idx], &quot;base index&quot;, idx) . When Is Help Available? . When a colleague of yours types help(math), Python reports an error: . NameError: name &#39;math&#39; is not defined . What has your colleague forgotten to do? . Show answer Importing the math module (import math) . Importing With Aliases . Fill in the blanks so that the program below prints 90.0. | Rewrite the program so that it uses import without as. | Which form do you find easier to read? | import math as m angle = ____.degrees(____.pi / 2) print(____) . Show answer import math as m angle = m.degrees(m.pi / 2) print(angle) . can bewritten as . import math angle = math.degrees(math.pi / 2) print(angle) . Since you just wrote the code and are familiar with it, you might actually find the first version easier to read. But when trying to read a huge piece of code written by someone else, or when getting back to your own huge piece of code after several months, non-abbreviated names are often easier, except where there are clear abbreviation conventions. . There Are Many Ways To Import Libraries! . Match the following print statements with the appropriate library calls. . Print commands: . print(&quot;sin(pi/2) =&quot;,sin(pi/2)) | print(&quot;sin(pi/2) =&quot;,m.sin(m.pi/2)) | print(&quot;sin(pi/2) =&quot;,math.sin(math.pi/2)) | Library calls: . from math import sin,pi | import math | import math as m | from math import * | Show answer Library calls 1 and 4. In order to directly refer to sin and pi without the library name as prefix, you need to use the from ... import ... statement. Whereas library call 1 specifically imports the two functions sin and pi, library call 4 imports all functions in the math module. | Library call 3. Here sin and pi are referred to with a shortened library name m instead of math. Library call 3 does exactly that using the import ... as ... syntax - it creates an alias for math in the form of the shortened name m. | Library call 2. Here sin and pi are referred to with the regular library name math, so the regular import ... call suffices. | Importing Specific Items . Fill in the blanks so that the program below prints 90.0. | Do you find this version easier to read than preceding ones? | Why wouldn‚Äôt programmers always use this form of import? | ____ math import ____, ____ angle = degrees(pi / 2) print(angle) . Show answer from math import degrees, pi angle = degrees(pi / 2) print(angle) . Most likely you find this version easier to read since it‚Äôs less dense. The main reason not to use this form of import is to avoid name clashes. For instance, you wouldn‚Äôt import degrees this way if you also wanted to use the name degrees for a variable or function of your own. Or if you were to also import a function named degrees from another library. . Reading Error Messages . Read the code below and try to identify what the errors are without running it. | Run the code, and read the error message. What type of error is it? | from math import log log(0) . Show answer The logarithm of x is only defined for x 0, so 0 is outside the domain of the function. | You get an error of type ‚ÄúValueError‚Äù, indicating that the function received an inappropriate argument value. The additional message ‚Äúmath domain error‚Äù makes it clearer what the problem is. | . See the notebook. . Back to Python part two. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Libraries-Qs.html",
            "relUrl": "/2021/08/02/Libraries-Qs.html",
            "date": " ‚Ä¢ Aug 2, 2021"
        }
        
    
  
    
        ,"post22": {
            "title": "Introduction",
            "content": "This introduction in slide format is here. . Computing has become central to virtually all research and development in academia and industry, and with the advent of Machine Learning and High-Performance Computing this dominance is set to continue. . Computational physics encompasses a wide number of areas including materials modelling, particle physics simulations, protein structure prediction and plasma modelling. In fact, it is possible to find a computational branch for every major field in physics. . The focus of this course is to equip with you with the transferable skills needed for success in a range of computational disciplines, with examples tailored towards the physics domain. . This course is split into three sections - Getting started, Getting results and Getting it out there. In the first part of the course, Getting started, we will introduce programming concepts and Python libraries that are applicable to a wide range of research and industry - from game design to architecture. In the middle section of the course, which is called Getting results, we will apply these tools to model the differential equations that are so central to both classical and quantum physics. In the final section of the course, Getting it out there, we will use modern software engineering techniques to document, test and share our code. . In the final section of the course you will also hear from three guest speakers who use some of the computational skills outlined in this course in their own work. In 2021 the guest speakers are: Anna Krystalli (Research Software Engineer, Sheffield University), Adam Jackson (Computational scientist, Science and Technology Facilities Council), Felix Rehren (Director of insurance mergers and acquisitions, Athora). . How does this course relate to experimental physics? . The first part of this course covers the basic skills needed for processing experimental data using Python. At the end of Getting started you will be able to read in experimental data from a plain text file, clean the data, apply basic statistical analysis and plot. We very much encourage you to apply the tools outlined in this course to your experimental analysis. . Do I need to attend the in-person labs? . I will aim to publish all course materials on this website however a large component of this course is based around verbal explanations whilst writing code and class discussion. It will all make much more sense if you attend the sessions in the computer lab! . The details for Autumn 2021 are: . Wednesdays 9-12am | Room D211 in Ellison building | .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Introduction.html",
            "relUrl": "/2021/08/02/Introduction.html",
            "date": " ‚Ä¢ Aug 2, 2021"
        }
        
    
  
    
        ,"post23": {
            "title": "Programming good practice",
            "content": "Document your code . There are multiple ways you can document your code. In this course we will use three different methods: . Docstrings | def calc_bulk_density(mass,volume): &quot;Return dry bulk density = powder mass / powder volume.&quot; return mass / volume . Docstrings are the first statement in a module, function, class or method. . In-line comments | # bulk density is the powder mass / powder volume density = mass / volume . Markdown in a Jupyter Notebook | Focus on readability . Consistency is key | Use consistent whitespace: | spam(ham[1], {eggs: 2}) spam( ham[ 1 ], { eggs: 2} ) . Use clear, meaningful variable names (don‚Äôt just use x, p and expect the reader to know what they mean!) | The Pep 8 Style Guide for Python code has further guidance. . Think about reproducibility . Writing reproducible code is difficult. In fact, there are many interesting initiatives designed to improve reproducibility in the computational scientists, such as Reprohacks. . One straight-forward thing you can do is print the version number for each package you import using print(packagename.__version__) .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Good_practice.html",
            "relUrl": "/2021/08/02/Good_practice.html",
            "date": " ‚Ä¢ Aug 2, 2021"
        }
        
    
  
    
        ,"post24": {
            "title": "Built-in functions, help and errors",
            "content": ". Questions: . How can I use built-in functions? | How can I find out what they do? | What kind of errors can occur in programs? | . objectives: . Explain the purpose of functions. | Correctly call built-in Python functions. | Correctly nest calls to built-in functions. | Use help to display documentation for built-in functions. | Correctly describe situations in which SyntaxError and NameError occur. | . keypoints: . Use comments to add documentation to programs. | A function may take zero or more arguments. | Commonly-used built-in functions include max, min, and round. | Functions may only work for certain (combinations of) arguments. | Functions may have default values for some arguments. | Use the built-in function help to get help for a function. | The Jupyter Notebook has two ways to get help. | Every function returns something. | Python reports a syntax error when it can&#39;t understand the source of a program. | Python reports a runtime error when something goes wrong while a program is executing. | Fix syntax errors by reading the source code, and runtime errors by tracing the program&#39;s execution. | . . Use comments to add documentation to programs. . adjustment = 0.5 # Neither is this - anything after &#39;#&#39; is ignored. . A function may take zero or more arguments. . We have seen some functions already now let&#39;s take a closer look. | An argument is a value passed into a function. | len takes exactly one. | int, str, and float create a new value from an existing one. | print takes zero or more. | print with no arguments prints a blank line. Must always use parentheses, even if they&#39;re empty, so that Python knows a function is being called. | . | . print(&#39;before&#39;) print() print(&#39;after&#39;) . before after . Commonly-used built-in functions include max, min, and round. . Use max to find the largest value of one or more values. | Use min to find the smallest. | Both work on character strings as well as numbers. &quot;Larger&quot; and &quot;smaller&quot; use (0-9, A-Z, a-z) to compare letters. | . | . print(max(1, 2, 3)) print(min(&#39;a&#39;, &#39;A&#39;, &#39;0&#39;)) . 3 0 . Functions may only work for certain (combinations of) arguments. . max and min must be given at least one argument. &quot;Largest of the empty set&quot; is a meaningless question. | . | And they must be given things that can meaningfully be compared. | . print(max(1, &#39;a&#39;)) . TypeError Traceback (most recent call last) /var/folders/5q/mny3pg2n7h5g21h3v32rfj9wpykqrf/T/ipykernel_11743/2220240766.py in &lt;module&gt; -&gt; 1 print(max(1, &#39;a&#39;)) TypeError: &#39;&gt;&#39; not supported between instances of &#39;str&#39; and &#39;int&#39; . Functions may have default values for some arguments. . round will round off a floating-point number. | By default, rounds to zero decimal places. | . round(3.712) . 4 . We can specify the number of decimal places we want. | . round(3.712, 1) . 3.7 . Use the built-in function help to get help for a function. . Every built-in function has online documentation. | . help(round) . Help on built-in function round in module builtins: round(number, ndigits=None) Round a number to a given precision in decimal digits. The return value is an integer if ndigits is omitted or None. Otherwise the return value has the same type as the number. ndigits may be negative. . Python reports a syntax error when it can&#39;t understand the source of a program. . Won&#39;t even try to run the program if it can&#39;t be parsed. | . name = &#39;Feng . File &#34;/var/folders/5q/mny3pg2n7h5g21h3v32rfj9wpykqrf/T/ipykernel_11743/3103437601.py&#34;, line 2 name = &#39;Feng ^ SyntaxError: EOL while scanning string literal . age = = 52 . File &#34;/var/folders/5q/mny3pg2n7h5g21h3v32rfj9wpykqrf/T/ipykernel_11743/3760570524.py&#34;, line 2 age = = 52 ^ SyntaxError: invalid syntax . We can Look more closely at the error message: | . print(&quot;hello world&quot; . File &#34;/var/folders/5q/mny3pg2n7h5g21h3v32rfj9wpykqrf/T/ipykernel_11743/1028029194.py&#34;, line 1 print(&#34;hello world&#34; ^ SyntaxError: unexpected EOF while parsing . The message indicates a problem on first line of the input (&quot;line 1&quot;). In this case the &quot;ipython-input&quot; section of the file name tells us that we are working with input into IPython, the Python interpreter used by the Jupyter Notebook. | . | The -6- part of the filename indicates that the error occurred in cell 6 of our Notebook. | Next is the problematic line of code, indicating the problem with a ^ pointer. | . Python reports a runtime error when something goes wrong while a program is executing. . age = 53 remaining = 100 - aege # mis-spelled &#39;age&#39; . NameError Traceback (most recent call last) /var/folders/5q/mny3pg2n7h5g21h3v32rfj9wpykqrf/T/ipykernel_11743/4124232921.py in &lt;module&gt; 1 age = 53 -&gt; 2 remaining = 100 - aege # mis-spelled &#39;age&#39; NameError: name &#39;aege&#39; is not defined . Fix syntax errors by reading the source and runtime errors by tracing execution. | . The Jupyter Notebook has two additional ways to get help. . Place the cursor inside the parenthesis of the function, hold down shift, and press tab. | Or type a function name with a question mark after it: e.g. math.sqrt? | These are the same as doing e.g. help(math.sqrt) . Tip: How did we know what functions a module has and how to use them? If you are working in the IPython/Jupyter Notebook, there is an easy way to find out. If you type the name of something followed by a dot, then you can use tab completion (e.g. type math. and then press tab) to see a list of all functions and attributes that you can use. | . Every function returns something. . Every function call produces some result. | If the function doesn&#39;t have a useful result to return, it usually returns the special value None. | . result = print(&#39;example&#39;) print(&#39;result of print is&#39;, result) . . Do the quick-test. . Back to Python part one. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Functions.html",
            "relUrl": "/2021/08/02/Functions.html",
            "date": " ‚Ä¢ Aug 2, 2021"
        }
        
    
  
    
        ,"post25": {
            "title": "Built-in functions, help and errors - quick test",
            "content": "What Happens When . Explain in simple terms the order of operations in the following program: when does the addition happen, when does the subtraction happen, when is each function called, etc. | What is the final value of radiance? | radiance = 1.0 radiance = max(2.1, 2.0 + min(radiance, 1.1 * radiance - 0.5)) . Show answer 1.1 * radiance = 1.1 | 1.1 - 0.5 = 0.6 | min(randiance, 0.6) = 0.6 | 2.0 + 0.6 = 2.6 | max(2.1, 2.6) = 2.6 | | At the end, radiance = 2.6 | Spot the Difference . Predict what each of the print statements in the program below will print. | Does max(len(rich), poor) run or produce an error message? If it runs, does its result make any sense? | easy_string = &quot;abc&quot; print(max(easy_string)) rich = &quot;gold&quot; poor = &quot;tin&quot; print(max(rich, poor)) print(max(len(rich), len(poor))) . Show answer c | tin | 4 . | It throws a TypeError. The command is trying to run max(4, &#39;tin&#39;) and you can‚Äôt compare a string and an integer | Why Not? . Why don‚Äôt max and min return None when they are given no arguments? . Show answer max and min return TypeErrors in this case because the correct number of parameters was not supplied. If it just returned None, the error would be much harder to trace as it would likely be stored into a variable and used later in the program, which could lead to unintended behaviour. . . See the notebook. . Back to Python basics - part one. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Functions-Qs.html",
            "relUrl": "/2021/08/02/Functions-Qs.html",
            "date": " ‚Ä¢ Aug 2, 2021"
        }
        
    
  
    
        ,"post26": {
            "title": "For loops - quick test",
            "content": "Classifying Errors . Is an indentation error a syntax error or a runtime error? . Show answer An IndentationError is a syntax error. Programs with syntax errors cannot be started. A program with a runtime error will start but an error will be thrown under certain conditions. . Tracing Execution . Create a table showing the numbers of the lines that are executed when this program runs, and the values of the variables after each line is executed. . total = 0 for char in &quot;tin&quot;: total = total + 1 . Show answer Line no Variables . 1 | total = 0 | . 2 | total = 0 char = ‚Äòt‚Äô | . 3 | total = 1 char = ‚Äòt‚Äô | . 2 | total = 1 char = ‚Äòi‚Äô | . 3 | total = 2 char = ‚Äòi‚Äô | . 2 | total = 2 char = ‚Äòn‚Äô | . 3 | total = 3 char = ‚Äòn‚Äô | . Reversing a String . Fill in the blanks in the program below so that it prints ‚Äúnit‚Äù (the reverse of the original character string ‚Äútin‚Äù). . original = &quot;tin&quot; result = ____ for char in original: result = ____ print(result) . Show answer original = &quot;tin&quot; result = &quot;&quot; for char in original: result = char + result print(result) . Practice Accumulating . Fill in the blanks in each of the programs below to produce the indicated result. . # Total length of the strings in the list: [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;] = 12 total = 0 for word in [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]: ____ = ____ + len(word) print(total) . Show answer total = 0 for word in [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]: total = total + len(word) print(total) . # List of word lengths: [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;] = [3, 5, 4] lengths = ____ for word in [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]: lengths.____(____) print(lengths) . Show answer lengths = [] for word in [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]: lengths.append(len(word)) print(lengths) . # Concatenate all words: [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;] = &quot;redgreenblue&quot; words = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;] result = ____ for ____ in ____: ____ print(result) . Show answer words = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;] result = &quot;&quot; for word in words: result = result + word print(result) . Cumulative Sum . Reorder and properly indent the lines of code below so that they print an array with the cumulative sum of data. The result should be [1, 3, 5, 10]. . cumulative += [sum] for number in data: cumulative = [] sum += number sum = 0 print(cumulative) data = [1,2,2,5] . Show answer sum = 0 data = [1,2,2,5] cumulative = [] for number in data: sum += number cumulative.append(sum) print(cumulative) . Identifying Variable Name Errors . Read the code below and try to identify what the errors are without running it. | Run the code and read the error message. What type of NameError do you think this is? Is it a string with no quotes, a misspelled variable, or a variable that should have been defined but was not? | Fix the error. | Repeat steps 2 and 3, until you have fixed all the errors. | for number in range(10): # use a if the number is a multiple of 3, otherwise use b if (Number % 3) == 0: message = message + a else: message = message + &quot;b&quot; print(message) . Show answer message = &quot;&quot; for number in range(10): # use a if the number is a multiple of 3, otherwise use b if (number % 3) == 0: message = message + &quot;a&quot; else: message = message + &quot;b&quot; print(message) . Identifying Item Errors . Read the code below and try to identify what the errors are without running it. | Run the code, and read the error message. What type of error is it? | Fix the error. | seasons = [&#39;Spring&#39;, &#39;Summer&#39;, &#39;Fall&#39;, &#39;Winter&#39;] print(&#39;My favorite season is &#39;, seasons[4]) . Show answer seasons = [&#39;Spring&#39;, &#39;Summer&#39;, &#39;Fall&#39;, &#39;Winter&#39;] print(&#39;My favorite season is &#39;, seasons[3]) . . See the notebook. . Back to Python part two. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/For-Loops-Qs.html",
            "relUrl": "/2021/08/02/For-Loops-Qs.html",
            "date": " ‚Ä¢ Aug 2, 2021"
        }
        
    
  
    
        ,"post27": {
            "title": "Data analysis and visualisation - extension activity",
            "content": "Wave interference . Adapted from Mark Newman‚Äôs book ‚ÄúComputational Physics, p. 108 . When we drop a pebble in a pond waves travel out from the spot where it fell. The height of the waves at some time later could be represented by a sine wave, spreading out in a uniform circle. If the the pebble is dropped at $x_1,y_1$ (the centre of the circle) then the distance $r_1$ between a point $x,y$ and the pebble is: . r1=((x‚àíx1)2+(y‚àíy1)2)r_1 = sqrt((x-x_1)^2+(y-y_1)^2)r1‚Äã=( . ‚Äã(x‚àíx1‚Äã)2+(y‚àíy1‚Äã)2) . and the sine wave for the height $h$ is . h1(x,y)=h0sin‚Å°(kr1),h_1(x,y) = h_0 sin(kr_1),h1‚Äã(x,y)=h0‚Äãsin(kr1‚Äã), . where $h_0$ is the amplitdue of the waves and $k$ is the wavevector, related to the wavelength $ lambda$ by $k= frac{2 pi}{ lambda}$. . Task: Write a piece of code to make an image of the wave heights over a 1 metre square region of pond. Suppose the wavelength $ lambda=5 mathrm{cm}$ and the amplitude $h_0=1$. You can choose where the pebble drops within the 1 metre square region. To make the image first create a $500 times500$ array of values representing the height $h_0$. Then use that array to make a density plot using matplotlib.pyplot.imshow. . Now suppose that we drop two pebbles in a pond. We will now have pebble one centred at $x_1,y_1$ (as above) and pebble two at $x_2,y_2$. The distance $r_2$ between a point $x,y$ and pebble two is: . r2=((x‚àíx2)2+(y‚àíy2)2)r_2 = sqrt((x-x_2)^2+(y-y_2)^2)r2‚Äã=( . ‚Äã(x‚àíx2‚Äã)2+(y‚àíy2‚Äã)2) . and the sine wave for the height $h$ is . h2(x,y)=h0sin‚Å°(kr2).h_2(x,y) = h_0 sin(kr_2).h2‚Äã(x,y)=h0‚Äãsin(kr2‚Äã). . Assuming the waves add linearly (superpose) the total height of the surface at a point $x,y$ is . h1,2(x,y)=h0sin‚Å°(kr1)+h0sin‚Å°(kr2).h_{1,2}(x,y) = h_0 sin(kr_1)+h_0 sin(kr_2).h1,2‚Äã(x,y)=h0‚Äãsin(kr1‚Äã)+h0‚Äãsin(kr2‚Äã). . Task: Write a piece of code to make an image of the wave heights over a 1 metre square region of pond. Assume again that the wavelength $ lambda=5 mathrm{cm}$ and the amplitude $h_0=1$. You can choose where the pebbles drop but they should be $20 mathrm{cm}$ apart. To make the image first create a $500 times500$ array of values representing the height $h_0$. Then use that array to make a density plot using matplotlib.pyplot.imshow. . . Back to Data analysis and visualisation. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Data_analysis_extension.html",
            "relUrl": "/2021/08/02/Data_analysis_extension.html",
            "date": " ‚Ä¢ Aug 2, 2021"
        }
        
    
  
    
        ,"post28": {
            "title": "Data analysis and visualisation - exercises",
            "content": "Error bars . In [Python part two] you wrote a function to calculate the perimeter of a triangle and the associated standard error. . a) Use this function to plot the perimeter of an equilateral triangle as a function of side length. Use the following side lengths: 3.1cm, 6.7cm, 9.2cm, 12.4cm and assume you use. Think carefully about the type of plot: should it be a scatter plot or line plot? . b) Re-plot this data with attached error bars using the matplotlib.pyplot.errorbar function . Calculating Planck‚Äôs constant . Adapted from Mark Newman‚Äôs book ‚ÄúComputational Physics, p. 124 . When light is shone on the surface of a metal, the photons in the light can excite (transfer energy to) electrons in the metal and, sometimes, eject them from the surface into the free space above. The energy of the ejected electron can be calculated by measuring the minimum voltage $V$ that stops the electron moving. . We know that the energy of an ejected electron is equal to the energy of the photon that excited it minus the workfunction $ phi$ (which is the energy needed to remove it from the surface) and that the energy of a single photon is $hf$ where $h$ is Planck‚Äôs constant and $f$ is the frequency of light. Mathematically this can be expressed as: . eV=hf‚àíœïeV = hf - phieV=hf‚àíœï, . where $e$ is the charge of the electron. . a) Read in the photoelectric measurement data from the file Planck.txt. The first column contains frequencies $f$ is hertz and the second column contains voltages $V$. Use this data to plot $V$ vs $f$. Think about the plot type - does a scatter plot of line plot make most sense? . The least-squares method is very commonly used for fitting a polynomial to a set of data. As it is so prevalent in physics and engineering, you are encouraged to watch this video which give an intuitive and mathematical description of the method. . b) Fit a straight line (polynomial of degree one) to the data using the least-squares method implemented in numpy.polyfit. Overlay this line on your data points. . c) Using the gradient of the fitted line calculate a value for Planck‚Äôs constant. Compare this to values you can find online. . Line fitting . In the code below we calculate the velocity of a ball between times 0 and 10 and store it as a numpy array . import numpy g = 9.81 velocity_list = numpy.zeros(50) v_0 = 0 for index,time in enumerate(numpy.linspace(0,10,50)): velocity_list[index] = v_0 + g*time . We can fit a polynomial to this data using the numpy.polyfit function. In this case, we know from looking at the equation that is is a first order polynomial (straight line). . fit = numpy.polyfit(numpy.linspace(0,10,50), velocity_list, 1) print(fit) . What is the gradient and intercept of the straight line fit? Does this make physical sense? Make a scatter plot of velocity vs time. Label the x-axis and y-axis (with units) and give the plot a title. . Show answer The gradient is equal to the acceleration of the ball which is given by the gravitational constant $g$. The intercept is the starting velocity of the ball, which in this example is zero. . import matplotlib.pyplot as plt plt.scatter(numpy.linspace(0,10,50),velocity_list) plt.xlabel(&quot;Time (s)&quot;) plt.ylabel(&quot;Velocity (m/s)&quot;) plt.title(&quot;Velocity of an object accelerated by gravity&quot;) . Use the polyval function to generate and plot velocities over the timeframe 30 to 100 seconds. . Show answer import matplotlib.pyplot as plt time_range = numpy.linspace(30,100,70) plt.plot(time_range,np.polyval(fit,time_range)) plt.xlabel(&quot;Time (s)&quot;) plt.ylabel(&quot;Velocity (m/s)&quot;) plt.title(&quot;Velocity of an object accelerated by gravity&quot;) . Error bars and exponential growth . This question is partly modelled on the a blog post. There is also a nice 3Blue1Brown video on exponential growth in the context of Covid. . We have the following (hypothetical) data for the growth in Covid cases at a university over a two-week period . import numpy as np day = np.arange(0,14) case_numbers = np.array([2,3,4,8,15,32,65,128,253,512,1025,2049,4090,8191,16387]) . Assuming that the growth is exponential, fit a straight line to the log of the case number data and predict the exponential growth factor. . Show answer From scanning the blog post we can see that the growth factor is the base of the exponential. Assuming the growth is exponential, to generate a straight-(ish) line we first need to take a logarithm of the case values data. We can then fit a straight line to this to calculate the logarithm of the growth factor. . log_growth_factor, log_starting_case_number = np.polyfit(day,np.log(case_numbers),1) growth_factor = np.exp(log_growth_factor) . From inspecting the data, does the calculated growth factor make sense? . Show answer The data roughly doubles each day. The calculated growth factor is 1.94, which is reassuringly close to 2. . . Back to Data analysis and visualisation. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Data_analysis_exercises.html",
            "relUrl": "/2021/08/02/Data_analysis_exercises.html",
            "date": " ‚Ä¢ Aug 2, 2021"
        }
        
    
  
    
        ,"post29": {
            "title": "Data analysis and visualisation",
            "content": "In this lesson we focus on one extended example: parsing, analysing and plotting UV-Vis data. . Before you begin . Download the UV-Vis data into a data sub-directory: UVVis-01.csv | Check that Python and Jupyter Notebook are installed | Launch a Jupyter notebook | . Please see the Setup page for more details. . During the first tutorial you will generate a file called UVVis-01-cleaned.csv. It is also available for download here. . Lesson outline . Topic Objective Quick test . Reading Data with Pandas | How can I import and clean my data? | :mag: | . Analysing Data with NumPy | How can I analyse my data? | :flashlight: | . Visualising Data with Matplotlib | How can I plot my data? | :paperclip: | . Resources . Lesson exercises | Extension exercise | Presentation | .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Data_analysis.html",
            "relUrl": "/2021/08/02/Data_analysis.html",
            "date": " ‚Ä¢ Aug 2, 2021"
        }
        
    
  
    
        ,"post30": {
            "title": "Data types and type conversion - quick test",
            "content": "Slicing . If you assign a = 123, what happens if you try to get the second digit of a via a[1]? . Show answer Numbers are not stored in the written representation, so they can‚Äôt be treated like strings. . a = 123 print(a[1]) . TypeError: &#39;int&#39; object is not subscriptable . More slicing . What does the following program print? . atom_name = &#39;carbon&#39; print(&#39;atom_name[1:3] is:&#39;, atom_name[1:3]) . Show answer atom_name[1:3] is: ar . Even more slicing . Open a Notebook to help answer the following questions: . What does thing[low:] (without a value after the colon) do? | What does thing[:high] (without a value before the colon) do? | What does thing[:] (just a colon) do? | What does thing[-2] do? | Show answer Slices from low to the end (inclusive) | Slices from the start to high (exclusive) | Slices from the start to the end | Selects the second last element | Decimals . What type of value is 3.4? How can you find out? . Show answer It is a floating-point number (often abbreviated ‚Äúfloat‚Äù). . print(type(3.4)) . &lt;class &#39;float&#39;&gt; . Choose a Type . What type of value (integer, floating point number, or character string) would you use to represent each of the following? . Number of days since the start of the year. | Time elapsed from the start of the year until now in days. | Serial number of a piece of lab equipment. | A lab specimen‚Äôs age | Current population of a city. | Average population of a city over time. | Show answer The answers to the questions are: . Integer, since the number of days would lie between 1 and 365. | Floating point, since fractional days are required | Character string if serial number contains letters and numbers, otherwise integer if the serial number consists only of numerals | This will vary! How do you define a specimen‚Äôs age? whole days since collection (integer)? date and time (string)? | Choose floating point to represent population as large aggreates (eg millions), or integer to represent population in units of individuals. | Floating point number, since an average is likely to have a fractional part. | Division Types . In Python 3, the // operator performs integer (whole-number) floor division, the / operator performs floating-point division, and the ‚Äò%‚Äô (or modulo) operator calculates and returns the remainder from integer division: . print(&#39;5 // 3:&#39;, 5//3) print(&#39;5 / 3:&#39;, 5/3) print(&#39;5 % 3:&#39;, 5%3) . 5 // 3: 1 5 / 3: 1.6666666666666667 5 % 3: 2 . However in Python 2 (and other languages), the / operator between two integer types perform a floor (//) division. To perform a float division, we have to convert one of the integers to float. . print(&#39;5 // 3:&#39;, 1) print(&#39;5 / 3:&#39;, 1 ) print(&#39;5 / float(3):&#39;, 1.6666667 ) print(&#39;float(5) / 3:&#39;, 1.6666667 ) print(&#39;float(5 / 3):&#39;, 1.0 ) print(&#39;5 % 3:&#39;, 2) . If num_subjects is the number of subjects taking part in a study, and num_per_survey is the number that can take part in a single survey, write an expression that calculates the number of surveys needed to reach everyone once. . Show answer We want the minimum number of surveys that reaches everyone once, which is the rounded up value of num_subjects / num_per_survey. This is equivalent to performing an integer division with // and adding 1. . num_subjects = 600 num_per_survey = 42 num_surveys = num_subjects // num_per_survey + 1 print(num_subjects, &#39;subjects,&#39;, num_per_survey, &#39;per survey:&#39;, num_surveys) . 600 subjects, 42 per survey: 15 . Arithmetic with Different Types . Which of the following will print 2.0? Note: there may be more than one right answer. . first = 1.0 second = &quot;1&quot; third = &quot;1.1&quot; . first + float(second) | float(second) + float(third) | first + int(third) | first + int(float(third)) | int(first) + int(float(third)) | 2.0 * second | Show answer Answer: 1 and 4 . Complex Numbers . Python provides complex numbers, which are written as 1.0+2.0j. If val is an imaginary number, its real and imaginary parts can be accessed using dot notation as val.real and val.imag. . Why do you think Python uses j instead of i for the imaginary part? | What do you expect 1+2j + 3 to produce? | What do you expect ‚Äò4j‚Äô to be? What about 4 j or `4 + j‚Äô? &gt; | Show answer Standard mathematics treatments typically use i to denote an imaginary number. However, from media reports it was an early convention established from electrical engineering that now presents a technically expensive area to change. Stack Overflow provides additional explanation and discussion | 4+2j | 4j, syntax error, depends on the value of j | . See the notebook. . Back to Python basics - part one. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Data-Types-Qs.html",
            "relUrl": "/2021/08/02/Data-Types-Qs.html",
            "date": " ‚Ä¢ Aug 2, 2021"
        }
        
    
  
    
        ,"post31": {
            "title": "Conditionals",
            "content": "Questions: . How can programs do different things for different data? | . Objectives: . Correctly write programs that use if and else statements and simple Boolean expressions (without logical operators). | Trace the execution of unnested conditionals and conditionals inside loops. | . Keypoints: . Use if statements to control whether or not a block of code is executed. | Conditionals are often used inside loops. | Use else to execute a block of code when an if condition is not true. | Use elif to specify additional tests. | Conditions are tested once, in order. | Compound Relations Using and, or, and Parentheses. | . Use if statements to control whether or not a block of code is executed. . An if statement (more properly called a conditional statement) controls whether some block of code is executed or not. . The if statement structure is similar to a for statement: . First line opens with if and ends with a colon | Body containing one or more statements is indented (usually by 4 spaces) | . mass = 3.54 if mass &gt; 3.0: print(mass, &#39;is large&#39;) mass = 2.07 if mass &gt; 3.0: print (mass, &#39;is large&#39;) . 3.54 is large . Conditionals are often used inside loops. . There is not much point using a conditional when we know the value (as above). But conditionals can be useful when we have a collection to process. . masses = [3.54, 2.07, 9.22, 1.86, 1.71] for m in masses: if m &gt; 3.0: print(m, &#39;is large&#39;) . 3.54 is large 9.22 is large . . An else can be used following an if. This allows us to specify an alternative to execute when the if branch isn&#39;t taken. . masses = [3.54, 2.07, 9.22, 1.86, 1.71] for m in masses: if m &gt; 3.0: print(m, &#39;is large&#39;) else: print(m, &#39;is small&#39;) . 3.54 is large 2.07 is small 9.22 is large 1.86 is small 1.71 is small . Use elif to specify additional tests. . We may want to provide several alternative choices, each with its own test. We can use elif (short for &quot;else if&quot;) and a condition to specify these. An elif must always associated with an if, and it must come before the else (which is the &quot;catch all&quot;). . masses = [3.54, 2.07, 9.22, 1.86, 1.71] for m in masses: if m &gt; 9.0: print(m, &#39;is HUGE&#39;) elif m &gt; 3.0: print(m, &#39;is large&#39;) else: print(m, &#39;is small&#39;) . 3.54 is large 2.07 is small 9.22 is HUGE 1.86 is small 1.71 is small . Conditions are tested once, in order. . Python steps through the branches of the conditional in order, testing each in turn - so the ordering matters. Python does not automatically go back and re-evaluate if values change. . grade = 85 if grade &gt;= 70: print(&#39;grade is C&#39;) elif grade &gt;= 80: print(&#39;grade is B&#39;) elif grade &gt;= 90: print(&#39;grade is A&#39;) . grade is C . velocity = 10.0 if velocity &gt; 20.0: print(&#39;moving too fast&#39;) else: print(&#39;adjusting velocity&#39;) velocity = 50.0 . adjusting velocity . We can use conditionals in a loop to &quot;evolve&quot; the values of variables. . velocity = 10.0 for i in range(5): # execute the loop 5 times print(i, &#39;:&#39;, velocity) if velocity &gt; 20.0: print(&#39;moving too fast&#39;) velocity = velocity - 5.0 else: print(&#39;moving too slow&#39;) velocity = velocity + 10.0 print(&#39;final velocity:&#39;, velocity) . 0 : 10.0 moving too slow 1 : 20.0 moving too slow 2 : 30.0 moving too fast 3 : 25.0 moving too fast 4 : 20.0 moving too slow final velocity: 30.0 . The program must have a print statement outside the body of the loop to show the final value of velocity, since its value is updated by the last iteration of the loop. . Compound Relations Using and, or, and Parentheses . Often, you want some combination of things to be true. You can combine relations within a conditional using and and or. Continuing the example above, suppose you have . mass = [ 3.54, 2.07, 9.22, 1.86, 1.71] velocity = [10.00, 20.00, 30.00, 25.00, 20.00] i = 0 for i in range(5): if mass[i] &gt; 5 and velocity[i] &gt; 20: print(&quot;Fast heavy object. Duck!&quot;) elif mass[i] &gt; 2 and mass[i] &lt;= 5 and velocity[i] &lt;= 20: print(&quot;Normal traffic&quot;) elif mass[i] &lt;= 2 and velocity[i] &lt;= 20: print(&quot;Slow light object. Ignore it&quot;) else: print(&quot;Whoa! Something is up with the data. Check it&quot;) . Normal traffic Normal traffic Fast heavy object. Duck! Whoa! Something is up with the data. Check it Slow light object. Ignore it . Just like with arithmetic, you can and should use parentheses whenever there is possible ambiguity. A good general rule is to always use parentheses when mixing and and or in the same condition. That is, instead of: . if mass[i] &lt;= 2 or mass[i] &gt;= 5 and velocity[i] &gt; 20: . write one of these: . if (mass[i] &lt;= 2 or mass[i] &gt;= 5) and velocity[i] &gt; 20: . if mass[i] &lt;= 2 or (mass[i] &gt;= 5 and velocity[i] &gt; 20): . so it is perfectly clear to a reader (and to Python) what you really mean. . . Do the quick-test. . Back to Python part two. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Conditionals.html",
            "relUrl": "/2021/08/02/Conditionals.html",
            "date": " ‚Ä¢ Aug 2, 2021"
        }
        
    
  
    
        ,"post32": {
            "title": "Conditionals - quick test",
            "content": "Tracing Execution . What does this program print? . pressure = 71.9 if pressure 50.0: pressure = 25.0 elif pressure &lt;= 50.0: pressure = 0.0 print(pressure) . Show answer 25.0 . Trimming Values . Fill in the blanks so that this program creates a new list containing zeroes where the original list‚Äôs values were negative and ones where the original list‚Äôs values were positive. . original = [-1.5, 0.2, 0.4, 0.0, -1.3, 0.4] result = ____ for value in original: if ____: result.append(0) else: ____ print(result) . [0, 1, 1, 1, 0, 1] . Show answer original = [-1.5, 0.2, 0.4, 0.0, -1.3, 0.4] result = [] for value in original: if value&lt;0.0: result.append(0) else: result.append(1) print(result) . Initializing . Modify this program so that it finds the largest and smallest values in the list no matter what the range of values originally is. . values = [...some test data...] smallest, largest = None, None for v in values: if ____: smallest, largest = v, v ____: smallest = min(____, v) largest = max(____, v) print(smallest, largest) . What are the advantages and disadvantages of using this method to find the range of the data? . Show answer values = [-2,1,65,78,-54,-24,100] smallest, largest = None, None for v in values: if smallest==None and largest==None: smallest, largest = v, v else: smallest = min(smallest, v) largest = max(largest, v) print(smallest, largest) . . See the notebook. . Back to Python part two. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Conditionals-Qs.html",
            "relUrl": "/2021/08/02/Conditionals-Qs.html",
            "date": " ‚Ä¢ Aug 2, 2021"
        }
        
    
  
    
        ,"post33": {
            "title": "Cleaning data - quick test",
            "content": "Pandas or Numpy . Pandas and NumPy are both essential libraries for scientific computation due to their intuitive syntax and high-performance matrix computation capabilities. In which contexts might Pandas be a more useful library than Numpy (and vice-verca)? . Show answer The Pandas module works well with tabular data. Pandas provides 2d table object called DataFrame. | The NumPy module works well with numerical data. NumPy provides a multi-dimensional array, well suited to matrix operations. | If memory is a limiting factor, NumPy typically consumes less memory than Pandas. | . Crack the code . Crack the code using the dataframe df . . df.loc[3,0:1] df.loc[0,4] df.loc[3,4] df.loc[0,4] df.loc[0,3] df.loc[3,3] df.loc[4,2:3] . Show answer Mmm, tasty tasty ‚Äústewed veg‚Äù. . . See the notebook. . Back to Data analysis and visualisation. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Cleaning-Data-Qs.html",
            "relUrl": "/2021/08/02/Cleaning-Data-Qs.html",
            "date": " ‚Ä¢ Aug 2, 2021"
        }
        
    
  
    
        ,"post34": {
            "title": "Analysing data with NumPy",
            "content": "Questions: . How can I import and analyse tabular data files in Python? | . Objectives: . Read tabular data from a file into a program using numpy. | Select individual values and subsections from data. | Perform operations on arrays of data. | . Keypoints: . Use the numpy library to work with arrays in Python. | The expression array.shape gives the shape of an array. | Use array[x, y] to select a single element from a 2D array. | Array indices start at 0, not 1. | All the indexing and slicing that we&#39;ve used on lists and strings also works on arrays. | Use low:high to specify a slice that includes indices from low to high-1. | Arithmetic operations are done element-by-element. | Use numpy.mean(array), numpy.max(array), and numpy.min(array) to calculate simple statistics. | Use numpy.mean(array, axis=0) or numpy.mean(array, axis=1) to calculate the mean along a particular column or row | . Use the numpy library to work with arrays in Python. . In general you should use the NumPy library if you want to do fancy things with numbers, especially if you have matrices or arrays. . import numpy . First lets ask the library to read our cleaned data file for us: . numpy.loadtxt(fname=&#39;../data/UVVis-01-cleaned.csv&#39;, delimiter=&#39;,&#39;) . array([[ 4.47125000e-04, 6.55591000e-04, 8.64056000e-04, ..., 1.00000000e+01, 1.29667747e+00, 1.66669679e+00], [-3.66223800e-03, -3.49741500e-03, -3.34321500e-03, ..., -1.22419536e-01, -7.07442700e-03, -1.82473719e-01], [ 2.23267300e-03, 2.29731000e-03, 2.47505900e-03, ..., 3.31975669e-01, 3.77199233e-01, 3.53418890e-02], ..., [ 1.20771340e-02, 1.22769590e-02, 1.24000520e-02, ..., 3.11538220e-02, 1.53292596e-01, -2.67419547e-01], [ 3.98183100e-03, 4.22229500e-03, 4.32843200e-03, ..., -1.33138746e-01, -6.67433520e-02, 1.55003861e-01], [ 4.21040200e-03, 4.36906300e-03, 4.38802100e-03, ..., 8.95578190e-02, 8.41182170e-02, 1.43565789e-01]]) . The expression numpy.loadtxt(...) is a function call that asks Python to run the function loadtxt which belongs to the numpy library. . numpy.loadtxt has two parameters: the name of the file we want to read and the delimeter that separates values on a line. These both need to be character strings , so we put them in quotes. . Let&#39;s re-run numpy.loadtxt and save the returned data: . data = numpy.loadtxt(fname=&#39;../data/UVVis-01-cleaned.csv&#39;, delimiter=&#39;,&#39;) . Remember, this statement doesn&#39;t produce any output because we&#39;ve assigned the output to the variable data. If we want to check that the data have been loaded, we can print the variable&#39;s value: . print(data) . [[ 4.47125000e-04 6.55591000e-04 8.64056000e-04 ... 1.00000000e+01 1.29667747e+00 1.66669679e+00] [-3.66223800e-03 -3.49741500e-03 -3.34321500e-03 ... -1.22419536e-01 -7.07442700e-03 -1.82473719e-01] [ 2.23267300e-03 2.29731000e-03 2.47505900e-03 ... 3.31975669e-01 3.77199233e-01 3.53418890e-02] ... [ 1.20771340e-02 1.22769590e-02 1.24000520e-02 ... 3.11538220e-02 1.53292596e-01 -2.67419547e-01] [ 3.98183100e-03 4.22229500e-03 4.32843200e-03 ... -1.33138746e-01 -6.67433520e-02 1.55003861e-01] [ 4.21040200e-03 4.36906300e-03 4.38802100e-03 ... 8.95578190e-02 8.41182170e-02 1.43565789e-01]] . First, let&#39;s ask what type of thing data refers to: . print(type(data)) . &lt;class &#39;numpy.ndarray&#39;&gt; . The output tells us that data currently refers to an N-dimensional array, the functionality for which is provided by the NumPy library. The rows are the individual samples, and the columns are the absorption at each wavelength. . . Note: A Numpy array contains one or more elements of the same type. The type function will only tell you that a variable is a NumPy array but won&#39;t tell you the type of thing inside the array. We can find out the type of the data contained in the NumPy array using print(data.dtype). . The expression array.shape gives the shape of an array. . With the following command, we can see the array&#39;s shape: . print(data.shape) . (10, 1301) . The output tells us that the data array variable contains 10 rows and 1301 columns. When we created the variable data to store our absorption data, we didn&#39;t just create the array; we also created information about the array, called members or attributes. This extra information describes data in the same way an adjective describes a noun. data.shape is an attribute of data which describes the dimensions of data. We use the same dotted notation for the attributes of variables that we use for the functions in libraries because they have the same part-and-whole relationship. . Use array[x, y] to select a single element from a 2D array. . If we want to get a single number from the array, we must provide an index in square brackets after the variable name, just as we do in math when referring to an element of a matrix. Our absorption data has two dimensions, so we will need to use two indices to refer to one specific value: . print(&#39;first value in data:&#39;, data[0, 0]) . first value in data: 0.000447125 . print(&#39;middle value in data:&#39;, data[5, 600]) . middle value in data: 0.05236074 . Array indices start at 0, not 1. . The expression data[5, 600] accesses the element at row 5, column 600. While this expression may not surprise you, data[0, 0] might. Programming languages like Fortran, MATLAB and R start counting at 1 because that&#39;s what human beings have done for thousands of years. Languages in the C family (including C++, Java, Perl, and Python) count from 0 because it represents an offset from the first value in the array (the second value is offset by one index from the first value). This is closer to the way that computers represent arrays (if you are interested in the historical reasons behind counting indices from zero, you can read Mike Hoye&#39;s blog post). As a result, if we have an M√óN array in Python, its indices go from 0 to M-1 on the first axis and 0 to N-1 on the second. It takes a bit of getting used to, but one way to remember the rule is that the index is how many steps we have to take from the start to get the item we want. . . . Note: What may also surprise you is that when Python displays an array, it shows the element with index [0, 0] in the upper left corner rather than the lower left. This is consistent with the way mathematicians draw matrices but different from the Cartesian coordinates. The indices are (row, column) instead of (column, row) for the same reason, which can be confusing when plotting data. . All the indexing and slicing that we&#39;ve used on lists and strings also works on arrays. . An index like [5, 600] selects a single element of an array, but we can select whole sections as well. For example, we can select the first ten days (columns) of values for the first four patients (rows) like this: . print(data[0:4, 0:10]) . [[ 0.00044712 0.00065559 0.00086406 0.00107252 0.00128099 0.00148945 0.00169792 0.00190638 0.00211485 0.00232331] [-0.00366224 -0.00349741 -0.00334322 -0.0036817 -0.00405294 -0.00324795 -0.00336376 -0.00375587 -0.00342078 -0.00319713] [ 0.00223267 0.00229731 0.00247506 0.00222341 0.00225055 0.00260366 0.00255431 0.00229944 0.00254705 0.00278302] [ 0.0060851 0.00631194 0.00641883 0.00616071 0.00553703 0.00655359 0.00648117 0.00620936 0.00630154 0.00666987]] . Use low:high to specify a slice that includes indices from low to high-1. . The slice 0:4 means, &quot;Start at index 0 and go up to, but not including, index 4.&quot;Again, the up-to-but-not-including takes a bit of getting used to, but the rule is that the difference between the upper and lower bounds is the number of values in the slice. . We don&#39;t have to start slices at 0: . print(data[5:10, 0:10]) . [[0.01210117 0.01231773 0.01241982 0.01212973 0.01202739 0.01261753 0.01251138 0.01232068 0.01247477 0.01260437] [0.01206768 0.01227019 0.01239462 0.01212571 0.01220084 0.01219452 0.0122772 0.01225797 0.01248005 0.01262111] [0.01207713 0.01227696 0.01240005 0.01214027 0.01222512 0.01238692 0.01246438 0.01226141 0.01244613 0.01270402] [0.00398183 0.0042223 0.00432843 0.00407767 0.00415076 0.00426605 0.00438313 0.00419297 0.00439255 0.0046121 ] [0.0042104 0.00436906 0.00438802 0.00414603 0.0041499 0.00446744 0.00435411 0.00416835 0.00443187 0.00467494]] . We also don&#39;t have to include the upper and lower bound on the slice. If we don&#39;t include the lower bound, Python uses 0 by default; if we don&#39;t include the upper, the slice runs to the end of the axis, and if we don&#39;t include either (i.e., if we just use &#39;:&#39; on its own), the slice includes everything: . small = data[:3, 36:] print(&#39;small is:&#39;) print(small) . small is: [[ 7.95187800e-03 8.16034400e-03 8.36880900e-03 ... 1.00000000e+01 1.29667747e+00 1.66669679e+00] [-2.69293800e-03 -2.44559000e-03 -2.69407000e-03 ... -1.22419536e-01 -7.07442700e-03 -1.82473719e-01] [ 3.43972300e-03 3.70568000e-03 3.41978900e-03 ... 3.31975669e-01 3.77199233e-01 3.53418890e-02]] . The above example selects rows 0 through 2 and columns 36 through to the end of the array. . Arithmetic operations are done element-by-element . Arrays also know how to perform common mathematical operations on their values. The simplest operations with data are arithmetic: addition, subtraction, multiplication, and division. When you do such operations on arrays, the operation is done element-by-element. Thus: . doubledata = data * 2.0 . will create a new array doubledata each element of which is twice the value of the corresponding element in data: . print(&#39;original:&#39;) print(data[:3, 36:]) print(&#39;doubledata:&#39;) print(doubledata[:3, 36:]) . original: [[ 7.95187800e-03 8.16034400e-03 8.36880900e-03 ... 1.00000000e+01 1.29667747e+00 1.66669679e+00] [-2.69293800e-03 -2.44559000e-03 -2.69407000e-03 ... -1.22419536e-01 -7.07442700e-03 -1.82473719e-01] [ 3.43972300e-03 3.70568000e-03 3.41978900e-03 ... 3.31975669e-01 3.77199233e-01 3.53418890e-02]] doubledata: [[ 1.59037560e-02 1.63206880e-02 1.67376180e-02 ... 2.00000000e+01 2.59335494e+00 3.33339357e+00] [-5.38587600e-03 -4.89118000e-03 -5.38814000e-03 ... -2.44839072e-01 -1.41488540e-02 -3.64947438e-01] [ 6.87944600e-03 7.41136000e-03 6.83957800e-03 ... 6.63951338e-01 7.54398466e-01 7.06837780e-02]] . If, instead of taking an array and doing arithmetic with a single value (as above), you did the arithmetic operation with another array of the same shape, the operation will be done on corresponding elements of the two arrays. Thus: . tripledata = doubledata + data . will give you an array where tripledata[0,0] will equal doubledata[0,0] plus data[0,0], and so on for all other elements of the arrays. . print(&#39;tripledata:&#39;) print(tripledata[:3, 36:]) . tripledata: [[ 2.38556340e-02 2.44810320e-02 2.51064270e-02 ... 3.00000000e+01 3.89003241e+00 5.00009036e+00] [-8.07881400e-03 -7.33677000e-03 -8.08221000e-03 ... -3.67258608e-01 -2.12232810e-02 -5.47421157e-01] [ 1.03191690e-02 1.11170400e-02 1.02593670e-02 ... 9.95927007e-01 1.13159770e+00 1.06025667e-01]] . Use numpy.mean(array), numpy.max(array), and numpy.min(array) to calculate simple statistics. . Often, we want to do more than add, subtract, multiply, and divide array elements. NumPy knows how to do more complex operations, too. If we want to find the average absorption for all samples across all wavelengths, for example, we can ask NumPy to compute data&#39;s mean value: . print(numpy.mean(data)) . 0.0814548568076864 . mean is a function that takes an array as an argument. . . Note: Generally, a function uses inputs to produce outputs. However, some functions produce outputs without needing any input. For example, checking the current time with print(time.ctime()) doesn&#39;t require any input. For functions that don&#39;t take in any arguments, we still need parentheses () to tell Python to go and do something for us. . NumPy has lots of useful functions that take an array as input. Let&#39;s use three of those functions to get some descriptive values about the dataset. We&#39;ll also use multiple assignment, a convenient Python feature that will enable us to do this all in one line. . maxval, minval, stdval = numpy.max(data), numpy.min(data), numpy.std(data) print(&#39;maximum absorption:&#39;, maxval) print(&#39;minimum absorption:&#39;, minval) print(&#39;standard deviation:&#39;, stdval) . maximum absorption: 10.0 minimum absorption: -1.036568046 standard deviation: 0.24849228257073133 . Here we&#39;ve assigned the return value from numpy.max(data) to the variable maxval, the value from numpy.min(data) to minval, and so on. . Use numpy.mean(array, axis=0) or numpy.mean(array, axis=1) to calculate the mean along a particular column or row . When analyzing data, though, we often want to look at variations in statistical values, such as the maximum absorption per sample or the average absorption per wavelength. One way to do this is to create a new temporary array of the data we want, then ask it to do the calculation: . sample_0 = data[0, :] # 0 on the first axis (rows), everything on the second (columns) print(&#39;maximum absorption for sample 0:&#39;, sample_0.max()) . maximum absorption for sample 0: 10.0 . . Tip: Everything in a line of code following the &#8217;#&#8217; symbol is a comment that is ignored by Python. Comments allow programmers to leave explanatory notes for other programmers or their future selves. . We don&#39;t actually need to store the row in a variable of its own. Instead, we can combine the selection and the function call: . print(&#39;maximum absorption for sample 2:&#39;, numpy.max(data[2, :])) . maximum absorption for sample 2: 0.377199233 . What if we need the maximum absorption for each patient over all wavelengths (as in the next diagram on the left) or the average for each wavelength (as in the diagram on the right)? As the diagram below shows, we want to perform the operation across an axis: . . To support this functionality, most array functions allow us to specify the axis we want to work on. If we ask for the average across axis 0 (rows in our 2D example), we get: . print(numpy.mean(data, axis=0)) . [0.00556981 0.00575402 0.00588247 ... 1.07087656 0.34124763 0.27600167] . As a quick check, we can ask this array what its shape is: . print(numpy.mean(data, axis=0).shape) . (1301,) . The expression (1301,) tells us we have an N√ó1 vector, so this is the average absorption per day for all samples. If we average across axis 1 (columns in our 2D example), we get: . print(numpy.mean(data, axis=1)) . [0.13104075 0.02947129 0.02323768 0.08578812 0.07745822 0.10012283 0.10339795 0.09871813 0.08216419 0.08314941] . which is the average absorption per sample across all wavelengths. . . Do the quick-test. . Back to data analysis and visualisation. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Analysing-Data.html",
            "relUrl": "/2021/08/02/Analysing-Data.html",
            "date": " ‚Ä¢ Aug 2, 2021"
        }
        
    
  
    
        ,"post35": {
            "title": "Analysing data - quick test",
            "content": "Encapsulation . Fill in the blanks to create a function that takes a single filename, containing comma separated values, as an argument, loads the data in the file named by the argument, and returns the minimum value in that data. . import numpy def min_in_data(____): data = ____ return ____ . Show answer import numpy def min_in_data(filename): data = numpy.loadtxt(fname=filename, delimiter=&#39;,&#39;) return data.min() . Stacking Arrays . Arrays can be concatenated and stacked on top of one another, using NumPy‚Äôs vstack and hstack functions for vertical and horizontal stacking, respectively. . import numpy A = numpy.array([[1,2,3], [4,5,6], [7, 8, 9]]) print(&#39;A = &#39;) print(A) B = numpy.hstack([A, A]) print(&#39;B = &#39;) print(B) C = numpy.vstack([A, A]) print(&#39;C = &#39;) print(C) . A = [[1 2 3] [4 5 6] [7 8 9]] B = [[1 2 3 1 2 3] [4 5 6 4 5 6] [7 8 9 7 8 9]] C = [[1 2 3] [4 5 6] [7 8 9] [1 2 3] [4 5 6] [7 8 9]] . Write some additional code that slices the first and last columns of A, and stacks them into a 3x2 array. Make sure to print the results to verify your solution. . Show answer A ‚Äògotcha‚Äô with array indexing is that singleton dimensions are dropped by default. That means A[:, 0] is a one dimensional array, which won‚Äôt stack as desired. To preserve singleton dimensions, the index itself can be a slice or array. For example, A[:, :1] returns a two dimensional array with one singleton dimension (i.e. a column vector). . D = numpy.hstack((A[:, :1], A[:, -1:])) print(&#39;D = &#39;) print(D) . D = [[1 3] [4 6] [7 9]] . An alternative way to achieve the same result is to use Numpy‚Äôs delete function to remove the second column of A. . D = numpy.delete(A, 1, 1) print(&#39;D = &#39;) print(D) . D = [[1 3] [4 6] [7 9]] . . See the notebook. . Back to Data analysis and visualisation. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/Analysing-Data-Qs.html",
            "relUrl": "/2021/08/02/Analysing-Data-Qs.html",
            "date": " ‚Ä¢ Aug 2, 2021"
        }
        
    
  
    
        ,"post36": {
            "title": "Variables and assignment",
            "content": ". Questions: . How can I store data in programs? | . Objectives: . Write programs that assign scalar values to variables and perform calculations with those values. | Correctly trace value changes in programs that use scalar assignment. | . Keypoints: . Use variables to store values. | Use print to display values. | Variables must be created before they are used. | Variables persist between cells. | Variables can be used in calculations. | Python is case-sensitive. | Use valid and meaningful variable names. | . . Use variables to store values. . Variables are names for values. | In Python the = symbol assigns the value on the right to the name on the left. | The variable is created when a value is assigned to it. | Here, Python assigns an age to a variable age and a name in quotes to a variable first_name. | . age = 42 first_name = &#39;Ahmed&#39; . Use print to display values. . Python has a built-in function called print that prints things as text. | Call the function (i.e., tell Python to run it) by using its name. | Provide values to the function (i.e., the things to print) in parentheses. | To add a string to the printout, wrap the string in single or double quotes. | The values passed to the function are called &#39;arguments&#39; | . print(first_name, &#39;is&#39;, age, &#39;years old&#39;) . Ahmed is 42 years old . print automatically puts a single space between items to separate them. | And wraps around to a new line at the end. | . Variables must be created before they are used. . Unlike some languages, which &quot;guess&quot; a default value, if a variable doesn&#39;t exist yet, or if the name has been mis-spelled, Python reports an error. | . print(last_name) . NameError Traceback (most recent call last) /var/folders/5q/mny3pg2n7h5g21h3v32rfj9wpykqrf/T/ipykernel_792/2256896230.py in &lt;module&gt; -&gt; 1 print(last_name) 2 NameError: name &#39;last_name&#39; is not defined . The last line of an error message is usually the most informative. | We will look at error messages in detail later. | . Variables Persist Between Cells . Be aware that it is the order of execution of cells that is important in a Jupyter notebook, not the order in which they appear. Python will remember all the code that was run previously, including any variables you have defined, irrespective of the order in the notebook. Therefore if you define variables lower down the notebook and then (re)run cells further up, those defined further down will still be present. As an example, we can create 2 cells with the following content, in this order: . print(myval) . myval = 1 . If you execute this in order, the first cell will give an error. However, if you run the first cell after the second cell it will print out ‚Äò1‚Äô. To prevent confusion, it can be helpful to use the Kernel -&gt; Restart &amp; Run All option which clears the interpreter and runs everything from a clean slate going top to bottom. . Variables can be used in calculations. . We can use variables in calculations just as if they were values. | . age = 42 age = age + 3 print(&#39;Age in three years:&#39;, age) . Age in three years: 45 . Python is case-sensitive. . Python thinks that upper- and lower-case letters are different, so Name and name are different variables. | There are conventions for using upper-case letters at the start of variable names so we will use lower-case letters for now. | . . Tip: In programming an eye for detail is important. If you include an extra full-stop, or forget a space, then you may get an error message or unexpected behaviour. . Use valid and meaningful variable names. . Python doesn&#39;t care what you call variables as long as they obey the following rules: . can only contain letters, digits, and underscore _ (typically used to separate words in long variable names) | cannot start with a digit | . | Variable names that start with underscores like __bobbins_real_age have a special meaning so we won&#39;t do that until we understand the convention. . | . flabadab = 42 ewr_422_yY = &#39;Ahmed&#39; print(ewr_422_yY, &#39;is&#39;, flabadab, &#39;years old&#39;) . Use meaningful variable names to help other people understand what the program does. | The most important &quot;other person&quot; is your future self. | . . Do the quick-test. . Back to Python part one. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/02-Variables-Assignment.html",
            "relUrl": "/2021/08/02/02-Variables-Assignment.html",
            "date": " ‚Ä¢ Aug 2, 2021"
        }
        
    
  
    
        ,"post37": {
            "title": "Variables and assignment - quick test",
            "content": "Swapping Values . Fill the table showing the values of the variables in this program after each statement is executed. . Command Value of x Value of y Value of swap . x = 1.0 | ¬† | ¬† | ¬† | . y = 3.0 | ¬† | ¬† | ¬† | . swap = x | ¬† | ¬† | ¬† | . x = y | ¬† | ¬† | ¬† | . y = swap | ¬† | ¬† | ¬† | . Show answer Command Value of x Value of y Value of swap . x = 1.0 | 1.0 | not defined | not defined | . y = 3.0 | 1.0 | 3.0 | not defined | . swap = x | 1.0 | 3.0 | 1.0 | . x = y | 3.0 | 3.0 | 1.0 | . y = swap | 3.0 | 1.0 | 1.0 | . These three lines exchange the values in x and y using the swap variable for temporary storage. This is a fairly common programming idiom. . Predicting Values . What is the final value of position in the program below? (Try to predict the value without running the program, then check your prediction.) . initial = &#39;left&#39; position = initial initial = &#39;right&#39; . Show answer The final value of position is &#39;left&#39;. . The initial variable is assigned the value ‚Äòleft‚Äô. In the second line, the position variable also receives the string value ‚Äòleft‚Äô. In third line, the initial variable is given the value ‚Äòright‚Äô, but the position variable retains its string value of ‚Äòleft‚Äô. . Choosing a Name . Which is a better variable name, m, min, or minutes? Why? . Hint: think about which code you would rather inherit from someone who is leaving the lab: . ts = m * 60 + s tot_sec = min * 60 + sec total_seconds = minutes * 60 + seconds . Show answer minutes is better because min might mean something like ‚Äúminimum‚Äù (and actually does in Python, but we haven‚Äôt seen that yet). . . See the notebook. . Back to Python part one. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/02-Variables-Assignment-Qs.html",
            "relUrl": "/2021/08/02/02-Variables-Assignment-Qs.html",
            "date": " ‚Ä¢ Aug 2, 2021"
        }
        
    
  
    
        ,"post38": {
            "title": "Running python - quick test",
            "content": "Creating Lists in Markdown . Create a nested list in a Markdown cell in a notebook that looks like this: . Get funding. | Do work. Design experiment. | Collect data. | Analyze. | . | Write up. | Publish. | Show answer Note that the bullet list is indented 2 spaces so that it is inline with the items of the numbered list. . 1. Get funding. 2. Do work. * Design experiment. * Collect data. * Analyze. 3. Write up. 4. Publish. . Multiple Maths . What is displayed when a Python cell in a notebook that contains several calculations is executed? For example, what happens when this cell is executed? . 7 * 3 2 + 1 . Show answer Python returns the output of the last calculation. The output is: . 3 . Equations . Standard Markdown (such as we‚Äôre using for these notes) won‚Äôt render equations, but the Notebook will. Create a new Markdown cell and enter the following: . $ sum_{i=1}^{N} 2^{-i} approx 1$ . (It‚Äôs probably easier to copy and paste.) What does it display? What do you think the underscore, _, circumflex, ^, and dollar sign, $, do? . Show answer The notebook shows the equation as it would be rendered from LaTeX equation syntax. . The dollar sign, $, is used to tell markdown that the text in between is a latex equation. | underscore, _, is used for subscripts | circumflex, ^, is used for superscripts. | A pair of curly braces, { and }, is used to group text together so that the statement i=1 becomes the the subscript and N becomes the superscript. | Similarly, -i is in curly braces to make the whole statement the superscript for 2. | sum and approx are latex commands for ‚Äúsum over‚Äù and ‚Äúapproximate‚Äù symbols. | . . See the notebook. . Back to Python part one. . .",
            "url": "https://nu-cem.github.io/CompPhys/2021/08/02/01-Running_python-Qs.html",
            "relUrl": "/2021/08/02/01-Running_python-Qs.html",
            "date": " ‚Ä¢ Aug 2, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About",
          "content": "This website contains resources for the second year course ‚ÄúTheory, computation and experiment‚Äù (KD5081) at Northumbria University, UK. The resources have been developed by Dr Lucy Whalley and the website is powered by Github and fastpages which is licensed under Apache License 2.0. . The content of this website is derived from several other sources: . Software Carpentry (Setup and the ‚ÄúGetting started‚Äù section) | Code Refinery (‚ÄúGetting it out there‚Äù) | pycharge (landing page animation) | Rudolf Winter‚Äôs notes on ODEs and PDEs (‚ÄúGetting results‚Äù) | 3blue1brown Youtube videos (‚ÄúGetting results‚Äù) | The book Computational Physics by Mark Newman (Some of the exercises are adapted from this book and are under the copyright of the the author Mark Newman) | . The content of this website unless otherwise indicated is licensed under a Creative Commons Attribution 4.0 International License. You can re-use any of its content as long as an attribution is included, and you indicate if changes were made. .",
          "url": "https://nu-cem.github.io/CompPhys/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  

  

  
  

  
      ,"page12": {
          "title": "",
          "content": "Sitemap: {{ ‚Äúsitemap.xml‚Äù | absolute_url }} | .",
          "url": "https://nu-cem.github.io/CompPhys/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}